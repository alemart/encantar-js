/*!
 * encantar.js version 0.4.4-dev
 * GPU-accelerated Augmented Reality for the web
 * Copyright 2022-2025 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * https://encantar.dev
 *
 * @license LGPL-3.0-or-later
 * Date: 2025-04-03T14:20:53.606Z
*/
var AR=(()=>{var zA=Object.create;var zo=Object.defineProperty;var FA=Object.getOwnPropertyDescriptor;var UA=Object.getOwnPropertyNames;var XA=Object.getPrototypeOf,GA=Object.prototype.hasOwnProperty;var Fo=_=>{throw TypeError(_)};var le=(_,t)=>()=>(_&&(t=_(_=0)),t);var Uo=(_,t)=>()=>(t||_((t={exports:{}}).exports,t),t.exports);var HA=(_,t,n,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of UA(t))!GA.call(_,r)&&r!==n&&zo(_,r,{get:()=>t[r],enumerable:!(o=FA(t,r))||o.enumerable});return _};var Ne=(_,t,n)=>(n=_!=null?zA(XA(_)):{},HA(t||!_||!_.__esModule?zo(n,"default",{value:_,enumerable:!0}):n,_));var Xo=(_,t,n)=>t.has(_)||Fo("Cannot "+n);var Vt=(_,t,n)=>(Xo(_,t,"read from private field"),n?n.call(_):t.get(_)),hi=(_,t,n)=>t.has(_)?Fo("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(_):t.set(_,n),gi=(_,t,n,o)=>(Xo(_,t,"write to private field"),o?o.call(_,n):t.set(_,n),n);var be=Uo((fi,Lr)=>{/*!
 * Speedy Vision version 0.9.1
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2024 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * https://github.com/alemart/speedy-vision
 *
 * @license Apache-2.0
 * Date: 2024-07-03T02:16:25.769Z
 */(function(t,n){typeof fi=="object"&&typeof Lr=="object"?Lr.exports=n():typeof define=="function"&&define.amd?define([],n):typeof fi=="object"?fi.Speedy=n():t.Speedy=n()})(self,()=>(()=>{var _={2199:(r,a,A)=>{"use strict";A.d(a,{w:()=>I});var c=A(6634),u=A(1001),g=A(9037),f=A(8581);let d="raf",y="default";class I extends c.Q{static get powerPreference(){return u.c.powerPreference}static set powerPreference(S){u.c.powerPreference=S}static get gpuPollingMode(){return d}static set gpuPollingMode(S){if(S!=="raf"&&S!=="asap")throw new f.qw(`Invalid GPU polling mode: "${S}"`);d=S}static get logging(){return y}static set logging(S){if(S!=="default"&&S!=="none"&&S!=="diagnostic")throw new f.qw(`Invalid logging mode: "${S}"`);S==="diagnostic"&&g.A.log("%c DIAGNOSTIC MODE ","background:red;color:white;font-size:36pt;font-weight:bold"),y=S}}},6306:(r,a,A)=>{"use strict";A.d(a,{r:()=>b});var c=A(6465),u=A(9037),g=A(8581);let f=Object.freeze({float32:Float32Array});class b{constructor(D,z,q){u.A.assert(D>0&&z>0),u.A.assert(q===b.DEFAULT_DTYPE),this._rows=D|0,this._columns=z|0,this._dtype=q}get rows(){return this._rows}get columns(){return this._columns}get dtype(){return this._dtype}static get DEFAULT_DTYPE(){return"float32"}static get BUFFER_TYPE(){return f}plus(D){return new E(this,D)}minus(D){return new R(this,D)}times(D){return typeof D=="number"?new N(this,D):new B(this,D)}transpose(){return new S(this)}inverse(){return new M(this)}compMult(D){return new Q(this,D)}ldiv(D){return new U(this,D)}toString(){return`SpeedyMatrixExpr(rows=${this.rows}, columns=${this.columns})`}_evaluate(D,z){throw new g.aQ}}let{SpeedyMatrix:d}=A(4188);class y extends b{constructor(D,z,q){super(D,z,q),this._tempMatrix=d.Zeros(this.rows,this.columns,this.dtype)}}class I extends y{constructor(D,z,q){super(D,z,q.dtype),this._operand=q}_evaluate(D,z){let q=this._operand._evaluate(D,z),j=this._tempMatrix,V=c.U.allocateMat32(D,z,j),te=c.U.allocateMat32(D,z,q);return c.U.copyToMat32(D,z,te,q),this._compute(D,z,V,te),c.U.copyFromMat32(D,z,V,j),c.U.deallocateMat32(D,z,te),c.U.deallocateMat32(D,z,V),j}_compute(D,z,q,j){throw new g.aQ}}class x extends y{constructor(D,z,q,j){u.A.assert(q.dtype===j.dtype),super(D,z,q.dtype),this._left=q,this._right=j}_evaluate(D,z){let q=this._left._evaluate(D,z),j=this._right._evaluate(D,z),V=this._tempMatrix,te=c.U.allocateMat32(D,z,V),ge=c.U.allocateMat32(D,z,q),Be=c.U.allocateMat32(D,z,j);return c.U.copyToMat32(D,z,ge,q),c.U.copyToMat32(D,z,Be,j),this._compute(D,z,te,ge,Be),c.U.copyFromMat32(D,z,te,V),c.U.deallocateMat32(D,z,Be),c.U.deallocateMat32(D,z,ge),c.U.deallocateMat32(D,z,te),V}_compute(D,z,q,j,V){throw new g.aQ}}class S extends I{constructor(D){super(D.columns,D.rows,D)}_compute(D,z,q,j){D.exports.Mat32_transpose(q,j)}}class M extends I{constructor(D){u.A.assert(D.rows===D.columns),super(D.rows,D.columns,D),this._size=D.rows}_compute(D,z,q,j){switch(this._size){case 0:break;case 1:D.exports.Mat32_inverse1(q,j);break;case 2:D.exports.Mat32_inverse2(q,j);break;case 3:D.exports.Mat32_inverse3(q,j);break;default:D.exports.Mat32_qr_inverse(q,j);break}}}class N extends I{constructor(D,z){super(D.rows,D.columns,D),this._scalar=+z}_compute(D,z,q,j){D.exports.Mat32_scale(q,j,this._scalar)}}class E extends x{constructor(D,z){u.A.assert(D.rows===z.rows&&D.columns===z.columns),super(D.rows,D.columns,D,z)}_compute(D,z,q,j,V){D.exports.Mat32_add(q,j,V)}}class R extends x{constructor(D,z){u.A.assert(D.rows===z.rows&&D.columns===z.columns),super(D.rows,D.columns,D,z)}_compute(D,z,q,j,V){D.exports.Mat32_subtract(q,j,V)}}class B extends x{constructor(D,z){u.A.assert(D.columns===z.rows),super(D.rows,z.columns,D,z)}_compute(D,z,q,j,V){D.exports.Mat32_multiply(q,j,V)}}class Q extends x{constructor(D,z){u.A.assert(D.rows===z.rows&&D.columns===z.columns),super(z.rows,z.columns,D,z)}_compute(D,z,q,j,V){D.exports.Mat32_compmult(q,j,V)}}class U extends x{constructor(D,z){let q=D.rows,j=D.columns;u.A.assert(q>=j&&z.rows===q&&z.columns===1),super(j,1,D,z)}_compute(D,z,q,j,V){D.exports.Mat32_qr_ols(q,j,V,2)}}},6465:(r,a,A)=>{"use strict";A.d(a,{U:()=>x});var c=A(9192),u=A(8581),g=A(9037),f=A(3816);let b=A(3575),d=null,y=null,I=(N=>({as:{object:N,uint8:new Uint8Array(N.buffer),int32:new Int32Array(N.buffer),uint32:new Uint32Array(N.buffer),float32:new Float32Array(N.buffer),float64:new Float64Array(N.buffer)}}))(typeof WebAssembly>"u"?new Uint8Array(1024):new WebAssembly.Memory({initial:16,maximum:256}));class x{static ready(){return typeof WebAssembly>"u"?c.i.reject(new u.EM("This application requires WebAssembly. Please update your system.")):f.LITTLE_ENDIAN?new c.i((E,R)=>{x._ready(E,R)}):c.i.reject(new u.EM("Can't run WebAssembly code: not in a little-endian machine!"))}static get handle(){if(!d||!y)throw new u.NO("Can't get WASM handle: routines not yet loaded");return{wasm:d,memory:I,module:y}}static imports(E){let R=new S(E);return Object.getOwnPropertyNames(S.prototype).filter(B=>typeof R[B]=="function"&&B!=="constructor").reduce((B,Q)=>(B[Q]=R[Q],B),Object.create(null))}static allocateMat32(E,R,B){let Q=E.exports.malloc(B.data.byteLength);return E.exports.Mat32_create(B.rows,B.columns,B.step0,B.step1,B._data.length,Q)}static deallocateMat32(E,R,B){let Q=E.exports.Mat32_data(B);return E.exports.free(B),E.exports.free(Q),0}static copyToMat32(E,R,B,Q){g.A.assert(Q.data.byteLength===E.exports.Mat32_dataSize(B));let U=E.exports.Mat32_data(B);return R.as.float32.set(Q.data,U/Float32Array.BYTES_PER_ELEMENT),B}static copyFromMat32(E,R,B,Q){g.A.assert(Q.data.byteLength===E.exports.Mat32_dataSize(B));let U=E.exports.Mat32_data(B)/Float32Array.BYTES_PER_ELEMENT;for(let F=Q.data.length-1;F>=0;F--)Q.data[F]=R.as.float32[U+F];return B}static _ready(E,R,B=1e3){d!==null&&y!==null?E({wasm:d,memory:I,module:y}):B<=0?R(new u.MU("Can't load WASM routines")):setTimeout(x._ready,0,E,R,B-1)}}class S{constructor(E){return Object.getOwnPropertyNames(this.constructor.prototype).filter(B=>typeof this[B]=="function").filter(B=>B!=="constructor").forEach(B=>{this[B]=this[B].bind(this)}),this.memory=E,this.cstring=new M(E),Object.freeze(this)}print(E){g.A.log(this.cstring.get(E))}fatal(E){throw new u.NO(this.cstring.get(E))}bytefill(E,R,B){this.memory.as.uint8.fill(E,R,B)}copyWithin(E,R,B){this.memory.as.uint8.copyWithin(E,R,B)}}class M{constructor(E){this._decoder=new TextDecoder("utf-8"),this._memory=E}get(E){let R=this._memory.as.uint8,B=this._memory.as.uint8.byteLength,Q=E;for(;Q<B&&R[Q]!==0;)++Q;return this._decoder.decode(R.subarray(E,Q))}}(function(E){let R=B=>Uint8Array.from(atob(B),Q=>Q.charCodeAt(0));typeof WebAssembly>"u"||c.i.resolve(b).then(B=>R(B)).then(B=>WebAssembly.instantiate(B,{env:Object.assign({memory:E.as.object},x.imports(E))})).then(B=>{d=B.instance,y=B.module,B.instance.exports.srand(Date.now()*.001&4294967295),g.A.log("The WebAssembly routines have been loaded!")}).catch(B=>{throw new u.NO(`Can't load the WebAssembly routines: ${B}`,B)})})(I)},4188:(r,a,A)=>{"use strict";A.r(a),A.d(a,{SpeedyMatrix:()=>b});var c=A(6306),u=A(6465),g=A(9192),f=A(9037);class b extends c.r{constructor(y,I,x,S,M){super(y,I,c.r.DEFAULT_DTYPE),f.A.assert(M.constructor===c.r.BUFFER_TYPE[this.dtype]),f.A.assert(x>0&&S>=x),f.A.assert(M.length+y*I===0||M.length===1+x*(y-1)+S*(I-1)),this._step0=x|0,this._step1=S|0,this._data=M}static Create(y,I,x,S=c.r.DEFAULT_DTYPE){return f.A.assert(y*I>0,"Can't create a matrix without a shape"),f.A.assert(y*I===x.length,`Can't create matrix: expected ${y*I} entries, but found ${x.length}`),f.A.assert(Object.prototype.hasOwnProperty.call(c.r.BUFFER_TYPE,S),`Invalid dtype: "${S}"`),new b(y,I,1,y,Reflect.construct(c.r.BUFFER_TYPE[S],[x]))}static Zeros(y,I=y,x=c.r.DEFAULT_DTYPE){return f.A.assert(y*I>0,"Can't create a matrix without a shape"),f.A.assert(Object.prototype.hasOwnProperty.call(c.r.BUFFER_TYPE,x),`Invalid dtype: "${x}"`),new b(y,I,1,y,Reflect.construct(c.r.BUFFER_TYPE[x],[y*I]))}static Ones(y,I=y,x=c.r.DEFAULT_DTYPE){return f.A.assert(y*I>0,"Can't create a matrix without a shape"),f.A.assert(Object.prototype.hasOwnProperty.call(c.r.BUFFER_TYPE,x),`Invalid dtype: "${x}"`),new b(y,I,1,y,Reflect.construct(c.r.BUFFER_TYPE[x],[y*I]).fill(1))}static Eye(y,I=y,x=c.r.DEFAULT_DTYPE){f.A.assert(y*I>0,"Can't create a matrix without a shape"),f.A.assert(Object.prototype.hasOwnProperty.call(c.r.BUFFER_TYPE,x),`Invalid dtype: "${x}"`);let S=Reflect.construct(c.r.BUFFER_TYPE[x],[y*I]);for(let M=Math.min(y,I)-1;M>=0;M--)S[M*y+M]=1;return new b(y,I,1,y,S)}static From(y){return b.Zeros(y.rows,y.columns,y.dtype).setToSync(y)}static ready(){return u.U.ready().then(y=>{})}get data(){return this._data}get step0(){return this._step0}get step1(){return this._step1}block(y,I,x,S){f.A.assert(y<=I&&x<=S,`Invalid indices: [${y}:${I},${x}:${S}]`),y=Math.max(y,0),I=Math.min(I,this._rows-1),x=Math.max(x,0),S=Math.min(S,this._columns-1);let M=I-y+1,N=S-x+1,E=this._step0,R=this._step1,B=y*E+x*R,Q=1+I*E+S*R;return new b(M,N,E,R,this._data.subarray(B,Q))}row(y){return this.block(y,y,0,this._columns-1)}column(y){return this.block(0,this._rows-1,y,y)}diagonal(){let y=Math.min(this._rows,this._columns),I=y,x=1,S=this._step0+this._step1,M=0,N=1+(y-1)*S;return new b(I,x,S,S,this._data.subarray(M,N))}at(y,I){return y>=0&&y<this._rows&&I>=0&&I<this._columns?this._data[this._step0*y+this._step1*I]:Number.NaN}read(){let y=new Array(this._rows*this._columns),I=this._step0,x=this._step1,S=0;for(let M=0;M<this._columns;M++)for(let N=0;N<this._rows;N++)y[S++]=this._data[N*I+M*x];return y}toString(){let I=this.rows,x=this.columns,S=this.read(),M=new Array(I);for(let B=0;B<I;B++){M[B]=new Array(x);for(let Q=0;Q<x;Q++)M[B][Q]=S[Q*I+B]}let N=B=>B.toFixed(5),E=M.map(B=>"    "+B.map(N).join(", ")).join(`,
`);return`SpeedyMatrix(rows=${I}, columns=${x}, data=[
${E}
])`}setTo(y){return u.U.ready().then(I=>this.setToSync(y))}setToSync(y){let{wasm:I,memory:x}=u.U.handle,S=y._evaluate(I,x);f.A.assert(this._rows===S._rows&&this._columns===S._columns&&this.dtype===S.dtype,`Can't set the values of a ${this.rows} x ${this.columns} ${this.dtype} matrix to those of a ${S.rows} x ${S.columns} ${S.dtype} matrix`);let M=this._step0,N=this._step1,E=S._step0,R=S._step1;if(M===E&&N===R&&this._data.length===S._data.length)this._data.set(S._data);else for(let B=this._columns-1;B>=0;B--)for(let Q=this._rows-1;Q>=0;Q--)this._data[Q*M+B*N]=S._data[Q*E+B*R];return this}fill(y){return this.fillSync(y),g.i.resolve(this)}fillSync(y){if(y=+y,this._rows*this._columns===this._data.length)return this._data.fill(y),this;for(let I=0;I<this._columns;I++)for(let x=0;x<this._rows;x++)this._data[x*this._step0+I*this._step1]=y;return this}_evaluate(y,I){return this}}},6634:(r,a,A)=>{"use strict";A.d(a,{Q:()=>u});var c=A(8581);class u{constructor(){throw new c.aQ("Namespaces can't be instantiated")}}},9192:(r,a,A)=>{"use strict";A.d(a,{i:()=>d});let c=0,u=1,g=2,f=1,b=typeof queueMicrotask<"u"&&queueMicrotask||typeof process<"u"&&process.nextTick||(y=>Promise.resolve().then(()=>y()));class d{constructor(I){this._state=c,this._value=void 0,this._onFulfillment=null,this._onRejection=null,this._children=0,this[0]=this,this._parent=void 0,this._flags=0,this._fulfill=this._fulfill.bind(this),this._reject=this._reject.bind(this),this._resolve=this._resolve.bind(this),this._broadcastIfAsync=this._broadcastIfAsync.bind(this),I(this._fulfill,this._reject)}then(I,x=null){let S=new d(this._nop);return S._onFulfillment=typeof I=="function"&&I,S._onRejection=typeof x=="function"&&x,S._parent=this,this[this._children++]=S,this._flags&=~f,this._notify(),S}catch(I){return this.then(null,I)}finally(I){let x=S=>(I(),S);return this.then(x,x)}turbocharge(){let I=this;for(this._flags|=f;I._parent!==void 0;)I=I._parent,I._flags|=f;return I._notify(),this}toString(){switch(this._state){case c:return"SpeedyPromise { <pending> }";case u:return`SpeedyPromise { <fulfilled> ${this._value} }`;case g:return`SpeedyPromise { <rejected> ${this._value} }`;default:return""}}get[Symbol.toStringTag](){return"SpeedyPromise"}static resolve(I){let x=new d(this._snop);return typeof I=="object"&&I!==null&&"then"in I||typeof I=="function"&&"then"in I?x._resolve(I):(x._value=I,x._state=u),x}static reject(I){let x=new d(this._snop);return x._value=I,x._state=g,x}static all(I){return new d((x,S)=>{let M=[];for(let Q of I)M.push(Q);let N=M.length;if(N==0){x([]);return}let E=N,R=new Array(N),B=Q=>U=>{R[Q]=U,--E==0&&x(R)};for(let Q=0;Q<N;Q++){let U=M[Q];U.__proto__===d.prototype||U.__proto__===Promise.prototype?U.then(B(Q),S):d.resolve(U).then(B(Q),S)}})}static race(I){return new d((x,S)=>{let M=[];for(let E of I)M.push(E);let N=M.length;for(let E=0;E<N;E++){let R=M[E];R.__proto__===d.prototype||R.__proto__===Promise.prototype?R.then(x,S):d.resolve(R).then(x,S)}})}_fulfill(I){this._setState(u,I)}_reject(I){this._setState(g,I)}_setState(I,x){this._state==c&&(this._state=I,this._value=x,this._notify())}_notify(){if(this._state!=c){if(this._flags&f){this._broadcast();return}b(this._broadcastIfAsync)}}_broadcastIfAsync(){this._flags&f||this._broadcast()}_broadcast(){let I=this._children,x=this._state;if(x===u)for(let S=0;S<I;S++){let M=this[S],N=M._onFulfillment;try{N?N!==M._nop&&(M._resolve(N(this._value)),M._onFulfillment=M._nop):M._fulfill(this._value)}catch(E){M._reject(E)}}else if(x===g)for(let S=0;S<I;S++){let M=this[S],N=M._onRejection;try{N?N!==M._nop&&(M._resolve(N(this._value)),M._onRejection=M._nop):M._reject(this._value)}catch(E){M._reject(E)}}}_resolve(I){if(typeof I!="object"&&typeof I!="function"||I===null){this._fulfill(I);return}if(I===this)throw new TypeError;if(I.__proto__===d.prototype||I.__proto__===Promise.prototype){I.then(this._resolve,this._reject);return}try{let x=I.then;if(typeof x=="function"){let S=this._resolve,M=this._reject;try{x.call(I,N=>{S(N),S=M=this._nop},N=>{M(N),S=M=this._nop})}catch(N){S!==this._nop&&M!==this._nop&&this._reject(N)}}else this._fulfill(I)}catch(x){this._reject(x)}}_nop(){}static _snop(){}}},9420:(r,a,A)=>{"use strict";A.d(a,{gx:()=>Ye,bf:()=>Ie});var c=A(1001),u=A(9037),g=A(6049),f=A(8581);function b(){b=function($,ee){return new ae($,void 0,ee)};var se=RegExp.prototype,W=new WeakMap;function ae($,ee,_e){var ve=RegExp($,ee);return W.set(ve,_e||W.get($)),y(ve,ae.prototype)}function ne($,ee){var _e=W.get(ee);return Object.keys(_e).reduce(function(ve,pe){var Se=_e[pe];if(typeof Se=="number")ve[pe]=$[Se];else{for(var Ge=0;$[Se[Ge]]===void 0&&Ge+1<Se.length;)Ge++;ve[pe]=$[Se[Ge]]}return ve},Object.create(null))}return d(ae,RegExp),ae.prototype.exec=function($){var ee=se.exec.call(this,$);if(ee){ee.groups=ne(ee,this);var _e=ee.indices;_e&&(_e.groups=ne(_e,this))}return ee},ae.prototype[Symbol.replace]=function($,ee){if(typeof ee=="string"){var _e=W.get(this);return se[Symbol.replace].call(this,$,ee.replace(/\$<([^>]+)>/g,function(pe,Se){var Ge=_e[Se];return"$"+(Array.isArray(Ge)?Ge.join("$"):Ge)}))}if(typeof ee=="function"){var ve=this;return se[Symbol.replace].call(this,$,function(){var pe=arguments;return typeof pe[pe.length-1]!="object"&&(pe=[].slice.call(pe)).push(ne(pe,ve)),ee.apply(this,pe)})}return se[Symbol.replace].call(this,$,ee)},b.apply(this,arguments)}function d(se,W){if(typeof W!="function"&&W!==null)throw new TypeError("Super expression must either be null or a function");se.prototype=Object.create(W&&W.prototype,{constructor:{value:se,writable:!0,configurable:!0}}),Object.defineProperty(se,"prototype",{writable:!1}),W&&y(se,W)}function y(se,W){return y=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(ae,ne){return ae.__proto__=ne,ae},y(se,W)}let I=A(3816),x=Object.keys(I).filter(se=>typeof I[se]=="number").reduce((se,W)=>(se[W]=I[W],se),{}),S=Object.freeze(Object.assign(Object.assign({},x),{},{FS_USE_CUSTOM_PRECISION:0,FS_OUTPUT_TYPE:0,PIXELCOMPONENT_RED:g.kQ.RED,PIXELCOMPONENT_GREEN:g.kQ.GREEN,PIXELCOMPONENT_BLUE:g.kQ.BLUE,PIXELCOMPONENT_ALPHA:g.kQ.ALPHA})),M=(se,W)=>Object.freeze({APPLE:/(Mac|iOS|iPhone|iPad|iPod)/i.test(se)|0,APPLE_GPU:/Apple/.test(W)|0,INTEL_GRAPHICS:/Intel.*Graphics/.test(W)|0}),N=[/\/\*(.|\s)*?\*\//g,/\/\/.*$/gm],E=/^\s*@\s*include\s+"(.*?)"/gm,R=/@(\w+)@/g,B=[b(/@\s*unroll\s+?for\s*\(\s*(int|)\s*(\w+)\s*=\s*(\x2D?\d+|\w+)\s*;\s*\2\s*(<=?)\s*(\x2D?\d+|\w+)\s*;\s*\2\s*\+\+()\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,{counter:2}),b(/@\s*unroll\s+?for\s*\(\s*(int|)\s*(\w+)\s*=\s*(\x2D?\d+|\w+)\s*;\s*\2\s*(<=?)\s*(\x2D?\d+|\w+)\s*;\s*\2\s*\+=\s*(\x2D?\d+)\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,{counter:2})];class Q{static generateGLSL(W,ae,ne=null,$=null){let ee=[],_e=F(W),ve=U(W,ae,ne,$);return z(ve.replace(N[0],"").replace(N[1],"").replace(R,(pe,Se)=>String(_e.has(Se)?Number(_e.get(Se)):(ee.push(`Undefined constant ${Se}`),0))).replace(E,(pe,Se)=>Q.generateGLSL(W,D(Se))),W)+ee.map(pe=>`
#error ${pe}
`).join("")}}function U(se,W,ae=null,ne=null){let $=[];ae!==null&&$.push(ae);for(let[ee,_e]of se)$.push(`#define ${ee} ${Number(_e)}`);return $.push(W),ne!==null&&$.push(ne),$.join(`
`)}function F(se){u.A.assert(c.c.isInitialized());let W=new Map,ae=Object.assign(Object.create(null),S,M(u.A.platformString(),c.c.instance.renderer));for(let ne in ae)W.set(ne,ae[ne]);for(let[ne,$]of se)W.set(ne,$);return W}function D(se){if(String(se).match(/^[a-zA-Z0-9_-]+\.glsl$/))return A(5235)("./"+se);throw new f.kG(`Shader preprocessor: can't read file "${se}"`)}function z(se,W){let ae=q.bind(W),ne=B.length;for(let $=0;$<ne;$++)se=se.replace(B[$],ae);return se}function q(se,W,ae,ne,$,ee,_e,ve){let pe=this,Se=Number.isFinite(+ne)||pe.has(ne),Ge=Number.isFinite(+ee)||pe.has(ee);if(!Se||!Ge){if(pe.size>0)throw new f.mB(`Can't unroll loop: unknown limits (start=${ne}, end=${ee}). Code:

${se}`);return se}let Xt=pe.has(ne)?pe.get(ne):parseInt(ne),Bn=pe.has(ee)?pe.get(ee):parseInt(ee),Dn=_e.length==0?1:parseInt(_e);u.A.assert(Xt<=Bn&&Dn>0);let kt=ve.match(/\bbreak\s*;/)!==null?`switch(1) { default:
`:`{
`;kt+=`${W} ${ae};
`,Bn+=$=="<="?1:0;for(let ut=Xt;ut<Bn;ut+=Dn)kt+=`{
${ae} = ${ut};
${ve}
}
`;return kt+=`}
`,kt}let j=Object.freeze({position:"a_position",texCoord:"a_texCoord"}),V=Object.freeze({position:0,texCoord:1}),te=`#version 300 es
precision highp float;
precision highp int;

layout (location=${V.position}) in vec2 ${j.position};
layout (location=${V.texCoord}) in vec2 ${j.texCoord};
out highp vec2 texCoord;
uniform highp vec2 texSize;

#define vsinit() gl_Position = vec4(${j.position}, 0.0f, 1.0f); texCoord = ${j.texCoord};


`,ge="#define vsmain() ;",Be=`

void main() { vsinit(); vsmain(); }
`,Oe=`#version 300 es

#if @FS_USE_CUSTOM_PRECISION@ == 0
precision mediump float; // ~float16
precision mediump sampler2D;
precision highp int; // int32
#endif

#if @FS_OUTPUT_TYPE@ == 0
#define OUT_TYPE mediump vec4
#elif @FS_OUTPUT_TYPE@ == 1
#define OUT_TYPE mediump ivec4
#elif @FS_OUTPUT_TYPE@ == 2
#define OUT_TYPE mediump uvec4
#else
#error Unknown FS_OUTPUT_TYPE
#endif

out OUT_TYPE color;
in highp vec2 texCoord;
uniform highp vec2 texSize;

@include "global.glsl"

`,Xe=Symbol();class qe{constructor(W,ae,ne,$,ee){if(W!==Xe)throw new f.Er;this._arguments=[...ae],this._defines=new Map(ne),this._fragmentSource=Q.generateGLSL(this._defines,$,Oe),this._vertexSource=Q.generateGLSL(this._defines,ee,te,Be),this._uniforms=this._autodetectUniforms(this._fragmentSource+`
`+this._vertexSource),this._validateArguments(this._arguments,this._uniforms)}get fragmentSource(){return this._fragmentSource}get vertexSource(){return this._vertexSource}get attributes(){return j}get locationOfAttributes(){return V}get arguments(){return[].concat(this._arguments)}get uniforms(){return Array.from(this._uniforms.keys())}uniformType(W){if(!this._uniforms.has(W))throw new f.qw(`Unrecognized uniform variable: "${W}"`);return this._uniforms.get(W)}definedConstant(W){if(!this._defines.has(W))throw new f.qw(`Unrecognized externally defined constant: "${W}"`);return this._defines.get(W)}_autodetectUniforms(W){let ae=W,ne=/^\s*uniform\s+(highp\s+|mediump\s+|lowp\s+)?(\w+)\s+([^;]+)/gm,$=new Map,ee;for(;(ee=ne.exec(ae))!==null;){let _e=ee[2],ve=ee[3].split(",").map(pe=>pe.trim()).filter(pe=>pe);for(let pe of ve)if(pe.endsWith("]")){if(!(ee=pe.match(/(\w+)\s*\[\s*(\d+)\s*\]$/)))throw new f.mB(`Unspecified array length for uniform "${pe}" in the shader`);let[Se,Ge]=[ee[1],Number(ee[2])];for(let Xt=0;Xt<Ge;Xt++)$.set(`${Se}[${Xt}]`,_e)}else if(!$.has(pe)||$.get(pe)===_e)$.set(pe,_e);else throw new f.Er(`Redefinition of uniform "${pe}" in the shader`)}return $}_validateArguments(W,ae){for(let ne of W)if(!ae.has(ne)&&!ae.has(ne+"[0]"))throw new f.qw(`Argument "${ne}" has not been declared in the shader`)}}class ce extends qe{constructor(W,ae,ne,$,ee=ge){super(W,ae,ne,$,ee),this._fsUnprocessedSource=String($),this._vsUnprocessedSource=String(ee)}}class K extends qe{constructor(W,ae,ne,$,ee=""){if(String($).match(/^[a-zA-Z0-9_\-/]+\.glsl$/)){if(ee!=""&&!String(ee).match(/^[a-zA-Z0-9_\-/]+\.vs\.glsl$/))throw new f.kG(`Can't import vertex shader at "${ee}"`)}else throw new f.kG(`Can't import fragment shader at "${$}"`);let _e=A(4606)("./"+String($)),ve=ee!=""?A(4606)("./"+String(ee)):ge;super(W,ae,ne,_e,ve),this._fsFilepath=String($),this._vsFilepath=String(ee)}get fragmentSource(){return this._addHeader("// File: "+this._fsFilepath,super.fragmentSource)}get vertexSource(){return this._addHeader("// File: "+(this._vsFilepath!=""?this._vsFilepath:"(default-vs) "+this._fsFilepath),super.vertexSource)}_addHeader(W,ae){u.A.assert(W.startsWith("//")&&!W.includes(`
`));let ne=ae.indexOf(`
`),$=ae.substr(0,ne),ee=ae.substr(ne);return u.A.assert($.startsWith("#version ")),$+`
`+W+ee}}class J{constructor(W){if(W!==Xe)throw new f.Er;this._arguments=[],this._defines=new Map}withArguments(...W){if(this._arguments.length>0)throw new f.Er("Redefinition of shader arguments");for(let ae=0;ae<W.length;ae++)this._arguments.push(String(W[ae]));return this}withDefines(W){if(this._defines.size>0)throw new f.Er("Redefinition of externally defined constants of a shader");let ae=Object.keys(W);for(let ne of ae){let $=Number(W[ne]);this._defines.set(ne,$)}return this}build(){throw new f.aQ}}class ye extends J{constructor(W,ae,ne){super(W),this._fsSource=String(ae),this._vsSource=ne!==void 0?String(ne):void 0}build(){return new ce(Xe,this._arguments,this._defines,this._fsSource,this._vsSource)}}class ie extends J{constructor(W,ae,ne){super(W),this._fsFilepath=String(ae),this._vsFilepath=ne!==void 0?String(ne):void 0}build(){return new K(Xe,this._arguments,this._defines,this._fsFilepath,this._vsFilepath)}}function Ie(se,W=void 0){return new ie(Xe,se,W)}function Ye(se,W=void 0){return new ye(Xe,se,W)}},1672:(r,a,A)=>{"use strict";A.r(a),A.d(a,{conv2D:()=>f,convX:()=>b,convY:()=>d});var c=A(9420),u=A(9037),g=A(8581);function f(I,x=1){let S=new Float32Array(I.map(U=>+U*+x)),M=Math.sqrt(S.length)|0,N=M>>1;if(M<1||M%2==0)throw new g.qw(`Can't perform a 2D convolution with an invalid kSize of ${M}`);if(M*M!=S.length)throw new g.qw(`Invalid 2D convolution kernel of ${S.length} elements (expected: square)`);let E=N<=7?"pixelAtShortOffset":"pixelAtLongOffset",Q=`
    uniform sampler2D image;

    void main()
    {
        float alpha = threadPixel(image).a;
        vec4 result = vec4(0.0f);

        ${(U=>u.A.cartesian(u.A.symmetricRange(N),u.A.symmetricRange(N)).map(F=>U(S[(F[0]+N)*M+(F[1]+N)],F[0],F[1])).join(`
`))((U,F,D)=>`
        result += ${E}(image, ivec2(${-D|0}, ${-F|0})) * float(${+U});
    `)}

        color = vec4(result.rgb, alpha);
    }
    `;return(0,c.gx)(Q).withArguments("image")}function b(I,x=1){return y("x",I,x)}function d(I,x=1){return y("y",I,x)}function y(I,x,S=1){let M=new Float32Array(x.map(F=>+F*+S)),N=M.length,E=N>>1;if(N<1||N%2==0)throw new g.qw(`Can't perform a 1D convolution with an invalid kSize of ${N}`);if(I!="x"&&I!="y")throw new g.qw(`Can't perform 1D convolution: invalid axis "${I}"`);let R=E<=7?"pixelAtShortOffset":"pixelAtLongOffset",U=`
    uniform sampler2D image;

    void main()
    {
        float alpha = threadPixel(image).a;
        vec4 pixel = vec4(0.0f);

        ${(F=>u.A.symmetricRange(E).reduce((D,z)=>D+F(M[z+E],z),""))((F,D)=>I=="x"?`
        pixel += ${R}(image, ivec2(${-D|0}, 0)) * float(${+F});
    `:`
        pixel += ${R}(image, ivec2(0, ${-D|0})) * float(${+F});
    `)}

        color = vec4(pixel.rgb, alpha);
    }
    `;return(0,c.gx)(U).withArguments("image")}},1001:(r,a,A)=>{"use strict";A.d(a,{c:()=>N});var c=A(9037),u=A(2199),g=A(3211),f=A(9192),b=A(8581);let d=Symbol(),y="default",I=16,x=16,S=null,M=y;class N extends g.c{constructor(R){c.A.assert(R===d),super(),this._reinitializeOnContextLoss=!0,this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._vendor="",this._renderer="",this._readDriverInfo(),u.w.logging==="diagnostic"&&this._logDriverInfo()}static get instance(){return S||(S=new N(d))}get gl(){return this._gl}get canvas(){return this._canvas}get renderer(){return this._renderer}get vendor(){return this._vendor}_createCanvas(R){let B=c.A.createCanvas(I,x);return B.addEventListener("webglcontextlost",Q=>{c.A.warning("Lost WebGL2 context"),setTimeout(R,0),Q.preventDefault()},!1),B}_createContext(R){if(c.A.log(`Creating a ${M} WebGL2 rendering context...`),typeof WebGL2RenderingContext>"u")throw new b.EM("This application requires WebGL2. Please update your system.");let B=R.getContext("webgl2",{premultipliedAlpha:!1,preserveDrawingBuffer:!1,powerPreference:M,alpha:!0,antialias:!1,depth:!1,stencil:!1,desynchronized:!0});if(!B)throw new b.EM("Can't create a WebGL2 Rendering Context. Try a different browser!");return B}_reinitialize(){this._reinitializeOnContextLoss&&(c.A.warning("Reinitializing WebGL2..."),this._canvas.remove(),this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._readDriverInfo(),this._notify())}_readDriverInfo(){let R=this._gl,B=null;navigator.userAgent.includes("Firefox")?(this._vendor="",this._renderer=R.getParameter(R.RENDERER)):(B=R.getExtension("WEBGL_debug_renderer_info"))!=null?(this._vendor=R.getParameter(B.UNMASKED_VENDOR_WEBGL),this._renderer=R.getParameter(B.UNMASKED_RENDERER_WEBGL)):(this._vendor="",this._renderer="")}_logDriverInfo(){c.A.log("Platform: "+c.A.platformString()),c.A.log("GL vendor: "+this.vendor),c.A.log("GL renderer: "+this.renderer)}loseContext(){let R=this._gl,B=R.getExtension("WEBGL_lose_context");if(!B)throw new b.EM("WEBGL_lose_context extension is unavailable");return R.isContextLost()||(this._reinitializeOnContextLoss=!1,B.loseContext()),B}loseAndRestoreContext(R=1){let B=Math.max(R,0)*1e3,Q=this.loseContext();return new f.i(U=>{setTimeout(()=>{this._reinitializeOnContextLoss=!0,this._reinitialize(),setTimeout(()=>U(Q),0)},B)})}static get powerPreference(){return M}static set powerPreference(R){if(!(R==="default"||R==="low-power"||R==="high-performance"))throw new b.qw(`Invalid powerPreference: "${R}"`);(S==null||M!==R)&&(M=R,S?.loseAndRestoreContext())}static isInitialized(){return S!=null}}},8581:(r,a,A)=>{"use strict";A.d(a,{EM:()=>u,Er:()=>y,FJ:()=>S,MU:()=>M,NO:()=>B,Uk:()=>R,aQ:()=>b,kG:()=>x,l:()=>I,mB:()=>N,pf:()=>E,qw:()=>d,wB:()=>f,xB:()=>c});class c extends Error{constructor(U,F=null){super([U,F?F.toString():"[speedy-vision.js]"].join(`
-> `)),this._cause=F}get name(){return this.constructor.name}set name(U){}get cause(){return this._cause}}class u extends c{constructor(U="",F=null){super(`Unsupported operation. ${U}`,F)}}class g extends c{constructor(U="",F=null){super(`Method not implemented. ${U}`,F)}}class f extends c{constructor(U="",F=null){super(`WebGL error. ${U}`,F)}static from(U){let F=["NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL"],D=U.getError(),z=F.find(q=>U[q]==D)||"Unknown";return new f(z)}}class b extends c{constructor(U="",F=null){super(`Can't call abstract method. ${U}`,F)}}class d extends c{constructor(U="",F=null){super(`Illegal argument. ${U}`,F)}}class y extends c{constructor(U="",F=null){super(`Illegal operation. ${U}`,F)}}class I extends c{constructor(U="",F=null){super(`Out of memory. ${U}`,F)}}class x extends c{constructor(U="",F=null){super(`File not found. ${U}`,F)}}class S extends c{constructor(U="",F=null){super(`Resource not loaded. ${U}`,F)}}class M extends c{constructor(U="",F=null){super(`Timeout error. ${U}`,F)}}class N extends c{constructor(U="",F=null){super(`Parse error. ${U}`,F)}}class E extends c{constructor(U="",F=null){super(`Assertion failed. ${U}`,F)}}class R extends c{constructor(U="",F=null){super(`Access denied. ${U}`,F)}}class B extends c{constructor(U="",F=null){super(`WebAssembly error. ${U}`,F)}}},3816:(r,a,A)=>{"use strict";A.r(a),A.d(a,{DEFAULT_ENCODER_CAPACITY:()=>S,FIX_BITS:()=>f,FIX_RESOLUTION:()=>b,LITTLE_ENDIAN:()=>U,LOG2_MAX_DESCRIPTOR_SIZE:()=>M,LOG2_PYRAMID_MAX_SCALE:()=>u,MATCH_INDEX_BITS:()=>E,MATCH_INDEX_MASK:()=>R,MATCH_MAX_DISTANCE:()=>Q,MATCH_MAX_INDEX:()=>B,MAX_DESCRIPTOR_SIZE:()=>N,MAX_ENCODER_CAPACITY:()=>x,MAX_TEXTURE_LENGTH:()=>d,MIN_ENCODER_LENGTH:()=>I,MIN_KEYPOINT_SIZE:()=>y,PYRAMID_MAX_LEVELS:()=>c,PYRAMID_MAX_SCALE:()=>g});let c=8,u=0,g=1<<u,f=3,b=1<<f,d=(1<<16-f)-1,y=8,I=2,x=8192,S=2048,M=6,N=1<<M,E=32-(M+3),R=(1<<E)-1,B=(1<<E)-1,Q=(1<<32-E)-1,U=function(){return new Uint16Array(new Uint8Array([254,202]).buffer)[0]===51966}()},3211:(r,a,A)=>{"use strict";A.d(a,{c:()=>c});class c{constructor(){this._subscribers=[],this._thisptr=[],this._args=[]}subscribe(g,f,...b){this._subscribers.push(g),this._thisptr.push(f),this._args.push(b)}unsubscribe(g,f){for(let b=this._subscribers.length-1;b>=0;b--)if(this._subscribers[b]===g&&this._thisptr[b]===f){this._subscribers.splice(b,1),this._thisptr.splice(b,1),this._args.splice(b,1);break}}_notify(){for(let g=0;g<this._subscribers.length;g++)this._subscribers[g].apply(this._thisptr[g],this._args[g])}}},6049:(r,a,A)=>{"use strict";A.d(a,{f5:()=>u,kQ:()=>g,kg:()=>f,zu:()=>c});let c=Object.freeze({Image:Symbol("Image"),Video:Symbol("Video"),Canvas:Symbol("Canvas"),OffscreenCanvas:Symbol("OffscreenCanvas"),Bitmap:Symbol("Bitmap"),Data:Symbol("Data")}),u=Object.freeze({RGBA:Symbol("RGBA"),GREY:Symbol("GREY")}),g=Object.freeze({RED:1,GREEN:2,BLUE:4,ALPHA:8,ALL:15}),f=Object.freeze({[g.RED]:0,[g.GREEN]:1,[g.BLUE]:2,[g.ALPHA]:3})},9037:(r,a,A)=>{"use strict";A.d(a,{A:()=>f});var c=A(8581),u=A(9192),g=A(2199);class f{static warning(d,...y){g.w.logging!=="none"&&console.warn("[speedy-vision] "+d,...y)}static log(d,...y){g.w.logging!=="none"&&console.log("[speedy-vision] "+d,...y)}static assert(d,y=""){if(!d)throw new c.pf(y)}static functionArguments(d){let y=d.toString(),I=y.startsWith("function")?"function\\s.*\\(([^)]*)\\)":y.startsWith("(")?"\\(([^)]*)\\).*=>":"([^=]+).*=>",x=new RegExp(I).exec(y);if(x!==null)return x[1].replace(/\/\*.*?\*\//g,"").split(",").map(M=>M.replace(/=.*$/,"").trim()).filter(M=>M);throw new c.mB(`Can't detect function arguments of ${y}`)}static getAllPropertyDescriptors(d){if(d){let y=Object.getPrototypeOf(d);return Object.assign(Object.assign({},f.getAllPropertyDescriptors(y)),Object.getOwnPropertyDescriptors(d))}else return Object.create(null)}static createCanvas(d,y){let I=document.createElement("canvas");return I.width=d,I.height=y,I}static gaussianKernel(d,y=0,I=!0){if(y==0&&(y=Math.ceil(5*d)|0,y+=1-y%2),y|=0,y<1||y%2==0)throw new c.qw(`Invalid kernel size given to gaussianKernel: ${y} x 1`);if(d<=0)throw new c.qw(`Invalid sigma given to gaussianKernel: ${d}`);let x=new Array(y),S=y>>1,M=+d*1.4142135623730951,N=.3275911,E=.254829592,R=-.284496736,B=1.421413741,Q=-1.453152027,U=1.061405429,F=0;for(let D=0;D<y;D++){let z=(D-S+.5)/M,q=(D-S-.5)/M,j=1,V=1;z<0&&(j=-1,z=-z),q<0&&(V=-1,q=-q);let te=1/(1+N*z),ge=1/(1+N*q),Be=((((U*te+Q)*te+B)*te+R)*te+E)*te,Oe=((((U*ge+Q)*ge+B)*ge+R)*ge+E)*ge,Xe=1-Be*Math.exp(-z*z),qe=1-Oe*Math.exp(-q*q),ce=j*Xe,K=V*qe,J=(ce-K)/(2*M);x[D]=J,F+=J}if(I)for(let D=0;D<y;D++)x[D]/=F;return x}static kernel2d(d,y=d){let I=d.length;f.assert(d.length==d.length),f.assert(I>=1&&I%2==1);let x=new Array(I*I),S=0;for(let M=0;M<I;M++)for(let N=0;N<I;N++)x[S++]=d[N]*y[M];return x}static cartesian(d,y){return[].concat(...d.map(I=>y.map(x=>[I,x])))}static symmetricRange(d){if((d|=0)<0)throw new c.qw("Expected a non-negative integer as input");return[...Array(2*d+1).keys()].map(y=>y-d)}static range(d){if((d|=0)<=0)throw new c.qw("Expected a positive integer as input");return[...Array(d).keys()]}static shuffle(d){let y=d.length,I=y-1;for(let x=0;x<I;x++){let S=x+(Math.random()*(y-x)|0);if(x!==S){let M=d[x];d[x]=d[S],d[S]=M}}return d}static flatten(d){let y=[];for(let I=0,x=d.length;I<x;I++){let S=d[I];if(Array.isArray(S))for(let M=0,N=S.length;M<N;M++)y.push(S[M]);else y.push(S)}return y}static decodeFloat16(d){let y=(d&65535)>>15,I=(d&32767)>>10,x=d&1023,S=1-2*y;if(I==0)return x==0?S*0:S*x*5960464477539063e-23;if(I==31)return x==0?S*Number.POSITIVE_INFINITY:Number.NaN;let M=I>=15?1<<I-15:1/(1<<15-I);return S*M*(1+x*.0009765625)}static requestCameraStream(d={audio:!1,video:!0}){if(f.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new c.EM("Unsupported browser: no mediaDevices.getUserMedia()");return new u.i((y,I)=>{navigator.mediaDevices.getUserMedia(d).then(x=>{let S=document.createElement("video");S.onloadedmetadata=()=>{S.play(),f.log(`The camera is on! Resolution: ${S.videoWidth} x ${S.videoHeight}`),y(S)},S.setAttribute("playsinline",""),S.setAttribute("autoplay",""),(d.audio===!1||d.audio===void 0)&&S.setAttribute("muted",""),S.srcObject=x}).catch(x=>{x.name==="NotAllowedError"?I(new c.Uk("Please give access to the camera and reload the page.",x)):x.name==="OverconstrainedError"||x.name==="NotFoundError"?I(new c.EM(`Can't access the webcam with the requested constraints: ${JSON.stringify(d)}.`,x)):I(new c.xB("Can't access the webcam.",x))})})}static formatBinaryData(d){let y=new Uint8Array(d);return Array.from(y,x=>x.toString(16).padStart(2,"0")).join(" ")}static platformString(){return typeof navigator.userAgentData=="object"?navigator.userAgentData.platform:navigator.platform}}},5235:(r,a,A)=>{var c={"./colors.glsl":8609,"./filters.glsl":4672,"./fixed-point.glsl":9778,"./float16.glsl":8710,"./global.glsl":2434,"./int32.glsl":439,"./keypoint-descriptors.glsl":8545,"./keypoint-matches.glsl":6762,"./keypoints.glsl":7639,"./math.glsl":431,"./platform.glsl":6822,"./pyramids.glsl":2728,"./subpixel.glsl":6823};function u(f){var b=g(f);return A(b)}function g(f){if(!A.o(c,f)){var b=new Error("Cannot find module '"+f+"'");throw b.code="MODULE_NOT_FOUND",b}return c[f]}u.keys=function(){return Object.keys(c)},u.resolve=g,r.exports=u,u.id=5235},4606:(r,a,A)=>{var c={"./filters/convolution":1672,"./filters/convolution.js":1672,"./filters/convolution1d.glsl":8211,"./filters/convolution2d.glsl":7360,"./filters/fast-median.glsl":8191,"./filters/nightvision.glsl":4438,"./filters/normalize-image.glsl":5867,"./filters/rgb2grey.glsl":9252,"./include/colors.glsl":8609,"./include/filters.glsl":4672,"./include/fixed-point.glsl":9778,"./include/float16.glsl":8710,"./include/global.glsl":2434,"./include/int32.glsl":439,"./include/keypoint-descriptors.glsl":8545,"./include/keypoint-matches.glsl":6762,"./include/keypoints.glsl":7639,"./include/math.glsl":431,"./include/platform.glsl":6822,"./include/pyramids.glsl":2728,"./include/subpixel.glsl":6823,"./keypoints/allocate-descriptors.glsl":1341,"./keypoints/allocate-extra.glsl":7833,"./keypoints/apply-homography.glsl":2352,"./keypoints/bf-knn.glsl":7541,"./keypoints/clip-border.glsl":4868,"./keypoints/clip.glsl":5591,"./keypoints/distance-filter.glsl":191,"./keypoints/encode-keypoint-long-offsets.glsl":5467,"./keypoints/encode-keypoint-offsets.glsl":336,"./keypoints/encode-keypoint-positions.glsl":8968,"./keypoints/encode-keypoint-properties.glsl":1733,"./keypoints/encode-keypoints.glsl":9674,"./keypoints/encode-null-keypoints.glsl":2090,"./keypoints/fast.glsl":1855,"./keypoints/fast.vs.glsl":4824,"./keypoints/hamming-distance-filter.glsl":2381,"./keypoints/harris-cutoff.glsl":6060,"./keypoints/harris.glsl":9974,"./keypoints/knn-init.glsl":3047,"./keypoints/knn-transfer.glsl":3266,"./keypoints/laplacian.glsl":8018,"./keypoints/lk.glsl":3168,"./keypoints/lookup-of-locations.glsl":3890,"./keypoints/lookup-of-locations.vs.glsl":8647,"./keypoints/lsh-knn.glsl":4776,"./keypoints/mix-keypoints.glsl":2648,"./keypoints/nonmax-scale.glsl":8825,"./keypoints/nonmax-space.glsl":5693,"./keypoints/nonmax-suppression.glsl":9280,"./keypoints/orb-descriptor.glsl":9108,"./keypoints/orb-orientation.glsl":7137,"./keypoints/refine-scale.glsl":9739,"./keypoints/score-findmax.glsl":8231,"./keypoints/shuffle.glsl":2518,"./keypoints/sort-keypoints.glsl":8096,"./keypoints/subpixel-refinement.glsl":5795,"./keypoints/transfer-flow.glsl":3169,"./keypoints/transfer-orientation.glsl":1337,"./keypoints/transfer-to-extra.glsl":6187,"./keypoints/upload-keypoints.glsl":477,"./pyramids/downsample2.glsl":4050,"./pyramids/upsample2.glsl":5545,"./transforms/additive-mix.glsl":7113,"./transforms/resize.glsl":1202,"./transforms/warp-perspective.glsl":7971,"./utils/copy-components.glsl":6122,"./utils/copy-raster.glsl":371,"./utils/copy.glsl":7307,"./utils/fill-components.glsl":8614,"./utils/fill.glsl":6271,"./utils/flip-y.vs.glsl":3016,"./utils/scan-minmax2d.glsl":3630,"./utils/sobel-derivatives.glsl":8508,"./utils/sobel-derivatives.vs.glsl":8073};function u(f){var b=g(f);return A(b)}function g(f){if(!A.o(c,f)){var b=new Error("Cannot find module '"+f+"'");throw b.code="MODULE_NOT_FOUND",b}return c[f]}u.keys=function(){return Object.keys(c)},u.resolve=g,r.exports=u,u.id=4606},8211:r=>{r.exports=`#if !defined(KERNEL_SIZE) || !defined(AXIS) || (AXIS != 0 && AXIS != 1)
#error Undefined KERNEL_SIZE / AXIS
#endif
uniform sampler2D image;
uniform float kernel[@KERNEL_SIZE@];
const ivec2 axis = ivec2(1-AXIS, AXIS);
#define S(x,k) result += pixelAtShortOffset(image, ivec2((x),(x)) * axis) * kernel[k]
void main()
{
vec4 result = vec4(0.0f);
#if KERNEL_SIZE == 3
S(-1, 2);
S( 0, 1);
S( 1, 0);
#elif KERNEL_SIZE == 5
S(-2, 4);
S(-1, 3);
S( 0, 2);
S( 1, 1);
S( 2, 0);
#elif KERNEL_SIZE == 7
S(-3, 6);
S(-2, 5);
S(-1, 4);
S( 0, 3);
S( 1, 2);
S( 2, 1);
S( 3, 0);
#elif KERNEL_SIZE == 9
S(-4, 8);
S(-3, 7);
S(-2, 6);
S(-1, 5);
S( 0, 4);
S( 1, 3);
S( 2, 2);
S( 3, 1);
S( 4, 0);
#elif KERNEL_SIZE == 11
S(-5, 10);
S(-4, 9);
S(-3, 8);
S(-2, 7);
S(-1, 6);
S( 0, 5);
S( 1, 4);
S( 2, 3);
S( 3, 2);
S( 4, 1);
S( 5, 0);
#elif KERNEL_SIZE == 13
S(-6, 12);
S(-5, 11);
S(-4, 10);
S(-3, 9);
S(-2, 8);
S(-1, 7);
S( 0, 6);
S( 1, 5);
S( 2, 4);
S( 3, 3);
S( 4, 2);
S( 5, 1);
S( 6, 0);
#elif KERNEL_SIZE == 15
S(-7, 14);
S(-6, 13);
S(-5, 12);
S(-4, 11);
S(-3, 10);
S(-2, 9);
S(-1, 8);
S( 0, 7);
S( 1, 6);
S( 2, 5);
S( 3, 4);
S( 4, 3);
S( 5, 2);
S( 6, 1);
S( 7, 0);
#else
#error Invalid parameters
#endif
color = vec4(result.rgb, 1.0f);
}`},7360:r=>{r.exports=`#ifndef KERNEL_SIZE_SQUARED
#error Must define KERNEL_SIZE_SQUARED
#endif
uniform sampler2D image;
uniform float kernel[@KERNEL_SIZE_SQUARED@];
#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]
void main()
{
vec4 result = vec4(0.0f);
#if KERNEL_SIZE_SQUARED == 9
S(-1,-1, 8);
S(-1, 0, 7);
S(-1, 1, 6);
S( 0,-1, 5);
S( 0, 0, 4);
S( 0, 1, 3);
S( 1,-1, 2);
S( 1, 0, 1);
S( 1, 1, 0);
#elif KERNEL_SIZE_SQUARED == 25
S(-2,-2, 24);
S(-2,-1, 23);
S(-2, 0, 22);
S(-2, 1, 21);
S(-2, 2, 20);
S(-1,-2, 19);
S(-1,-1, 18);
S(-1, 0, 17);
S(-1, 1, 16);
S(-1, 2, 15);
S( 0,-2, 14);
S( 0,-1, 13);
S( 0, 0, 12);
S( 0, 1, 11);
S( 0, 2, 10);
S( 1,-2, 9);
S( 1,-1, 8);
S( 1, 0, 7);
S( 1, 1, 6);
S( 1, 2, 5);
S( 2,-2, 4);
S( 2,-1, 3);
S( 2, 0, 2);
S( 2, 1, 1);
S( 2, 2, 0);
#elif KERNEL_SIZE_SQUARED == 49
S(-3,-3, 48);
S(-3,-2, 47);
S(-3,-1, 46);
S(-3, 0, 45);
S(-3, 1, 44);
S(-3, 2, 43);
S(-3, 3, 42);
S(-2,-3, 41);
S(-2,-2, 40);
S(-2,-1, 39);
S(-2, 0, 38);
S(-2, 1, 37);
S(-2, 2, 36);
S(-2, 3, 35);
S(-1,-3, 34);
S(-1,-2, 33);
S(-1,-1, 32);
S(-1, 0, 31);
S(-1, 1, 30);
S(-1, 2, 29);
S(-1, 3, 28);
S( 0,-3, 27);
S( 0,-2, 26);
S( 0,-1, 25);
S( 0, 0, 24);
S( 0, 1, 23);
S( 0, 2, 22);
S( 0, 3, 21);
S( 1,-3, 20);
S( 1,-2, 19);
S( 1,-1, 18);
S( 1, 0, 17);
S( 1, 1, 16);
S( 1, 2, 15);
S( 1, 3, 14);
S( 2,-3, 13);
S( 2,-2, 12);
S( 2,-1, 11);
S( 2, 0, 10);
S( 2, 1, 9);
S( 2, 2, 8);
S( 2, 3, 7);
S( 3,-3, 6);
S( 3,-2, 5);
S( 3,-1, 4);
S( 3, 0, 3);
S( 3, 1, 2);
S( 3, 2, 1);
S( 3, 3, 0);
#else
#error Invalid KERNEL_SIZE_SQUARED
#endif
color = vec4(result.rgb, 1.0f);
}`},8191:r=>{r.exports=`uniform sampler2D image;
#define X(i,j) t = vec2(min(p[i], p[j]), max(p[i], p[j])); p[i] = t.x; p[j] = t.y;
#define S(i,x,y) p[i] = pixelAtShortOffset(image, ivec2((x),(y))).g
void main()
{
float median;
vec2 t;
#if !defined(KERNEL_SIZE)
#error Must define KERNEL_SIZE
#elif KERNEL_SIZE == 3
float p[9];
S(0,-1,-1);
S(1, 0,-1);
S(2, 1,-1);
S(3,-1, 0);
S(4, 0, 0);
S(5, 1, 0);
S(6,-1, 1);
S(7, 0, 1);
S(8, 1, 1);
X(1,2);X(4,5);X(7,8);X(0,1);X(3,4);X(6,7);X(1,2);X(4,5);X(7,8);X(0,3);X(5,8);X(4,7);X(3,6);X(1,4);X(2,5);X(4,7);X(4,2);X(6,4);X(4,2);
median = p[4];
#elif KERNEL_SIZE == 5
float p[25];
S( 0,-2,-2);
S( 1,-1,-2);
S( 2, 0,-2);
S( 3, 1,-2);
S( 4, 2,-2);
S( 5,-2,-1);
S( 6,-1,-1);
S( 7, 0,-1);
S( 8, 1,-1);
S( 9, 2,-1);
S(10,-2, 0);
S(11,-1, 0);
S(12, 0, 0);
S(13, 1, 0);
S(14, 2, 0);
S(15,-2, 1);
S(16,-1, 1);
S(17, 0, 1);
S(18, 1, 1);
S(19, 2, 1);
S(20,-2, 2);
S(21,-1, 2);
S(22, 0, 2);
S(23, 1, 2);
S(24, 2, 2);
X(0,1);X(3,4);X(2,4);X(2,3);X(6,7);X(5,7);X(5,6);X(9,10);X(8,10);X(8,9);X(12,13);X(11,13);X(11,12);X(15,16);X(14,16);X(14,15);X(18,19);X(17,19);X(17,18);X(21,22);X(20,22);X(20,21);X(23,24);X(2,5);X(3,6);X(0,6);X(0,3);X(4,7);X(1,7);X(1,4);X(11,14);X(8,14);X(8,11);X(12,15);X(9,15);X(9,12);X(13,16);X(10,16);X(10,13);X(20,23);X(17,23);X(17,20);X(21,24);X(18,24);X(18,21);X(19,22);X(8,17);X(9,18);X(0,18);X(0,9);X(10,19);X(1,19);X(1,10);X(11,20);X(2,20);X(2,11);X(12,21);X(3,21);X(3,12);X(13,22);X(4,22);X(4,13);X(14,23);X(5,23);X(5,14);X(15,24);X(6,24);X(6,15);X(7,16);X(7,19);X(13,21);X(15,23);X(7,13);X(7,15);X(1,9);X(3,11);X(5,17);X(11,17);X(9,17);X(4,10);X(6,12);X(7,14);X(4,6);X(4,7);X(12,14);X(10,14);X(6,7);X(10,12);X(6,10);X(6,17);X(12,17);X(7,17);X(7,10);X(12,18);X(7,12);X(10,18);X(12,20);X(10,20);X(10,12);
median = p[12];
#elif KERNEL_SIZE == 7
float p[49];
S( 0,-3,-3);
S( 1,-2,-3);
S( 2,-1,-3);
S( 3, 0,-3);
S( 4, 1,-3);
S( 5, 2,-3);
S( 6, 3,-3);
S( 7,-3,-2);
S( 8,-2,-2);
S( 9,-1,-2);
S(10, 0,-2);
S(11, 1,-2);
S(12, 2,-2);
S(13, 3,-2);
S(14,-3,-1);
S(15,-2,-1);
S(16,-1,-1);
S(17, 0,-1);
S(18, 1,-1);
S(19, 2,-1);
S(20, 3,-1);
S(21,-3, 0);
S(22,-2, 0);
S(23,-1, 0);
S(24, 0, 0);
S(25, 1, 0);
S(26, 2, 0);
S(27, 3, 0);
S(28,-3, 1);
S(29,-2, 1);
S(30,-1, 1);
S(31, 0, 1);
S(32, 1, 1);
S(33, 2, 1);
S(34, 3, 1);
S(35,-3, 2);
S(36,-2, 2);
S(37,-1, 2);
S(38, 0, 2);
S(39, 1, 2);
S(40, 2, 2);
S(41, 3, 2);
S(42,-3, 3);
S(43,-2, 3);
S(44,-1, 3);
S(45, 0, 3);
S(46, 1, 3);
S(47, 2, 3);
S(48, 3, 3);
X(0,1);X(2,3);X(0,2);X(1,3);X(1,2);X(4,5);X(6,7);X(4,6);X(5,7);X(5,6);X(0,4);X(2,6);X(2,4);X(1,5);X(3,7);X(3,5);X(1,2);X(3,4);X(5,6);X(8,9);X(10,11);X(8,10);X(9,11);X(9,10);X(12,13);X(14,15);X(12,14);X(13,15);X(13,14);X(8,12);X(10,14);X(10,12);X(9,13);X(11,15);X(11,13);X(9,10);X(11,12);X(13,14);X(0,8);X(4,12);X(4,8);X(2,10);X(6,14);X(6,10);X(2,4);X(6,8);X(10,12);X(1,9);X(5,13);X(5,9);X(3,11);X(7,15);X(7,11);X(3,5);X(7,9);X(11,13);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(16,17);X(18,19);X(16,18);X(17,19);X(17,18);X(20,21);X(22,23);X(20,22);X(21,23);X(21,22);X(16,20);X(18,22);X(18,20);X(17,21);X(19,23);X(19,21);X(17,18);X(19,20);X(21,22);X(24,25);X(26,27);X(24,26);X(25,27);X(25,26);X(28,29);X(30,31);X(28,30);X(29,31);X(29,30);X(24,28);X(26,30);X(26,28);X(25,29);X(27,31);X(27,29);X(25,26);X(27,28);X(29,30);X(16,24);X(20,28);X(20,24);X(18,26);X(22,30);X(22,26);X(18,20);X(22,24);X(26,28);X(17,25);X(21,29);X(21,25);X(19,27);X(23,31);X(23,27);X(19,21);X(23,25);X(27,29);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(0,16);X(8,24);X(8,16);X(4,20);X(12,28);X(12,20);X(4,8);X(12,16);X(20,24);X(2,18);X(10,26);X(10,18);X(6,22);X(14,30);X(14,22);X(6,10);X(14,18);X(22,26);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(1,17);X(9,25);X(9,17);X(5,21);X(13,29);X(13,21);X(5,9);X(13,17);X(21,25);X(3,19);X(11,27);X(11,19);X(7,23);X(15,31);X(15,23);X(7,11);X(15,19);X(23,27);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(32,33);X(34,35);X(32,34);X(33,35);X(33,34);X(36,37);X(38,39);X(36,38);X(37,39);X(37,38);X(32,36);X(34,38);X(34,36);X(33,37);X(35,39);X(35,37);X(33,34);X(35,36);X(37,38);X(40,41);X(42,43);X(40,42);X(41,43);X(41,42);X(44,45);X(46,47);X(44,46);X(45,47);X(45,46);X(40,44);X(42,46);X(42,44);X(41,45);X(43,47);X(43,45);X(41,42);X(43,44);X(45,46);X(32,40);X(36,44);X(36,40);X(34,42);X(38,46);X(38,42);X(34,36);X(38,40);X(42,44);X(33,41);X(37,45);X(37,41);X(35,43);X(39,47);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(32,48);X(40,48);X(36,40);X(44,48);X(38,42);X(34,36);X(38,40);X(42,44);X(46,48);X(37,41);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(47,48);X(0,32);X(16,48);X(16,32);X(8,40);X(24,40);X(8,16);X(24,32);X(40,48);X(4,36);X(20,36);X(12,44);X(28,44);X(12,20);X(28,36);X(4,8);X(12,16);X(20,24);X(28,32);X(36,40);X(44,48);X(2,34);X(18,34);X(10,42);X(26,42);X(10,18);X(26,34);X(6,38);X(22,38);X(14,46);X(30,46);X(14,22);X(30,38);X(6,10);X(14,18);X(22,26);X(30,34);X(38,42);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(30,32);X(34,36);X(38,40);X(42,44);X(46,48);X(1,33);X(17,33);X(9,41);X(25,41);X(9,17);X(25,33);X(5,37);X(21,37);X(13,45);X(29,45);X(13,21);X(29,37);X(5,9);X(13,17);X(21,25);X(29,33);X(37,41);X(3,35);X(19,35);X(11,43);X(27,43);X(11,19);X(27,35);X(7,39);X(23,39);X(15,47);X(31,47);X(15,23);X(31,39);X(7,11);X(15,19);X(23,27);X(31,35);X(39,43);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(31,33);X(35,37);X(39,41);X(43,45);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);
median = p[24];
#else
#error Unsupported kernel size
#endif
color = vec4(median, median, median, 1.0f);
}`},4438:r=>{r.exports=`uniform sampler2D image;
uniform sampler2D illuminationMap;
uniform float gain;
uniform float offset;
uniform float decay;
#ifndef GREYSCALE
#error Must define GREYSCALE
#endif
#if GREYSCALE == 0
const mat3 rgb2yuv = mat3(
0.299f, -0.14713f, 0.615f,
0.587f, -0.28886f, -0.51499f,
0.114f, 0.436f, -0.10001f
);
const mat3 yuv2rgb = mat3(
1.0f, 1.0f, 1.0f,
0.0f, -0.39465f, 2.03211f,
1.13983f, -0.58060f, 0.0f
);
#endif
const float eps = 0.0001f;
const float sqrt2 = 1.4142135623730951f;
const float magic = 20.0f;
const vec2 center = vec2(0.5f);
void main()
{
vec4 pixel = threadPixel(image);
vec4 imapPixel = threadPixel(illuminationMap);
float lambda = -sqrt2 * log(max(1.0f - decay, eps));
float dist = length(texCoord - center);
float vgain = gain * exp(-lambda * dist);
float normalizedGain = 2.0f * vgain;
float normalizedOffset = 2.0f * offset - 1.0f;
#if GREYSCALE != 0
float luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));
luma = clamp(luma + normalizedOffset, 0.0f, 1.0f);
color = vec4(luma, luma, luma, 1.0f);
#else
vec3 yuvPixel = rgb2yuv * pixel.rgb;
vec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;
float luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));
luma += normalizedOffset;
vec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);
rgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);
color = vec4(rgbCorrectedPixel, 1.0f);
#endif
}`},5867:r=>{r.exports=`#ifndef GREYSCALE
#error Must define GREYSCALE
#endif
#if GREYSCALE != 0
uniform sampler2D minmax2d;
#else
uniform sampler2D minmax2dRGB[3];
#endif
uniform float minValue;
uniform float maxValue;
const float eps = 1.0f / 255.0f;
void main()
{
vec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;
vec4 newMin = vec4(minmax.x);
vec4 newRange = vec4(minmax.y - minmax.x);
vec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);
#if GREYSCALE != 0
vec4 pixel = threadPixel(minmax2d);
mat4 channel = mat4(pixel, pixel, pixel, alpha);
#else
mat4 channel = mat4(
threadPixel(minmax2dRGB[0]),
threadPixel(minmax2dRGB[1]),
threadPixel(minmax2dRGB[2]),
alpha
);
#endif
vec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);
vec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);
vec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);
vec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;
color = newIntensity;
}`},9252:r=>{r.exports=`const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);
uniform sampler2D image;
void main()
{
vec4 pixel = threadPixel(image);
float g = dot(pixel, grey);
color = vec4(g, g, g, 1.0f);
}`},8609:r=>{r.exports=`#ifndef _COLORS_GLSL
#define _COLORS_GLSL
#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@
#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@
#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@
#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@
#endif`},4672:r=>{r.exports=`#ifndef _FILTERS_GLSL
#define _FILTERS_GLSL
float laplacian(sampler2D pyramid, vec2 position, float lod)
{
float pot = exp2(lod);
ivec2 pyrBaseSize = textureSize(pyramid, 0);
const vec3 ones = vec3(1.0f);
const mat3 kernel = mat3(
0,-1, 0,
-1, 4,-1,
0,-1, 0
);
#define LPC(x,y) pyrSubpixelAtExOffset(pyramid, position, lod, pot, ivec2((x),(y)), pyrBaseSize).g
mat3 neighborhood = mat3(
0.0f, LPC(0,-1), 0.0f,
LPC(-1,0), LPC(0,0), LPC(1,0),
0.0f, LPC(0,1), 0.0f
);
mat3 m = matrixCompMult(neighborhood, kernel);
return dot(ones, vec3(
dot(m[0], ones),
dot(m[1], ones),
dot(m[2], ones)
)) * (1.0f + lod);
}
#endif`},9778:r=>{r.exports=`#ifndef _FIXEDPOINT_GLSL
#define _FIXEDPOINT_GLSL
#define fixed_t int
#define fixed2_t ivec2
const int FIX_BITS = int(@FIX_BITS@);
const float FIX_RESOLUTION = float(@FIX_RESOLUTION@);
#define itofix(x) fixed_t((x) << FIX_BITS)
#define fixtoi(f) int((x) >> FIX_BITS)
#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)
#define fixtof(f) (float(f) / FIX_RESOLUTION)
#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)
#define fixtoivec2(f) ivec2((f) >> FIX_BITS)
#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))
#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)
#endif`},8710:r=>{r.exports=`#ifndef _FLOAT16_GLSL
#define _FLOAT16_GLSL
#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)
#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))
#define encodePairOfFloat16(f) vec4(encodeFloat16((f).x), encodeFloat16((f).y))
#define decodePairOfFloat16(v) vec2(decodeFloat16((v).rg), decodeFloat16((v).ba))
#define encodeNullPairOfFloat16() vec4(1.0f)
#define isNullPairOfFloat16(v) all(equal((v), encodeNullPairOfFloat16()))
#define encodeDiscardedPairOfFloat16() vec4(0.0f, 1.0f, 0.0f, 1.0f)
#define isDiscardedPairOfFloat16(v) all(equal((v), encodeDiscardedPairOfFloat16()))
#define encodeFloat16NaN() vec2(0.5f, 1.0f)
#define isEncodedFloat16NaN(v) all(equal((v), encodeFloat16NaN()))
uvec2 packf16( float f)
{
uint y = packHalf2x16(vec2(f, 0.0f));
return uvec2(y, y >> 8u) & 0xFFu;
}
float unpackf16(uvec2 v)
{
v &= 0xFFu;
return unpackHalf2x16(v.x | (v.y << 8u)).x;
}
bool isEncodedFloat16Zero(vec2 v)
{
uvec2 w = uvec2(v * 255.0f);
return 0u == w.x + w.y * (0x80u - w.y);
}
#endif`},2434:r=>{r.exports=`#ifndef _GLOBAL_GLSL
#define _GLOBAL_GLSL
#define threadLocation() ivec2(texCoord * texSize)
#define outputSize() ivec2(texSize)
#define threadPixel(img) textureLod((img), texCoord, 0.0f)
#define pixelAt(img, pos) texelFetch((img), (pos), 0)
#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))
#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)
#endif`},439:r=>{r.exports=`#ifndef _INT32_GLSL
#define _INT32_GLSL
@include "platform.glsl"
uint decodeUint32(vec4 rgba)
{
uvec4 v = uvec4(rgba * 255.0f) & 255u;
return v.x | (v.y << 8u) | (v.z << 16u) | (v.w << 24u);
}
vec4 encodeUint32(uint value)
{
#if defined(APPLE_GPU) || (defined(APPLE) && defined(INTEL_GRAPHICS))
uvec4 v = uvec4(value, value / 256u, value / 65536u, value / 16777216u) % 256u;
return vec4(v) / 255.0f;
#else
uvec4 v = uvec4(value, value >> 8u, value >> 16u, value >> 24u) & 255u;
return vec4(v) / 255.0f;
#endif
}
#endif`},8545:r=>{r.exports=`#ifndef _KEYPOINT_DESCRIPTORS_GLSL
#define _KEYPOINT_DESCRIPTORS_GLSL
#if !defined(DESCRIPTOR_SIZE)
#error Must define DESCRIPTOR_SIZE
#elif !defined(_KEYPOINTS_GLSL)
#error Must include keypoints.glsl
#endif
uint[DESCRIPTOR_SIZE] readKeypointDescriptor(sampler2D encodedKeypoints, int descriptorSize, int extraSize, int encoderLength, KeypointAddress address)
{
int descriptorOffset = sizeofEncodedKeypoint(0, extraSize) / 4;
KeypointAddress descriptorAddress = KeypointAddress(address.base, descriptorOffset);
uint[DESCRIPTOR_SIZE] descriptor;
vec4 pixel; uvec4 bytes;
@unroll
for(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {
pixel = readKeypointData(encodedKeypoints, encoderLength, descriptorAddress);
bytes = uvec4(pixel * 255.0f);
descriptor[i]   = bytes.r;
descriptor[i+1] = bytes.g;
descriptor[i+2] = bytes.b;
descriptor[i+3] = bytes.a;
descriptorAddress.offset++;
}
return descriptor;
}
uint[DESCRIPTOR_SIZE] readKeypointDescriptorFromDB(sampler2D descriptorDB, int descriptorDBStride, int index)
{
uint[DESCRIPTOR_SIZE] descriptor;
int rasterIndex = index * (DESCRIPTOR_SIZE / 4) * int(index >= 0);
vec4 pixel; uvec4 bytes; ivec2 pos;
@unroll
for(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {
pos = ivec2(rasterIndex % descriptorDBStride, rasterIndex / descriptorDBStride);
pixel = (index >= 0) ? texelFetch(descriptorDB, pos, 0) : vec4(0.0f);
bytes = uvec4(pixel * 255.0f);
descriptor[i]   = bytes.r;
descriptor[i+1] = bytes.g;
descriptor[i+2] = bytes.b;
descriptor[i+3] = bytes.a;
rasterIndex++;
}
return descriptor;
}
int distanceBetweenKeypointDescriptors(uint[DESCRIPTOR_SIZE] a, uint[DESCRIPTOR_SIZE] b)
{
const int[256] POPCNT = int[256](0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8);
uvec4 xor, u, v;
int dist = 0;
ivec4 bits;
@unroll
for(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {
u = uvec4(a[i], a[i+1], a[i+2], a[i+3]);
v = uvec4(b[i], b[i+1], b[i+2], b[i+3]);
xor = (u ^ v) & 255u;
bits = ivec4(POPCNT[xor.x], POPCNT[xor.y], POPCNT[xor.z], POPCNT[xor.w]);
dist += bits.x + bits.y + bits.z + bits.w;
}
return dist;
}
#endif`},6762:r=>{r.exports=`#ifndef _KEYPOINT_MATCHES_GLSL
#define _KEYPOINT_MATCHES_GLSL
@include "int32.glsl"
const int MATCH_INDEX_BITS = int(@MATCH_INDEX_BITS@);
const int MATCH_INDEX_MASK = int(@MATCH_INDEX_MASK@);
const int MATCH_MAX_INDEX = int(@MATCH_MAX_INDEX@);
const int MATCH_MAX_DISTANCE = int(@MATCH_MAX_DISTANCE@);
struct KeypointMatch
{
int index;
int dist;
};
vec4 encodeKeypointMatch(KeypointMatch candidate)
{
uint index = uint(candidate.index) & uint(MATCH_INDEX_MASK);
uint dist = uint(clamp(candidate.dist, 0, MATCH_MAX_DISTANCE));
uint u32 = index | (dist << MATCH_INDEX_BITS);
return encodeUint32(u32);
}
KeypointMatch decodeKeypointMatch(vec4 rgba)
{
uint u32 = decodeUint32(rgba);
int dist = int(u32 >> MATCH_INDEX_BITS);
int index = int(u32 & uint(MATCH_INDEX_MASK));
return KeypointMatch(index, dist);
}
const KeypointMatch MATCH_NOT_FOUND = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);
#endif`},7639:r=>{r.exports=`#ifndef _KEYPOINTS_GLSL
#define _KEYPOINTS_GLSL
@include "math.glsl"
@include "fixed-point.glsl"
@include "float16.glsl"
@include "pyramids.glsl"
struct Keypoint
{
vec2 position;
float lod;
float orientation;
float score;
uint flags;
};
struct KeypointAddress
{
int base;
int offset;
};
const int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);
const int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);
const uint KPF_NONE = 0u;
const uint KPF_NULL = 1u;
const uint KPF_DISCARDED = 2u;
#define encodeKeypointScore(score) encodeFloat16(score)
#define decodeKeypointScore(encodedScore) decodeFloat16(encodedScore)
#define encodeKeypointOrientation(angle) ((angle) * INV_PI_OVER_2 + 0.5f)
#define decodeKeypointOrientation(value) ((value) * TWO_PI - PI)
#define encodeNullKeypoint() (vec4(1.0f))
#define encodeDiscardedKeypoint() (vec4(0.0f))
#define isNullKeypoint(keypoint) ((((keypoint).flags) & KPF_NULL) != 0u)
#define isDiscardedKeypoint(keypoint) ((((keypoint).flags) & KPF_DISCARDED) != 0u)
#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)
#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))
#define sizeofEncodedKeypointHeader() sizeofEncodedKeypoint(0,0)
#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))
vec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)
{
int rasterIndex = address.base + address.offset;
vec4 data = pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));
return rasterIndex < encoderLength * encoderLength ? data : encodeNullKeypoint();
}
KeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)
{
int threadRaster = thread.y * encoderLength + thread.x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
int keypointIndex = int(threadRaster / pixelsPerKeypoint);
KeypointAddress address = KeypointAddress(
keypointIndex * pixelsPerKeypoint,
threadRaster % pixelsPerKeypoint
);
return address;
}
Keypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)
{
Keypoint keypoint;
KeypointAddress positionAddress = KeypointAddress(address.base, 0);
KeypointAddress propertiesAddress = KeypointAddress(address.base, 1);
vec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);
ivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);
keypoint.position = fixtovec2(fixed2_t(
encodedPosition.r | (encodedPosition.g << 8),
encodedPosition.b | (encodedPosition.a << 8)
));
vec4 rawEncodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);
keypoint.lod = decodeLod(rawEncodedProperties.r);
keypoint.orientation = decodeKeypointOrientation(rawEncodedProperties.g);
keypoint.score = decodeKeypointScore(rawEncodedProperties.ba);
bool isNull = all(equal(rawEncodedPosition, vec4(1)));
bool isDiscarded = all(equal(rawEncodedPosition + rawEncodedProperties, vec4(0)));
keypoint.score = (isNull || isDiscarded) ? -1.0f : keypoint.score;
keypoint.flags = KPF_NONE;
keypoint.flags |= KPF_NULL * uint(isNull);
keypoint.flags |= KPF_DISCARDED * uint(isDiscarded);
return keypoint;
}
vec4 encodeKeypointPosition(vec2 position)
{
const vec2 zeros = vec2(0.0f);
fixed2_t pos = vec2tofix(max(position, zeros));
fixed2_t lo = pos & 255;
fixed2_t hi = (pos >> 8) & 255;
return vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;
}
#endif`},431:r=>{r.exports=`#ifndef _MATH_GLSL
#define _MATH_GLSL
#define TWO_PI          6.28318530718f
#define PI              3.14159265359f
#define PI_OVER_2       1.57079632679f
#define PI_OVER_4       0.78539816339f
#define INV_PI          0.3183098861837907f
#define INV_PI_OVER_2   0.15915494309189535f
const highp float INFINITY = 1.0f / 0.0f;
float fastAtan(float x)
{
float w = 1.0f - abs(x);
return (w >= 0.0f) ? ((PI_OVER_4 + 0.273f * w) * x) :
(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x);
}
float fastAtan2(float y, float x)
{
return (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);
}
#endif`},6822:r=>{r.exports=`#ifndef _PLATFORM_GLSL
#define _PLATFORM_GLSL
#if @APPLE@
#define APPLE 1
#endif
#if @APPLE_GPU@
#define APPLE_GPU 1
#endif
#if @INTEL_GRAPHICS@
#define INTEL_GRAPHICS 1
#endif
#endif`},2728:r=>{r.exports=`#ifndef _PYRAMIDS_GLSL
#define _PYRAMIDS_GLSL
#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))
#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))
#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))
#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))
#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))
#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))
const int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);
const float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);
const float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);
#define encodeLod(lod) ((LOG2_PYRAMID_MAX_SCALE + (lod)) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS))
float decodeLod(float encodedLod)
{
float lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;
return lod - lod * step(1.0f, encodedLod);
}
#define LOD_EPS 0.0625f
const float ENCODED_LOD_EPS = (LOD_EPS / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS));
#define isSameLod(lod1, lod2) (abs((lod1) - (lod2)) < LOD_EPS)
#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < ENCODED_LOD_EPS)
#endif`},6823:r=>{r.exports=`#ifndef _SUBPIXEL_GLSL
#define _SUBPIXEL_GLSL
#define subpixelAt(image, pos) textureLod((image), ((pos) + vec2(0.5f)) / texSize, 0.0f)
vec4 subpixelAtBI(sampler2D image, vec2 pos)
{
vec2 frc = fract(pos);
vec2 ifrc = vec2(1.0f) - frc;
vec2 p = (floor(pos) + vec2(0.5f)) / vec2(textureSize(image, 0));
vec4 pix00 = textureLod(image, p, 0.0f);
vec4 pix10 = textureLodOffset(image, p, 0.0f, ivec2(1,0));
vec4 pix01 = textureLodOffset(image, p, 0.0f, ivec2(0,1));
vec4 pix11 = textureLodOffset(image, p, 0.0f, ivec2(1,1));
mat4 pix = mat4(pix00, pix10, pix01, pix11);
vec4 mul = vec4(ifrc.x * ifrc.y, frc.x * ifrc.y, ifrc.x * frc.y, frc.x * frc.y);
return pix * mul;
}
#endif`},1341:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D inputEncodedKeypoints;
uniform int inputDescriptorSize;
uniform int inputExtraSize;
uniform int inputEncoderLength;
uniform int outputDescriptorSize;
uniform int outputExtraSize;
uniform int outputEncoderLength;
const vec4 EMPTY_DESCRIPTOR = vec4(0.0f);
void main()
{
ivec2 thread = threadLocation();
KeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);
int myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);
int headerSize = sizeofEncodedKeypointHeader();
bool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);
int addressOffset = myAddress.offset;
int pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;
KeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);
color = isDescriptor ? EMPTY_DESCRIPTOR : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);
}`},7833:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D inputEncodedKeypoints;
uniform int inputDescriptorSize;
uniform int inputExtraSize;
uniform int inputEncoderLength;
uniform int outputDescriptorSize;
uniform int outputExtraSize;
uniform int outputEncoderLength;
void main()
{
ivec2 thread = threadLocation();
KeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);
int myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);
int headerSize = sizeofEncodedKeypointHeader();
bool isHead = (myAddress.offset < headerSize / 4);
bool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);
bool isExtra = (!isHead && !isDescriptor);
int numberOfExtraPixels = outputExtraSize / 4;
int addressOffset = myAddress.offset - int(isDescriptor) * numberOfExtraPixels;
int pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;
KeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);
color = isExtra ? vec4(0.0f) : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);
}`},2352:r=>{r.exports=`@include "keypoints.glsl"
uniform mat3 homography;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
color = pixel;
if(address.offset != 0)
return;
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
if(isBadKeypoint(keypoint))
return;
vec3 pos3 = homography * vec3(keypoint.position, 1.0f);
color = encodeKeypointPosition(pos3.xy / pos3.z);
}`},7541:r=>{r.exports=`@include "keypoints.glsl"
@include "keypoint-descriptors.glsl"
@include "keypoint-matches.glsl"
uniform sampler2D encodedMatches;
uniform sampler2D encodedFilters;
uniform int matcherLength;
uniform sampler2D dbEncodedKeypoints;
uniform int dbDescriptorSize;
uniform int dbExtraSize;
uniform int dbEncoderLength;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int passId;
#ifndef NUMBER_OF_KEYPOINTS_PER_PASS
#error Undefined NUMBER_OF_KEYPOINTS_PER_PASS
#endif
const int INFINITE_DISTANCE = MATCH_MAX_DISTANCE + 1;
void main()
{
ivec2 thread = threadLocation();
int keypointIndex = thread.x + thread.y * matcherLength;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
color = encodeKeypointMatch(MATCH_NOT_FOUND);
if(isBadKeypoint(keypoint))
return;
KeypointMatch bestMatch = decodeKeypointMatch(threadPixel(encodedMatches));
KeypointMatch filterMatch = decodeKeypointMatch(threadPixel(encodedFilters));
uint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);
uint[DESCRIPTOR_SIZE] dbDescriptor;
int dbPixelsPerKeypoint = sizeofEncodedKeypoint(dbDescriptorSize, dbExtraSize) / 4;
for(int i = 0; i < NUMBER_OF_KEYPOINTS_PER_PASS; i++) {
int dbKeypointIndex = passId * NUMBER_OF_KEYPOINTS_PER_PASS + i;
KeypointAddress dbAddress = KeypointAddress(dbKeypointIndex * dbPixelsPerKeypoint, 0);
Keypoint dbKeypoint = decodeKeypoint(dbEncodedKeypoints, dbEncoderLength, dbAddress);
dbDescriptor = readKeypointDescriptor(dbEncodedKeypoints, dbDescriptorSize, dbExtraSize, dbEncoderLength, dbAddress);
int dist = !isBadKeypoint(dbKeypoint) ? distanceBetweenKeypointDescriptors(descriptor, dbDescriptor) : INFINITE_DISTANCE;
bestMatch.index = all(bvec2(
dist < bestMatch.dist || (dist == bestMatch.dist && dbKeypointIndex > bestMatch.index),
dist > filterMatch.dist || (dist == filterMatch.dist && dbKeypointIndex < filterMatch.index)
)) ? dbKeypointIndex : bestMatch.index;
bestMatch.dist = dbKeypointIndex == bestMatch.index ? dist : bestMatch.dist;
}
color = encodeKeypointMatch(bestMatch);
}`},4868:r=>{r.exports=`@include "keypoints.glsl"
uniform int imageWidth;
uniform int imageHeight;
uniform int borderTop;
uniform int borderRight;
uniform int borderBottom;
uniform int borderLeft;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
ivec2 thread = threadLocation();
KeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);
vec2 p = keypoint.position;
bool withinBorder = any(lessThan(
vec4(p.x, p.y, -p.x, -p.y),
vec4(borderLeft, borderTop, borderRight - (imageWidth - 1), borderBottom - (imageHeight - 1))
));
vec4 pixel = threadPixel(encodedKeypoints);
vec4 nullPixel = encodeNullKeypoint();
color = withinBorder ? nullPixel : pixel;
}`},5591:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int maxKeypoints;
void main()
{
ivec2 thread = threadLocation();
int newEncoderLength = outputSize().x;
KeypointAddress address = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
vec4 pixel = readKeypointData(encodedKeypoints, encoderLength, address);
color = index < maxKeypoints ? pixel : encodeNullKeypoint();
}`},191:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedKeypointsA;
uniform int encoderLengthA;
uniform sampler2D encodedKeypointsB;
uniform int encoderLengthB;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform float threshold;
void main()
{
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
vec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);
color = data;
if(address.offset >= sizeofEncodedKeypointHeader() / 4)
return;
Keypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);
Keypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);
color = encodeNullKeypoint();
if(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))
return;
color = encodeDiscardedKeypoint();
if(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))
return;
color = encodeDiscardedKeypoint();
if(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))
return;
vec2 delta = keypointA.position - keypointB.position;
bool shouldKeep = (dot(delta, delta) <= threshold * threshold);
color = shouldKeep ? data : encodeDiscardedKeypoint();
}`},5467:r=>{r.exports=`@include "float16.glsl"
uniform sampler2D offsetsImage;
uniform ivec2 imageSize;
#ifndef MAX_ITERATIONS
#error Undefined MAX_ITERATIONS
#endif
#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))
#define encodeSkipOffset(offset) (vec2((offset) & 255, (offset) >> 8) / 255.0f)
void main()
{
vec4 pixel = threadPixel(offsetsImage);
ivec2 thread = threadLocation();
int rasterIndex = thread.y * imageSize.x + thread.x;
int offset = decodeSkipOffset(pixel);
int totalOffset = offset;
vec2 encodedScore = pixel.rb;
ivec2 pos = thread; int allow = 1;
@unroll
for(int i = 0; i < MAX_ITERATIONS; i++) {
allow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb));
rasterIndex += allow * offset;
pos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);
pixel = pixelAt(offsetsImage, pos);
offset = decodeSkipOffset(pixel);
totalOffset += allow * offset;
}
totalOffset = min(totalOffset, 65535);
color.rb = encodedScore;
color.ga = encodeSkipOffset(totalOffset);
}`},336:r=>{r.exports=`@include "float16.glsl"
uniform sampler2D corners;
uniform ivec2 imageSize;
void main()
{
vec4 pixel = threadPixel(corners);
ivec2 pos = threadLocation();
vec2 encodedScore = pixel.rb;
int offset = 0, allow = 1, jumped = 0;
#define READ(j) ; \\
allow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb)); \\
offset += allow; \\
pos.x = (pos.x + 1) % imageSize.x; \\
pos.y += int(pos.x == 0); \\
pixel = (0 != (jumped |= int(pos.x == 0))) ? pixelAtShortOffset(corners, ivec2((j),1)) : pixelAtShortOffset(corners, ivec2((j),0))
READ(1); READ(2); READ(3); READ(4); READ(5); READ(6); READ(7);
color.rb = encodedScore;
color.ga = vec2(offset, 0) / 255.0f;
}`},8968:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D offsetsImage;
uniform ivec2 imageSize;
uniform int passId;
uniform int numPasses;
uniform int keypointLimit;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))
bool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)
{
int notFirstPass = int(passId > 0);
position *= notFirstPass;
p |= -(1 - notFirstPass);
p -= notFirstPass;
int rasterIndex = position.y * imageSize.x + position.x;
while(position.y < imageSize.y && p != q) {
position = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);
pixel = texelFetch(offsetsImage, position, 0);
p += int(!isEncodedFloat16Zero(pixel.rb));
rasterIndex += max(1, decodeSkipOffset(pixel));
}
return (p == q);
}
void main()
{
ivec2 thread = threadLocation();
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int q = findKeypointIndex(address, descriptorSize, extraSize);
color = vec4(0.0f);
if(address.offset != 0)
return;
color = threadPixel(encodedKeypoints);
int numPixels = encoderLength * encoderLength;
int maxKeypoints = numPixels / pixelsPerKeypoint;
int maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);
int targetPassId = q / maxKeypointsPerPass;
if(passId != targetPassId)
return;
int lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;
KeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);
Keypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);
ivec2 position = passId > 0 ? ivec2(lastKeypointFromPrevPass.position) : ivec2(0);
vec4 pixel;
color = encodeNullKeypoint();
if(q >= min(maxKeypoints, keypointLimit) || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))
return;
color = encodeKeypointPosition(vec2(position));
}`},1733:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D corners;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(encodedKeypoints);
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int q = findKeypointIndex(address, descriptorSize, extraSize);
color = pixel;
if(address.offset != 1)
return;
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
vec4 kpix = pixelAt(corners, ivec2(keypoint.position));
keypoint.score = decodeFloat16(kpix.rb);
color.r = kpix.a;
color.g = encodeKeypointOrientation(0.0f);
color.ba = encodeKeypointScore(keypoint.score);
}`},9674:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D corners;
uniform mediump usampler2D lookupTable;
uniform int stride;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int encoderCapacity;
const uvec2 NULL_ELEMENT = uvec2(0xFFFFu);
void main()
{
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
ivec2 pos = ivec2(index % stride, index / stride);
uvec4 entry = texelFetch(lookupTable, pos, 0);
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
int rasterIndex = address.base + address.offset;
int numberOfPixels = encoderLength * encoderLength;
int numberOfValidPixels = numberOfPixels - (numberOfPixels % pixelsPerKeypoint);
int maxEncoderCapacity = numberOfValidPixels / pixelsPerKeypoint;
color = encodeNullKeypoint();
if(all(equal(entry.xy, NULL_ELEMENT)) || index >= min(encoderCapacity, maxEncoderCapacity))
return;
color = encodeKeypointPosition(vec2(entry.xy));
if(address.offset == 0)
return;
color = vec4(0.0f);
if(address.offset >= sizeofEncodedKeypointHeader() / 4)
return;
vec4 pixel = texelFetch(corners, ivec2(entry.xy), 0);
vec2 encodedScore = encodeKeypointScore(decodeFloat16(pixel.rb));
float encodedOrientation = encodeKeypointOrientation(0.0f);
float encodedLod = pixel.a;
color = vec4(encodedLod, encodedOrientation, encodedScore);
}`},2090:r=>{r.exports=`@include "keypoints.glsl"
void main()
{
color = encodeNullKeypoint();
}`},1855:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
uniform sampler2D corners;
uniform sampler2D pyramid;
uniform float lod;
uniform int threshold;
#define USE_VARYINGS 1
#if !defined(FAST_TYPE)
#error Undefined FAST_TYPE
#elif FAST_TYPE == 916
in vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,
v_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;
#else
#error Invalid FAST_TYPE
#endif
#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g
#define XIP(v) textureLod(pyramid, (v), lod).g
void main()
{
float pixel = threadPixel(pyramid).g;
vec4 prev = threadPixel(corners);
ivec2 thread = threadLocation();
ivec2 size = outputSize();
float pot = exp2(lod);
float t = float(clamp(threshold, 0, 255)) / 255.0f;
float ct = pixel + t, c_t = pixel - t;
color = vec4(prev.r, pixel, prev.ba);
#if FAST_TYPE == 916
const ivec4 margin = ivec4(3, 3, 4, 4);
if(any(lessThan(ivec4(thread, size - thread), margin)))
return;
#if USE_VARYINGS
float p0 = XIP(v_pix0), p4 = XIP(v_pix4), p8 = XIP(v_pix8), p12 = XIP(v_pix12);
#else
float p0 = PIX(0,3), p4 = PIX(3,0), p8 = PIX(0,-3), p12 = PIX(-3,0);
#endif
bvec4 brighter = bvec4(p0 > ct, p4 > ct, p8 > ct, p12 > ct);
bvec4 darker = bvec4(p0 < c_t, p4 < c_t, p8 < c_t, p12 < c_t);
bvec4 bpairs = bvec4(all(brighter.xy), all(brighter.yz), all(brighter.zw), all(brighter.wx));
bvec4 dpairs = bvec4(all(darker.xy), all(darker.yz), all(darker.zw), all(darker.wx));
if(!(any(bpairs) || any(dpairs)))
return;
#if USE_VARYINGS
float p1 = XIP(v_pix1), p2 = XIP(v_pix2), p3 = XIP(v_pix3),
p5 = XIP(v_pix5), p6 = XIP(v_pix6), p7 = XIP(v_pix7),
p9 = XIP(v_pix9), p10 = XIP(v_pix10), p11 = XIP(v_pix11),
p13 = XIP(v_pix13), p14 = XIP(v_pix14), p15 = XIP(v_pix15);
#else
float p1 = PIX(1,3), p2 = PIX(2,2), p3 = PIX(3,1),
p5 = PIX(3,-1), p6 = PIX(2,-2), p7 = PIX(1,-3),
p9 = PIX(-1,-3), p10 = PIX(-2,-2), p11 = PIX(-3,-1),
p13 = PIX(-3,1), p14 = PIX(-2,2), p15 = PIX(-1,3);
#endif
bool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);
bool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));
if(!isCorner)
return;
mat4 mp = mat4(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);
mat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);
mat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;
const vec4 zeros = vec4(0.0f), ones = vec4(1.0f);
vec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);
bs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);
bs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);
bs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);
float thisScore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;
float prevScore = decodeFloat16(prev.rb);
vec3 thisResult = vec3(encodeFloat16(thisScore), encodeLod(lod));
color.rba = thisScore > prevScore ? thisResult : color.rba;
#endif
}`},4824:r=>{r.exports=`uniform mediump float lod;
#if !defined(FAST_TYPE)
#error Undefined FAST_TYPE
#elif FAST_TYPE == 916
out vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,
v_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;
#else
#error Invalid FAST_TYPE
#endif
#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)
void vsmain()
{
float pot = exp2(lod);
#if FAST_TYPE == 916
v_pix0 = PIX(0,3); v_pix1 = PIX(1,3), v_pix2 = PIX(2,2), v_pix3 = PIX(3,1);
v_pix4 = PIX(3,0); v_pix5 = PIX(3,-1), v_pix6 = PIX(2,-2), v_pix7 = PIX(1,-3);
v_pix8 = PIX(0,-3); v_pix9 = PIX(-1,-3), v_pix10 = PIX(-2,-2), v_pix11 = PIX(-3,-1);
v_pix12 = PIX(-3,0); v_pix13 = PIX(-3,1), v_pix14 = PIX(-2,2), v_pix15 = PIX(-1,3);
#endif
}`},2381:r=>{r.exports=`@include "keypoints.glsl"
@include "keypoint-descriptors.glsl"
uniform sampler2D encodedKeypointsA;
uniform int encoderLengthA;
uniform sampler2D encodedKeypointsB;
uniform int encoderLengthB;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int threshold;
void main()
{
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
vec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);
color = data;
if(address.offset >= sizeofEncodedKeypointHeader() / 4)
return;
Keypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);
Keypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);
color = encodeNullKeypoint();
if(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))
return;
color = encodeDiscardedKeypoint();
if(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))
return;
color = encodeDiscardedKeypoint();
if(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))
return;
uint[DESCRIPTOR_SIZE] descriptorA, descriptorB;
descriptorA = readKeypointDescriptor(encodedKeypointsA, descriptorSize, extraSize, encoderLengthA, address);
descriptorB = readKeypointDescriptor(encodedKeypointsB, descriptorSize, extraSize, encoderLengthB, address);
int dist = distanceBetweenKeypointDescriptors(descriptorA, descriptorB);
bool shouldKeep = (dist <= threshold);
color = shouldKeep ? data : encodeDiscardedKeypoint();
}`},6060:r=>{r.exports=`@include "float16.glsl"
uniform sampler2D corners;
uniform sampler2D maxScore;
uniform float quality;
void main()
{
vec4 pixel = threadPixel(corners);
float score = decodeFloat16(pixel.rb);
float maxval = decodeFloat16(threadPixel(maxScore).rb);
float threshold = maxval * clamp(quality, 0.0f, 1.0f);
color = pixel;
color.rb = score >= threshold ? color.rb : encodeFloat16(0.0f);
}`},9974:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
@include "filters.glsl"
#if !defined(WINDOW_SIZE)
#error Undefined WINDOW_SIZE
#endif
#define WINDOW_RADIUS ((WINDOW_SIZE - 1) / 2)
uniform sampler2D corners;
uniform sampler2D pyramid;
uniform sampler2D derivatives;
uniform float lod;
uniform float lodStep;
uniform float gaussian[@WINDOW_SIZE@];
#define G(x) gaussian[(x) + WINDOW_RADIUS]
#define W(x,y) (G(x) * G(y))
#define H(ox,oy) dpix = pixelAtShortOffset(derivatives, ivec2((ox),(oy))); \\
df = (1.0f + lod) * decodePairOfFloat16(dpix); \\
h += vec3(df.x * df.x, df.x * df.y, df.y * df.y) * W((ox),(oy))
void main()
{
float intensity = 0.0f;
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(corners);
vec4 dpix = vec4(0.0f);
vec2 df = vec2(0.0f);
vec3 h = vec3(0.0f);
color = pixel;
#if WINDOW_SIZE == 1
H(0,0);
#elif WINDOW_SIZE == 3
H(-1,-1); H(0,-1); H(1,-1);
H(-1,0); H(0,0); H(1,0);
H(-1,1); H(0,1); H(1,1);
#elif WINDOW_SIZE == 5
H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2);
H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1);
H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0);
H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1);
H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2);
#elif WINDOW_SIZE == 7
H(-3,-3); H(-2,-3); H(-1,-3); H(0,-3); H(1,-3); H(2,-3); H(3,-3);
H(-3,-2); H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2); H(3,-2);
H(-3,-1); H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1); H(3,-1);
H(-3,0); H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0); H(3,0);
H(-3,1); H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1); H(3,1);
H(-3,2); H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2); H(3,2);
H(-3,3); H(-2,3); H(-1,3); H(0,3); H(1,3); H(2,3); H(3,3);
#else
#error Invalid WINDOW_SIZE
#endif
float response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));
response /= float(WINDOW_SIZE * WINDOW_SIZE);
float lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep);
float currentScaleStrength = abs(laplacian(pyramid, vec2(thread), lod));
float previousScaleStrength = abs(laplacian(pyramid, vec2(thread), lodPlus));
float previousResponse = decodeFloat16(pixel.rb);
vec4 result = vec4(encodeFloat16(response), encodeLod(lod), intensity);
color.rbag = (currentScaleStrength >= previousScaleStrength || previousResponse == 0.0f) ? result : pixel.rbag;
}`},3047:r=>{r.exports=`@include "keypoint-matches.glsl"
void main()
{
#if ENCODE_FILTERS != 0
KeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, 0);
#else
KeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);
#endif
color = encodeKeypointMatch(initial);
}`},3266:r=>{r.exports=`@include "keypoint-matches.glsl"
uniform sampler2D encodedMatches;
uniform sampler2D encodedKthMatches;
uniform int numberOfMatchesPerKeypoint;
uniform int kthMatch;
void main()
{
ivec2 thread = threadLocation();
ivec2 matcherSize = textureSize(encodedMatches, 0);
ivec2 kthMatcherSize = textureSize(encodedKthMatches, 0);
int rasterIndex = thread.y * matcherSize.x + thread.x;
int matchIndex = rasterIndex / numberOfMatchesPerKeypoint;
int matchCell = rasterIndex % numberOfMatchesPerKeypoint;
color = threadPixel(encodedMatches);
if(matchCell != kthMatch)
return;
color = encodeKeypointMatch(MATCH_NOT_FOUND);
if(matchIndex >= kthMatcherSize.x * kthMatcherSize.y)
return;
ivec2 pos = ivec2(matchIndex % kthMatcherSize.x, matchIndex / kthMatcherSize.x);
color = texelFetch(encodedKthMatches, pos, 0);
}`},8018:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
@include "filters.glsl"
uniform sampler2D corners;
uniform sampler2D pyramid;
uniform float lodStep;
uniform float lodOffset;
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(corners);
float lod = decodeLod(pixel.a);
float lodMinus = max(0.0f, lod - lodStep + lodOffset);
float lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep + lodOffset);
float lapMinus = laplacian(pyramid, vec2(thread), lodMinus);
float lapPlus = abs(lodPlus - lodMinus) < 1e-5 ? lapMinus : laplacian(pyramid, vec2(thread), lodPlus);
color = encodePairOfFloat16(vec2(lapMinus, lapPlus));
}`},3168:r=>{r.exports=`@include "keypoints.glsl"
@include "float16.glsl"
uniform sampler2D nextPyramid;
uniform sampler2D prevPyramid;
uniform sampler2D encodedFlow;
uniform sampler2D prevKeypoints;
uniform int level;
uniform int depth;
uniform int numberOfIterations;
uniform float discardThreshold;
uniform float epsilon;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#ifndef WINDOW_SIZE
#error Undefined WINDOW_SIZE
#endif
#define NEXT_IMAGE 1
#define PREV_IMAGE 0
const int WINDOW_RADIUS = (WINDOW_SIZE - 1) / 2;
const int WINDOW_SIZE_SQUARED = (WINDOW_SIZE) * (WINDOW_SIZE);
const int WINDOW_SIZE_PLUS = (WINDOW_SIZE) + 2;
const int WINDOW_SIZE_PLUS_SQUARED = WINDOW_SIZE_PLUS * WINDOW_SIZE_PLUS;
const int DBL_WINDOW_SIZE_PLUS_SQUARED = 2 * WINDOW_SIZE_PLUS_SQUARED;
const int WINDOW_RADIUS_PLUS = (WINDOW_SIZE_PLUS - 1) / 2;
const highp float FLT_SCALE = 9.5367431640625e-7;
const highp float FLT_EPSILON = 0.00000011920929f;
int pixelBuffer[DBL_WINDOW_SIZE_PLUS_SQUARED];
#define prevPixel(index) pixelBuffer[(index)]
#define nextPixel(index) pixelBuffer[WINDOW_SIZE_PLUS_SQUARED + (index)]
#define pixelIndex(i, j) (((j) + WINDOW_RADIUS_PLUS) * WINDOW_SIZE_PLUS + ((i) + WINDOW_RADIUS_PLUS))
ivec2 derivBuffer[WINDOW_SIZE_SQUARED];
#define derivativesAt(x, y) derivBuffer[((y) + WINDOW_RADIUS) * WINDOW_SIZE + ((x) + WINDOW_RADIUS)]
void readWindow(vec2 center, float lod)
{
const int r = WINDOW_RADIUS;
ivec2 pyrBaseSize = textureSize(prevPyramid, 0);
float pot = exp2(lod);
ivec2 offset; int idx;
#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); \\
idx = pixelIndex(offset.x, offset.y); \\
nextPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g); \\
prevPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g)
for(int j = 0; j < WINDOW_SIZE; j++) {
for(int i = 0; i < WINDOW_SIZE; i++) {
readPixelsAt(i-r, j-r);
}
}
int r1 = r+1;
for(int k = 0; k < WINDOW_SIZE; k++) {
readPixelsAt(-r1, k-r);
readPixelsAt( r1, k-r);
readPixelsAt(k-r,-r1);
readPixelsAt(k-r, r1);
}
readPixelsAt(-r1,-r1);
readPixelsAt( r1,-r1);
readPixelsAt(-r1, r1);
readPixelsAt( r1, r1);
}
ivec2 computeDerivatives(int imageCode, ivec2 offset)
{
const mat3 dx = mat3(
3, 0, -3,
10, 0, -10,
3, 0, -3
);
const mat3 dy = mat3(
3, 10, 3,
0, 0, 0,
-3, -10, -3
);
int indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;
mat3 window = mat3(
pixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],
pixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],
pixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],
pixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],
0.0f,
pixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],
pixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],
pixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],
pixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]
);
mat3 fx = matrixCompMult(dx, window);
mat3 fy = matrixCompMult(dy, window);
const vec3 ones = vec3(1.0f);
return ivec2(
dot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),
dot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)
);
}
int readBufferedPixel(int imageCode, ivec2 offset)
{
const int r = WINDOW_RADIUS;
offset = clamp(offset, -r, r);
int indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;
return pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];
}
int readBufferedSubpixel(int imageCode, vec2 offset)
{
ivec2 p = ivec2(floor(offset));
vec2 frc = fract(offset);
vec2 ifrc = vec2(1.0f) - frc;
vec4 pix = vec4(
readBufferedPixel(imageCode, p),
readBufferedPixel(imageCode, p + ivec2(1,0)),
readBufferedPixel(imageCode, p + ivec2(0,1)),
readBufferedPixel(imageCode, p + ivec2(1,1))
);
vec4 sub = vec4(
ifrc.x * ifrc.y,
frc.x * ifrc.y,
ifrc.x * frc.y,
frc.x * frc.y
);
return int(0.5f + dot(sub*pix, vec4(1.0f)));
}
vec2 computeMismatch(vec2 pyrGuess, vec2 localGuess)
{
const int r = WINDOW_RADIUS;
int timeDerivative;
ivec2 mismatch = ivec2(0);
int x, y, _x, _y;
vec2 d = pyrGuess + localGuess;
#define innerLoop() \\
for(_x = 0; _x < WINDOW_SIZE; _x++) { \\
x = _x - r; y = _y - r; \\
timeDerivative = ( \\
readBufferedSubpixel(NEXT_IMAGE, vec2(x, y) + d) - \\
readBufferedPixel(PREV_IMAGE, ivec2(x, y)) \\
); \\
mismatch += derivativesAt(x, y) * timeDerivative; \\
}
@unroll
for(_y = 0; _y < WINDOW_SIZE; _y++) {
innerLoop();
}
return vec2(mismatch) * FLT_SCALE;
}
bool isInsideImage(vec2 position)
{
vec2 imageSize = vec2(textureSize(nextPyramid, 0));
vec2 border = vec2(WINDOW_SIZE);
return all(bvec4(
greaterThanEqual(position, border),
lessThan(position, imageSize - border)
));
}
void main()
{
vec4 pixel = threadPixel(encodedFlow);
ivec2 thread = threadLocation();
float windowArea = float(WINDOW_SIZE * WINDOW_SIZE);
const int r = WINDOW_RADIUS;
int keypointIndex = thread.x + thread.y * outputSize().x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);
color = encodeNullPairOfFloat16();
if(isNullKeypoint(keypoint))
return;
color = encodeDiscardedPairOfFloat16();
if(isBadKeypoint(keypoint))
return;
vec2 pyrGuess = (level < depth - 1) ? decodePairOfFloat16(pixel) : vec2(0.0f);
pyrGuess *= 2.0f;
readWindow(keypoint.position, float(level));
ivec2 derivatives;
ivec3 harris3i = ivec3(0);
for(int j = 0; j < WINDOW_SIZE; j++) {
for(int i = 0; i < WINDOW_SIZE; i++) {
derivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));
harris3i += ivec3(
derivatives.x * derivatives.x,
derivatives.x * derivatives.y,
derivatives.y * derivatives.y
);
derivativesAt(i-r, j-r) = derivatives;
}
}
highp vec3 harris = vec3(harris3i) * FLT_SCALE;
highp mat2 invHarris = mat2(harris.z, -harris.y, -harris.y, harris.x);
highp float det = harris.x * harris.z - harris.y * harris.y;
highp float invDet = abs(det) >= FLT_EPSILON ? 1.0f / det : 0.0f;
highp float minEigenvalue = 0.5f * ((harris.x + harris.z) - sqrt(
(harris.x - harris.z) * (harris.x - harris.z) + 4.0f * (harris.y * harris.y)
));
int niceNumbers = int(abs(det) >= FLT_EPSILON && minEigenvalue >= discardThreshold * windowArea);
bool goodKeypoint = (level > 0) || (niceNumbers != 0);
highp float eps2 = epsilon * epsilon;
highp vec2 mismatch, delta, localGuess = vec2(0.0f);
for(int k = 0; k < numberOfIterations; k++) {
mismatch = niceNumbers != 0 ? computeMismatch(pyrGuess, localGuess) : vec2(0.0f);
delta = mismatch * invHarris * invDet;
niceNumbers *= int(eps2 <= dot(delta, delta));
localGuess += float(niceNumbers) * delta;
}
vec2 opticalFlow = pyrGuess + localGuess;
bool mustDiscard = (level == 0) && any(bvec2(
!goodKeypoint,
!isInsideImage(keypoint.position + opticalFlow)
));
color = !mustDiscard ? encodePairOfFloat16(opticalFlow) : encodeDiscardedPairOfFloat16();
}`},3890:r=>{r.exports=`#if @FS_USE_CUSTOM_PRECISION@
precision mediump int;
precision mediump float;
#endif
#if !defined(STAGE)
#error Undefined STAGE
#elif STAGE == 1
@include "float16.glsl"
uniform sampler2D corners;
#elif STAGE < 1
uniform mediump usampler2D lookupTable;
#else
#define SKIP_TEXTURE_READS 1
#define DENSITY_FACTOR 0.10
uniform mediump usampler2D lookupTable;
uniform int blockSize;
uniform int width;
uniform int height;
in vec2 v_topLeft, v_top, v_topRight,
v_left, v_center, v_right,
v_bottomLeft, v_bottom, v_bottomRight;
#endif
const uvec2 NULL_ELEMENT = uvec2(0xFFFFu);
void main()
{
#if STAGE == 1
uvec2 outSize = uvec2(outputSize());
uvec2 thread = uvec2(threadLocation());
uvec2 size = uvec2(textureSize(corners, 0));
uint location = thread.y * outSize.x + thread.x;
ivec2 pos = ivec2(location % size.x, location / size.x);
vec4 pixel = location < size.x * size.y ? texelFetch(corners, pos, 0) : vec4(0.0f);
bool isCorner = !isEncodedFloat16Zero(pixel.rb);
color = isCorner ? uvec4(uvec2(pos), 1u, 0u) : uvec4(NULL_ELEMENT, 0u, 0u);
#elif STAGE > 1
int dblBlockSize = 2 * blockSize;
ivec2 thread = threadLocation();
ivec2 offset = thread % dblBlockSize;
ivec2 delta = thread - offset;
#if SKIP_TEXTURE_READS
if(blockSize >= 8) {
uint sb = texture(lookupTable, texCoord).z;
float p = max((float(sb) / float(blockSize)) / float(blockSize), DENSITY_FACTOR);
float rowthr = float(dblBlockSize) * p + 3.0f * sqrt(p * (1.0f - p));
color = uvec4(NULL_ELEMENT, 4u * sb, 0u);
if(offset.y >= max(1, int(ceil(rowthr))))
return;
}
#endif
#define deltaCenter ivec2(0,0)
#define deltaTop ivec2(0,-blockSize)
#define deltaTopRight ivec2(blockSize,-blockSize)
#define deltaRight ivec2(blockSize,0)
#define deltaBottomRight ivec2(blockSize,blockSize)
#define deltaBottom ivec2(0,blockSize)
#define deltaBottomLeft ivec2(-blockSize,blockSize)
#define deltaLeft ivec2(-blockSize,0)
#define deltaTopLeft ivec2(-blockSize,-blockSize)
ivec2 boundary = ivec2(width - 1, height - 1) / blockSize;
ivec2 bottomRightPos = thread + deltaBottomRight;
uvec2 valid = uvec2(
bottomRightPos.x < width  || bottomRightPos.x / blockSize == boundary.x,
bottomRightPos.y < height || bottomRightPos.y / blockSize == boundary.y
);
uvec4 mask[4];
mask[0] = uvec4(1u, valid.x, valid.y, valid.x * valid.y);
mask[1] = uvec4(1u, 1u, valid.y, valid.y);
mask[2] = uvec4(1u, valid.x, 1u, valid.x);
mask[3] = uvec4(1u);
#if SKIP_TEXTURE_READS
#define calcSb(delta) texelFetch(lookupTable, blockSize * ((thread + (delta)) / blockSize), 0).z
uint center = calcSb(deltaCenter);
uint top = calcSb(deltaTop);
uint topRight = calcSb(deltaTopRight);
uint right = calcSb(deltaRight);
uint bottomRight = calcSb(deltaBottomRight);
uint bottom = calcSb(deltaBottom);
uint bottomLeft = calcSb(deltaBottomLeft);
uint left = calcSb(deltaLeft);
uint topLeft = calcSb(deltaTopLeft);
#else
#define calcSb(pos) texture(lookupTable, (pos)).z
uint center = calcSb(v_center);
uint top = calcSb(v_top);
uint topRight = calcSb(v_topRight);
uint right = calcSb(v_right);
uint bottomRight = calcSb(v_bottomRight);
uint bottom = calcSb(v_bottom);
uint bottomLeft = calcSb(v_bottomLeft);
uint left = calcSb(v_left);
uint topLeft = calcSb(v_topLeft);
#endif
uvec4 sums[4];
sums[0] = uvec4(center, right, bottom, bottomRight);
sums[1] = uvec4(left, center, bottomLeft, bottom);
sums[2] = uvec4(top, topRight, center, right);
sums[3] = uvec4(topLeft, top, left, center);
ivec2 cmp = ivec2(greaterThanEqual(offset, ivec2(blockSize)));
int option = 2 * cmp.y + cmp.x;
uvec4 cdef = sums[option] * mask[option];
uint c2b = cdef.x, d2b = cdef.y, e2b = cdef.z, f2b = cdef.w;
uint sb = center;
uint s2b = c2b + d2b + e2b + f2b;
s2b = s2b < sb ? 0xFFFFu : min(0xFFFFu, s2b);
uint w2b = uint(min(dblBlockSize, width - delta.x));
uvec2 uoffset = uvec2(offset);
uint ceiling = s2b >= uoffset.x ? (s2b - uoffset.x) / w2b + uint((s2b - uoffset.x) % w2b > 0u) : 0u;
color = uvec4(NULL_ELEMENT, s2b, 0u);
if(uoffset.y >= ceiling)
return;
uint i2b = uoffset.y * w2b + uoffset.x;
uint j2b = i2b >= c2b ? i2b - c2b : 0u;
uint k2b = j2b >= d2b ? j2b - d2b : 0u;
uint l2b = k2b >= e2b ? k2b - e2b : 0u;
uint wl = uint(min(blockSize, width - delta.x));
uint wr = uint(min(blockSize, width - delta.x - blockSize));
ivec2 magicOffset = (
(i2b < c2b) ? ivec2(i2b % wl, i2b / wl) : (
(j2b < d2b) ? ivec2(j2b % wr, j2b / wr) + ivec2(blockSize, 0) : (
(k2b < e2b) ? ivec2(k2b % wl, k2b / wl) + ivec2(0, blockSize) : (
(l2b < f2b) ? ivec2(l2b % wr, l2b / wr) + ivec2(blockSize) : ivec2(0)
))));
uvec2 a2b = texelFetch(lookupTable, delta + magicOffset, 0).xy;
color = uvec4(a2b, s2b, 0u);
#else
uvec4 pix = texture(lookupTable, texCoord);
color = all(equal(pix.xy, NULL_ELEMENT)) ? vec4(0,1,1,1) : vec4(1,0,0,1);
#endif
}`},8647:r=>{r.exports=`#if !defined(STAGE) || STAGE < 1
#error Invalid STAGE
#else
uniform mediump int blockSize;
out vec2 v_topLeft, v_top, v_topRight,
v_left, v_center, v_right,
v_bottomLeft, v_bottom, v_bottomRight;
void vsmain()
{
float b = float(blockSize);
#define V(x,y) (texCoord + (vec2((x),(y)) * b) / texSize)
v_topLeft = V(-1,-1); v_top = V(0,-1); v_topRight = V(1,-1);
v_left = V(-1,0); v_center = V(0,0); v_right = V(1,0);
v_bottomLeft = V(-1,1); v_bottom = V(0,1); v_bottomRight = V(1,1);
}
#endif`},4776:r=>{r.exports=`@include "keypoints.glsl"
@include "keypoint-matches.glsl"
@include "keypoint-descriptors.glsl"
uniform sampler2D candidates;
uniform sampler2D filters;
uniform int matcherLength;
uniform sampler2D tables;
uniform sampler2D descriptorDB;
uniform int tableIndex;
uniform int bucketCapacity;
uniform int bucketsPerTable;
uniform int tablesStride;
uniform int descriptorDBStride;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#if HASH_SIZE > SEQUENCE_MAXLEN
#error LSH: invalid HASH_SIZE
#elif SEQUENCE_COUNT * SEQUENCE_MAXLEN * 4 > 16384
#error LSH: sequences are too large!
#elif (SEQUENCE_COUNT * SEQUENCE_MAXLEN) % 4 > 0
#error LSH: sequences of invalid size!
#endif
layout(std140) uniform LSHSequences
{
uvec4 sequences[(SEQUENCE_COUNT * SEQUENCE_MAXLEN) / 4];
};
#if HASH_SIZE == 10
const int SWAP_COUNT[3] = int[3](1, 11, 56);
const int[56] SWAP = int[56](0,1,2,4,8,16,32,64,128,256,512,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768);
#elif HASH_SIZE == 11
const int SWAP_COUNT[3] = int[3](1, 12, 67);
const int[67] SWAP = int[67](0,1,2,4,8,16,32,64,128,256,512,1024,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536);
#elif HASH_SIZE == 12
const int SWAP_COUNT[3] = int[3](1, 13, 79);
const int[79] SWAP = int[79](0,1,2,4,8,16,32,64,128,256,512,1024,2048,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072);
#elif HASH_SIZE == 13
const int SWAP_COUNT[3] = int[3](1, 14, 92);
const int[92] SWAP = int[92](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144);
#elif HASH_SIZE == 14
const int SWAP_COUNT[3] = int[3](1, 15, 106);
const int[106] SWAP = int[106](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288);
#elif HASH_SIZE == 15
const int SWAP_COUNT[3] = int[3](1, 16, 121);
const int[121] SWAP = int[121](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576);
#elif HASH_SIZE == 16
const int SWAP_COUNT[3] = int[3](1, 17, 137);
const int[137] SWAP = int[137](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152);
#elif HASH_SIZE == 17
const int SWAP_COUNT[3] = int[3](1, 18, 154);
const int[154] SWAP = int[154](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304);
#elif HASH_SIZE == 18
const int SWAP_COUNT[3] = int[3](1, 19, 172);
const int[172] SWAP = int[172](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608);
#elif HASH_SIZE == 19
const int SWAP_COUNT[3] = int[3](1, 20, 191);
const int[191] SWAP = int[191](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216);
#elif HASH_SIZE == 20
const int SWAP_COUNT[3] = int[3](1, 21, 211);
const int[211] SWAP = int[211](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216,524289,524290,524292,524296,524304,524320,524352,524416,524544,524800,525312,526336,528384,532480,540672,557056,589824,655360,786432);
#else
#error Invalid HASH_SIZE
#endif
#if LEVEL < 0 || LEVEL > 2
#error Invalid LEVEL
#endif
const uint END_OF_LIST = 0xFFFFFFFFu;
const int NUMBER_OF_HASHES = SWAP_COUNT[LEVEL];
uint sequenceElement(int sequenceIndex, int elementIndex)
{
int offset = (SEQUENCE_MAXLEN) * sequenceIndex + elementIndex;
uvec4 tuple = sequences[offset / 4];
return tuple[offset & 3];
}
int descriptorHash(uint[DESCRIPTOR_SIZE] descriptor, int sequenceIndex)
{
uint bit, b, m;
int hash = 0;
@unroll
for(int i = 0; i < HASH_SIZE; i++) {
bit = sequenceElement(sequenceIndex, i);
b = bit >> 3u;
m = 1u << (bit & 7u);
hash = (hash << 1) | int((descriptor[b] & m) != 0u);
}
return hash;
}
#define readTableData(tables, tablesStride, rasterIndex) decodeUint32(texelFetch((tables), ivec2((rasterIndex) % (tablesStride), (rasterIndex) / (tablesStride)), 0))
void main()
{
ivec2 thread = threadLocation();
int keypointIndex = thread.x + thread.y * matcherLength;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
color = encodeKeypointMatch(MATCH_NOT_FOUND);
if(isBadKeypoint(keypoint))
return;
KeypointMatch candidate = decodeKeypointMatch(threadPixel(candidates));
KeypointMatch mfilter = decodeKeypointMatch(threadPixel(filters));
uint[DESCRIPTOR_SIZE] candidateDescriptor;
uint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);
int hash0 = descriptorHash(descriptor, tableIndex);
for(int h = 0; h < NUMBER_OF_HASHES; h++) {
int hash = hash0 ^ SWAP[h];
int tableAddress = tableIndex * bucketsPerTable * bucketCapacity;
int bucketAddress = tableAddress + hash * bucketCapacity;
bool validEntry = true;
for(int b = 0; b < bucketCapacity; b++) {
int entryAddress = bucketAddress + b;
uint entry = validEntry ? readTableData(tables, tablesStride, entryAddress) : END_OF_LIST;
validEntry = (validEntry && entry != END_OF_LIST);
int candidateIndex = int(entry);
candidateDescriptor = readKeypointDescriptorFromDB(descriptorDB, descriptorDBStride, validEntry ? candidateIndex : -1);
int descriptorDistance = distanceBetweenKeypointDescriptors(descriptor, candidateDescriptor);
KeypointMatch match = KeypointMatch(candidateIndex, descriptorDistance);
bool betterThanCandidate = (match.dist < candidate.dist) || (match.dist == candidate.dist && match.index > candidate.index);
bool worseThanFilter = (match.dist > mfilter.dist) || (match.dist == mfilter.dist && match.index < mfilter.index);
bool nicerMatch = (validEntry && betterThanCandidate && worseThanFilter);
ivec2 v = nicerMatch ? ivec2(match.index, match.dist) : ivec2(candidate.index, candidate.dist);
candidate = KeypointMatch(v.x, v.y);
}
}
color = encodeKeypointMatch(candidate);
}`},2648:r=>{r.exports=`@include "keypoints.glsl"
@include "int32.glsl"
#if !defined(STAGE)
#error Undefined STAGE
#elif STAGE == 1
uniform sampler2D encodedKeypointsA;
uniform sampler2D encodedKeypointsB;
uniform int encoderLengthA;
uniform int encoderLengthB;
uniform int encoderCapacityA;
uniform int encoderCapacityB;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#elif STAGE == 2
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int maxKeypoints;
#elif STAGE == 3
uniform sampler2D array;
uniform int blockSize;
#elif STAGE == 4
uniform sampler2D array;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#elif STAGE == 5
uniform sampler2D array;
#else
#error Invalid STAGE
#endif
#define NULL_KEYPOINT_INDEX 0xFFFF
const highp uint UNIT = 0x10000u;
void main()
{
#if STAGE == 1
ivec2 thread = threadLocation();
KeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);
int newKeypointIndex = keypointIndex < encoderCapacityA ? keypointIndex : keypointIndex - encoderCapacityA;
color = encodeNullKeypoint();
if(newKeypointIndex >= max(encoderCapacityA, encoderCapacityB))
return;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
addr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);
vec4 dataA = readKeypointData(encodedKeypointsA, encoderLengthA, addr);
vec4 dataB = readKeypointData(encodedKeypointsB, encoderLengthB, addr);
color = keypointIndex < encoderCapacityA ? dataA : dataB;
#elif STAGE == 2
ivec2 thread = threadLocation();
int keypointIndex = thread.y * outputSize().x + thread.x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress addr = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);
bool isValid = !isNullKeypoint(keypoint) && keypointIndex < maxKeypoints;
keypointIndex = isValid ? keypointIndex : NULL_KEYPOINT_INDEX;
color = encodeUint32(uint(keypointIndex & 0xFFFF) | (isValid ? UNIT : 0u));
#elif STAGE == 3
ivec2 thread = threadLocation();
ivec2 size = outputSize();
int arrayLength = size.x * size.y;
int arrayIndex = thread.y * size.x + thread.x;
int arrayIndexLeft = arrayIndex - blockSize;
int arrayIndexRight = arrayIndex + blockSize;
int mask = int(arrayIndexRight < arrayLength || arrayIndexRight / blockSize == (arrayLength - 1) / blockSize);
arrayIndexLeft = max(0, arrayIndexLeft);
arrayIndexRight = min(arrayLength - 1, arrayIndexRight);
#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)
uvec3 entries32 = uvec3(
decodeUint32(threadPixel(array)),
decodeUint32(texelFetch(array, raster2pos(arrayIndexLeft), 0)),
decodeUint32(texelFetch(array, raster2pos(arrayIndexRight), 0))
);
ivec3 sb = ivec3((entries32 >> 16u) & 0xFFFFu);
sb.z *= mask;
int dblBlockSize = 2 * blockSize;
int offset = arrayIndex % dblBlockSize;
int s2b = sb.x + (offset < blockSize ? sb.z : sb.y);
int l2b = offset < blockSize ? sb.x : sb.y;
uint keypointIndex = entries32.x & 0xFFFFu;
uint shiftedS2b = uint(s2b) << 16u;
color = encodeUint32(uint(NULL_KEYPOINT_INDEX) | shiftedS2b);
if(offset >= s2b)
return;
color = encodeUint32(keypointIndex | shiftedS2b);
if(offset < l2b)
return;
vec4 entry = texelFetch(array, raster2pos(arrayIndex + blockSize - l2b), 0);
keypointIndex = decodeUint32(entry) & 0xFFFFu;
color = encodeUint32(keypointIndex | shiftedS2b);
#elif STAGE == 4
ivec2 thread = threadLocation();
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);
#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)
ivec2 size = textureSize(array, 0);
uint sortedPair = decodeUint32(texelFetch(array, raster2pos(keypointIndex), 0));
int newKeypointIndex = int(sortedPair & 0xFFFFu);
color = encodeNullKeypoint();
if(newKeypointIndex == NULL_KEYPOINT_INDEX || keypointIndex >= size.x * size.y)
return;
KeypointAddress newAddr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);
color = readKeypointData(encodedKeypoints, encoderLength, newAddr);
#elif STAGE == 5
uint val = decodeUint32(threadPixel(array));
color = (val & 0xFFFFu) == uint(NULL_KEYPOINT_INDEX) ? vec4(0,1,1,1) : vec4(1,0,0,1);
#endif
}`},8825:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
@include "filters.glsl"
#if !defined(USE_LAPLACIAN)
#error Undefined USE_LAPLACIAN
#endif
uniform sampler2D corners;
uniform sampler2D pyramid;
uniform float lodStep;
#if USE_LAPLACIAN
uniform sampler2D pyrLaplacian;
#endif
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(corners);
float score = decodeFloat16(pixel.rb);
float myEncodedLod = pixel.a;
float lod = decodeLod(myEncodedLod);
float lodPlus = lod + lodStep;
float lodMinus = lod - lodStep;
float pot = exp2(lod);
float potPlus = exp2(lodPlus);
float potMinus = exp2(lodMinus);
color = pixel;
if(score == 0.0f)
return;
#define P(p,u,v) textureLod(corners, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)
vec4 pix[18];
#define D(u,v) P(potMinus,(u),(v))
pix[0] = D(-1,-1); pix[1] = D(0,-1); pix[2] = D(1,-1);
pix[3] = D(-1,0); pix[4] = D(0,0); pix[5] = D(1,0);
pix[6] = D(-1,1); pix[7] = D(0,1); pix[8] = D(1,1);
#define U(u,v) P(potPlus,(u),(v))
pix[9] = U(-1,-1); pix[10] = U(0,-1); pix[11] = U(1,-1);
pix[12] = U(-1,0); pix[13] = U(0,0); pix[14] = U(1,0);
pix[15] = U(-1,1); pix[16] = U(0,1); pix[17] = U(1,1);
float scores[18];
#define C(j) decodeFloat16(pix[j].rb)
scores[0] = C(0); scores[1] = C(1); scores[2] = C(2);
scores[3] = C(3); scores[4] = C(4); scores[5] = C(5);
scores[6] = C(6); scores[7] = C(7); scores[8] = C(8);
scores[9] = C(9); scores[10] = C(10); scores[11] = C(11);
scores[12] = C(12); scores[13] = C(13); scores[14] = C(14);
scores[15] = C(15); scores[16] = C(16); scores[17] = C(17);
float lods[18];
#define E(j) decodeLod(pix[j].a)
lods[0] = E(0); lods[1] = E(1); lods[2] = E(2);
lods[3] = E(3); lods[4] = E(4); lods[5] = E(5);
lods[6] = E(6); lods[7] = E(7); lods[8] = E(8);
lods[9] = E(9); lods[10] = E(10); lods[11] = E(11);
lods[12] = E(12); lods[13] = E(13); lods[14] = E(14);
lods[15] = E(15); lods[16] = E(16); lods[17] = E(17);
#if USE_LAPLACIAN
#define L(p,u,v) textureLod(pyrLaplacian, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)
mat3 strengths[2];
strengths[0] = mat3(
#define Lm(u,v) abs(decodeFloat16(L(potMinus,(u),(v)).xy))
Lm(-1,-1), Lm(0,-1), Lm(1,-1),
Lm(-1,0), Lm(0,0), Lm(1,0),
Lm(-1,1), Lm(0,1), Lm(1,1)
);
strengths[1] = mat3(
#define Lp(u,v) abs(decodeFloat16(L(potPlus,(u),(v)).zw))
Lp(-1,-1), Lp(0,-1), Lp(1,-1),
Lp(-1,0), Lp(0,0), Lp(1,0),
Lp(-1,1), Lp(0,1), Lp(1,1)
);
float myStrength = abs(laplacian(pyramid, vec2(thread), lod));
#else
#define L(u,v) (((v)+1)*3 + ((u)+1))
mat3 strengths[2];
strengths[0] = mat3(
#define Lm(u,v) scores[L((u),(v))]
Lm(-1,-1), Lm(0,-1), Lm(1,-1),
Lm(-1,0), Lm(0,0), Lm(1,0),
Lm(-1,1), Lm(0,1), Lm(1,1)
);
strengths[1] = mat3(
#define Lp(u,v) scores[9 + L((u),(v))]
Lp(-1,-1), Lp(0,-1), Lp(1,-1),
Lp(-1,0), Lp(0,0), Lp(1,0),
Lp(-1,1), Lp(0,1), Lp(1,1)
);
float myStrength = score;
#endif
#define B(j,lod) float(isSameLod(lods[j], (lod))) * float(scores[j] > 0.0f)
mat3 nearLod[2];
nearLod[0] = mat3(
#define Bm(j) B((j), lodMinus)
Bm(0), Bm(1), Bm(2),
Bm(3), Bm(4), Bm(5),
Bm(6), Bm(7), Bm(8)
);
nearLod[1] = mat3(
#define Bp(j) B((j), lodPlus)
Bp(9), Bp(10), Bp(11),
Bp(12), Bp(13), Bp(14),
Bp(15), Bp(16), Bp(17)
);
mat3 upStrengths = matrixCompMult(strengths[1], nearLod[1]);
mat3 downStrengths = matrixCompMult(strengths[0], nearLod[0]);
vec3 maxUpStrength3 = max(upStrengths[0], max(upStrengths[1], upStrengths[2]));
vec3 maxDownStrength3 = max(downStrengths[0], max(downStrengths[1], downStrengths[2]));
vec3 maxStrength3 = max(maxUpStrength3, maxDownStrength3);
float maxStrength = max(maxStrength3.x, max(maxStrength3.y, maxStrength3.z));
color.rb = encodeFloat16(score * step(maxStrength, myStrength));
}`},5693:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
uniform sampler2D corners;
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(corners);
float encodedLod = pixel.a;
float score = decodeFloat16(pixel.rb);
float lod = decodeLod(encodedLod);
float pot = exp2(lod);
color = pixel;
if(score == 0.0f)
return;
#if 1
vec2 gridSize = vec2(pot);
vec2 gridLocation = floor(mod(texCoord * texSize, gridSize));
vec2 gridDelta = gridLocation / gridSize - vec2(0.5f);
float gridStep = 1.0f / pot;
const float adjustment = 1.25f;
color.rb = encodeFloat16(0.0f);
if(max(abs(gridDelta.x), abs(gridDelta.y)) > adjustment * gridStep)
return;
#endif
#define P(x,y) textureLod(corners, texCoord + pot * vec2((x), (y)) / texSize, 0.0f)
vec4 pix[9];
pix[0] = P(-1,-1); pix[1] = P(0,-1); pix[2] = P(1,-1);
pix[3] = P(-1, 0); pix[4] = pixel;   pix[5] = P(1, 0);
pix[6] = P(-1, 1); pix[7] = P(0, 1); pix[8] = P(1, 1);
#define S(j) decodeFloat16(pix[j].rb)
mat3 scores = mat3(
S(0), S(1), S(2),
S(3), S(4), S(5),
S(6), S(7), S(8)
);
#define B(j) float(isSameLod(decodeLod(pix[j].a), lod))
mat3 sameLod = mat3(
B(0), B(1), B(2),
B(3), B(4), B(5),
B(6), B(7), B(8)
);
mat3 sameLodScores = matrixCompMult(scores, sameLod);
vec3 maxScore3 = max(sameLodScores[0], max(sameLodScores[1], sameLodScores[2]));
float maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));
color.rb = encodeFloat16(score * step(maxScore, score));
}`},9280:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
uniform sampler2D image;
uniform float lodStep;
#if !defined(MULTISCALE)
#error Must define MULTISCALE
#elif MULTISCALE != 0
#define LOD_STEP (lodStep)
#define USE_MIDDLE_RING
#else
#define LOD_STEP (0.0f)
#endif
#define PIX(x,y) pixelAtShortOffset(image, ivec2((x),(y)))
#define L2(v,i) bvec2(isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))
#define L3(v,i) bvec3(isSameEncodedLod(v[i].a, alpha), isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))
#define S3(v,i) decodeFloat16(v[i].rb) * float(any(L3(v,i)))
#define S2(v,i) decodeFloat16(v[i].rb) * float(any(L2(v,i)))
#define P(i) S3(p,i)
#define Q(i) S2(q,i)
#define R(i) S2(r,i)
const vec4 O = vec4(0.0f);
void main()
{
vec4 pixel = threadPixel(image);
float lod = decodeLod(pixel.a);
float score = decodeFloat16(pixel.rb);
color = pixel;
if(score == 0.0f)
return;
vec4 p[8];
p[0] = PIX(0,1); p[1] = PIX(1,1); p[2] = PIX(1,0); p[3] = PIX(1,-1);
p[4] = PIX(0,-1); p[5] = PIX(-1,-1); p[6] = PIX(-1,0); p[7] = PIX(-1,1);
#ifdef USE_MIDDLE_RING
vec4 q[16];
q[0] = PIX(0,2); q[1] = PIX(1,2); q[2] = PIX(2,2); q[3] = PIX(2,1);
q[4] = PIX(2,0); q[5] = PIX(2,-1); q[6] = PIX(2,-2); q[7] = PIX(1,-2);
q[8] = PIX(0,-2); q[9] = PIX(-1,-2); q[10] = PIX(-2,-2); q[11] = PIX(-2,-1);
q[12] = PIX(-2,0); q[13] = PIX(-2,1); q[14] = PIX(-2,2); q[15] = PIX(-1,2);
#else
vec4 q[16];
q[0] = O; q[1] = O; q[2] = O; q[3] = O;
q[4] = O; q[5] = O; q[6] = O; q[7] = O;
q[8] = O; q[9] = O; q[10] = O; q[11] = O;
q[12] = O; q[13] = O; q[14] = O; q[15] = O;
#endif
#ifdef USE_OUTER_RING
vec4 r[16];
r[0] = PIX(0,3); r[1] = PIX(1,3); r[2] = PIX(3,1); r[3] = PIX(3,0);
r[4] = PIX(3,-1); r[5] = PIX(1,-3); r[6] = PIX(0,-3); r[7] = PIX(-1,-3);
r[8] = PIX(-3,-1); r[9] = PIX(-3,0); r[10] = PIX(-3,1); r[11] = PIX(-1,3);
r[12] = PIX(0,4); r[13] = PIX(4,0); r[14] = PIX(0,-4); r[15] = PIX(-4,0);
#else
vec4 r[16];
r[0] = O; r[1] = O; r[2] = O; r[3] = O;
r[4] = O; r[5] = O; r[6] = O; r[7] = O;
r[8] = O; r[9] = O; r[10] = O; r[11] = O;
r[12] = O; r[13] = O; r[14] = O; r[15] = O;
#endif
float alphaPlus = encodeLod(lod + LOD_STEP);
float alphaMinus = encodeLod(lod - LOD_STEP);
float alpha = encodeLod(lod);
mat3 innerScore = mat3(
P(0), P(1), P(2), P(3),
P(4), P(5), P(6), P(7),
0.0f);
mat4 middleScore = mat4(
Q(0), Q(1), Q(2), Q(3),
Q(4), Q(5), Q(6), Q(7),
Q(8), Q(9), Q(10), Q(11),
Q(12), Q(13), Q(14), Q(15)
);
mat4 outerScore = mat4(
R(0), R(1), R(2), R(3),
R(4), R(5), R(6), R(7),
R(8), R(9), R(10), R(11),
R(12), R(13), R(14), R(15)
);
vec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));
vec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));
vec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));
float maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));
float maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));
float maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));
float maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));
float finalScore = step(maxScore, score) * score;
color.rb = encodeFloat16(finalScore);
}`},9108:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedCorners;
uniform int encoderLength;
uniform sampler2D image;
uniform int extraSize;
const int descriptorSize = 32;
#define P(a,b,c,d) ivec4((a),(b),(c),(d))
const ivec4 pat31[256] = ivec4[256](
P(8,-3,9,5),
P(4,2,7,-12),
P(-11,9,-8,2),
P(7,-12,12,-13),
P(2,-13,2,12),
P(1,-7,1,6),
P(-2,-10,-2,-4),
P(-13,-13,-11,-8),
P(-13,-3,-12,-9),
P(10,4,11,9),
P(-13,-8,-8,-9),
P(-11,7,-9,12),
P(7,7,12,6),
P(-4,-5,-3,0),
P(-13,2,-12,-3),
P(-9,0,-7,5),
P(12,-6,12,-1),
P(-3,6,-2,12),
P(-6,-13,-4,-8),
P(11,-13,12,-8),
P(4,7,5,1),
P(5,-3,10,-3),
P(3,-7,6,12),
P(-8,-7,-6,-2),
P(-2,11,-1,-10),
P(-13,12,-8,10),
P(-7,3,-5,-3),
P(-4,2,-3,7),
P(-10,-12,-6,11),
P(5,-12,6,-7),
P(5,-6,7,-1),
P(1,0,4,-5),
P(9,11,11,-13),
P(4,7,4,12),
P(2,-1,4,4),
P(-4,-12,-2,7),
P(-8,-5,-7,-10),
P(4,11,9,12),
P(0,-8,1,-13),
P(-13,-2,-8,2),
P(-3,-2,-2,3),
P(-6,9,-4,-9),
P(8,12,10,7),
P(0,9,1,3),
P(7,-5,11,-10),
P(-13,-6,-11,0),
P(10,7,12,1),
P(-6,-3,-6,12),
P(10,-9,12,-4),
P(-13,8,-8,-12),
P(-13,0,-8,-4),
P(3,3,7,8),
P(5,7,10,-7),
P(-1,7,1,-12),
P(3,-10,5,6),
P(2,-4,3,-10),
P(-13,0,-13,5),
P(-13,-7,-12,12),
P(-13,3,-11,8),
P(-7,12,-4,7),
P(6,-10,12,8),
P(-9,-1,-7,-6),
P(-2,-5,0,12),
P(-12,5,-7,5),
P(3,-10,8,-13),
P(-7,-7,-4,5),
P(-3,-2,-1,-7),
P(2,9,5,-11),
P(-11,-13,-5,-13),
P(-1,6,0,-1),
P(5,-3,5,2),
P(-4,-13,-4,12),
P(-9,-6,-9,6),
P(-12,-10,-8,-4),
P(10,2,12,-3),
P(7,12,12,12),
P(-7,-13,-6,5),
P(-4,9,-3,4),
P(7,-1,12,2),
P(-7,6,-5,1),
P(-13,11,-12,5),
P(-3,7,-2,-6),
P(7,-8,12,-7),
P(-13,-7,-11,-12),
P(1,-3,12,12),
P(2,-6,3,0),
P(-4,3,-2,-13),
P(-1,-13,1,9),
P(7,1,8,-6),
P(1,-1,3,12),
P(9,1,12,6),
P(-1,-9,-1,3),
P(-13,-13,-10,5),
P(7,7,10,12),
P(12,-5,12,9),
P(6,3,7,11),
P(5,-13,6,10),
P(2,-12,2,3),
P(3,8,4,-6),
P(2,6,12,-13),
P(9,-12,10,3),
P(-8,4,-7,9),
P(-11,12,-4,-6),
P(1,12,2,-8),
P(6,-9,7,-4),
P(2,3,3,-2),
P(6,3,11,0),
P(3,-3,8,-8),
P(7,8,9,3),
P(-11,-5,-6,-4),
P(-10,11,-5,10),
P(-5,-8,-3,12),
P(-10,5,-9,0),
P(8,-1,12,-6),
P(4,-6,6,-11),
P(-10,12,-8,7),
P(4,-2,6,7),
P(-2,0,-2,12),
P(-5,-8,-5,2),
P(7,-6,10,12),
P(-9,-13,-8,-8),
P(-5,-13,-5,-2),
P(8,-8,9,-13),
P(-9,-11,-9,0),
P(1,-8,1,-2),
P(7,-4,9,1),
P(-2,1,-1,-4),
P(11,-6,12,-11),
P(-12,-9,-6,4),
P(3,7,7,12),
P(5,5,10,8),
P(0,-4,2,8),
P(-9,12,-5,-13),
P(0,7,2,12),
P(-1,2,1,7),
P(5,11,7,-9),
P(3,5,6,-8),
P(-13,-4,-8,9),
P(-5,9,-3,-3),
P(-4,-7,-3,-12),
P(6,5,8,0),
P(-7,6,-6,12),
P(-13,6,-5,-2),
P(1,-10,3,10),
P(4,1,8,-4),
P(-2,-2,2,-13),
P(2,-12,12,12),
P(-2,-13,0,-6),
P(4,1,9,3),
P(-6,-10,-3,-5),
P(-3,-13,-1,1),
P(7,5,12,-11),
P(4,-2,5,-7),
P(-13,9,-9,-5),
P(7,1,8,6),
P(7,-8,7,6),
P(-7,-4,-7,1),
P(-8,11,-7,-8),
P(-13,6,-12,-8),
P(2,4,3,9),
P(10,-5,12,3),
P(-6,-5,-6,7),
P(8,-3,9,-8),
P(2,-12,2,8),
P(-11,-2,-10,3),
P(-12,-13,-7,-9),
P(-11,0,-10,-5),
P(5,-3,11,8),
P(-2,-13,-1,12),
P(-1,-8,0,9),
P(-13,-11,-12,-5),
P(-10,-2,-10,11),
P(-3,9,-2,-13),
P(2,-3,3,2),
P(-9,-13,-4,0),
P(-4,6,-3,-10),
P(-4,12,-2,-7),
P(-6,-11,-4,9),
P(6,-3,6,11),
P(-13,11,-5,5),
P(11,11,12,6),
P(7,-5,12,-2),
P(-1,12,0,7),
P(-4,-8,-3,-2),
P(-7,1,-6,7),
P(-13,-12,-8,-13),
P(-7,-2,-6,-8),
P(-8,5,-6,-9),
P(-5,-1,-4,5),
P(-13,7,-8,10),
P(1,5,5,-13),
P(1,0,10,-13),
P(9,12,10,-1),
P(5,-8,10,-9),
P(-1,11,1,-13),
P(-9,-3,-6,2),
P(-1,-10,1,12),
P(-13,1,-8,-10),
P(8,-11,10,-6),
P(2,-13,3,-6),
P(7,-13,12,-9),
P(-10,-10,-5,-7),
P(-10,-8,-8,-13),
P(4,-6,8,5),
P(3,12,8,-13),
P(-4,2,-3,-3),
P(5,-13,10,-12),
P(4,-13,5,-1),
P(-9,9,-4,3),
P(0,3,3,-9),
P(-12,1,-6,1),
P(3,2,4,-8),
P(-10,-10,-10,9),
P(8,-13,12,12),
P(-8,-12,-6,-5),
P(2,2,3,7),
P(10,6,11,-8),
P(6,8,8,-12),
P(-7,10,-6,5),
P(-3,-9,-3,9),
P(-1,-13,-1,5),
P(-3,-7,-3,4),
P(-8,-2,-8,3),
P(4,2,12,12),
P(2,-5,3,11),
P(6,-9,11,-13),
P(3,-1,7,12),
P(11,-1,12,4),
P(-3,0,-3,6),
P(4,-11,4,12),
P(2,-4,2,1),
P(-10,-6,-8,1),
P(-13,7,-11,1),
P(-13,12,-11,-13),
P(6,0,11,-13),
P(0,-1,1,4),
P(-13,3,-9,-2),
P(-9,8,-6,-3),
P(-13,-6,-8,-2),
P(5,-9,8,10),
P(2,7,3,-9),
P(-1,-6,-1,-1),
P(9,5,11,-2),
P(11,-3,12,-8),
P(3,0,3,5),
P(-1,4,0,10),
P(3,-6,4,5),
P(-13,0,-10,5),
P(5,8,12,11),
P(8,9,9,-6),
P(7,-4,8,-12),
P(-10,4,-10,9),
P(7,3,12,4),
P(9,-7,10,-2),
P(7,0,12,-2),
P(-1,-6,0,-11)
);
void getPair(int index, mat2 rot, out vec2 p, out vec2 q)
{
ivec4 data = pat31[index];
vec2 op = vec2(data.xy);
vec2 oq = vec2(data.zw);
p = rot * op;
q = rot * oq;
}
void main()
{
vec4 pixel = threadPixel(encodedCorners);
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;
color = pixel;
if(descriptorCell < 0)
return;
Keypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);
if(isBadKeypoint(keypoint))
return;
float degreesOrientation = round(360.0f + degrees(keypoint.orientation));
float orientation = radians(degreesOrientation - mod(degreesOrientation, 12.0f));
float kcos = cos(orientation);
float ksin = sin(orientation);
mat2 rot = mat2(kcos, ksin, -ksin, kcos);
float pot = exp2(keypoint.lod);
int patternStart = 32 * descriptorCell;
uint test[4] = uint[4](0u, 0u, 0u, 0u);
for(int t = 0; t < 4; t++) {
uint bits = 0u;
vec2 p, q;
vec4 a, b;
int i = t * 8;
@unroll
for(int j = 0; j < 8; j++) {
getPair(patternStart + i + j, rot, p, q);
a = texelFetch(image, ivec2(round(keypoint.position + pot * p)), 0);
b = texelFetch(image, ivec2(round(keypoint.position + pot * q)), 0);
bits |= uint(a.g < b.g) << j;
}
test[t] = bits;
}
color = vec4(test[0], test[1], test[2], test[3]) / 255.0f;
}`},7137:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D image;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#define P(x,y) ivec2((x),(y))
const int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);
const ivec2 diskPoint[708] = ivec2[708](
P(0,-1),P(-1,0),P(1,0),P(0,1),
P(-1,-1),P(1,-1),P(-1,1),P(1,1),P(0,-2),P(-2,0),P(2,0),P(0,2),
P(-1,-2),P(1,-2),P(-2,-1),P(2,-1),P(-2,1),P(2,1),P(-1,2),P(1,2),P(-2,-2),P(2,-2),P(-2,2),P(2,2),P(0,-3),P(-3,0),P(3,0),P(0,3),
P(-1,-3),P(1,-3),P(-3,-1),P(3,-1),P(-3,1),P(3,1),P(-1,3),P(1,3),P(-2,-3),P(2,-3),P(-3,-2),P(3,-2),P(-3,2),P(3,2),P(-2,3),P(2,3),P(0,-4),P(-4,0),P(4,0),P(0,4),
P(-1,-4),P(1,-4),P(-4,-1),P(4,-1),P(-4,1),P(4,1),P(-1,4),P(1,4),P(-3,-3),P(3,-3),P(-3,3),P(3,3),P(-2,-4),P(2,-4),P(-4,-2),P(4,-2),P(-4,2),P(4,2),P(-2,4),P(2,4),P(0,-5),P(-3,-4),P(3,-4),P(-4,-3),P(4,-3),P(-5,0),P(5,0),P(-4,3),P(4,3),P(-3,4),P(3,4),P(0,5),
P(-1,-5),P(1,-5),P(-5,-1),P(5,-1),P(-5,1),P(5,1),P(-1,5),P(1,5),P(-2,-5),P(2,-5),P(-5,-2),P(5,-2),P(-5,2),P(5,2),P(-2,5),P(2,5),P(-4,-4),P(4,-4),P(-4,4),P(4,4),P(-3,-5),P(3,-5),P(-5,-3),P(5,-3),P(-5,3),P(5,3),P(-3,5),P(3,5),P(0,-6),P(-6,0),P(6,0),P(0,6),
P(-1,-6),P(1,-6),P(-6,-1),P(6,-1),P(-6,1),P(6,1),P(-1,6),P(1,6),P(-2,-6),P(2,-6),P(-6,-2),P(6,-2),P(-6,2),P(6,2),P(-2,6),P(2,6),P(-4,-5),P(4,-5),P(-5,-4),P(5,-4),P(-5,4),P(5,4),P(-4,5),P(4,5),P(-3,-6),P(3,-6),P(-6,-3),P(6,-3),P(-6,3),P(6,3),P(-3,6),P(3,6),P(0,-7),P(-7,0),P(7,0),P(0,7),
P(-1,-7),P(1,-7),P(-5,-5),P(5,-5),P(-7,-1),P(7,-1),P(-7,1),P(7,1),P(-5,5),P(5,5),P(-1,7),P(1,7),P(-4,-6),P(4,-6),P(-6,-4),P(6,-4),P(-6,4),P(6,4),P(-4,6),P(4,6),P(-2,-7),P(2,-7),P(-7,-2),P(7,-2),P(-7,2),P(7,2),P(-2,7),P(2,7),P(-3,-7),P(3,-7),P(-7,-3),P(7,-3),P(-7,3),P(7,3),P(-3,7),P(3,7),P(-5,-6),P(5,-6),P(-6,-5),P(6,-5),P(-6,5),P(6,5),P(-5,6),P(5,6),P(0,-8),P(-8,0),P(8,0),P(0,8),
P(-1,-8),P(1,-8),P(-4,-7),P(4,-7),P(-7,-4),P(7,-4),P(-8,-1),P(8,-1),P(-8,1),P(8,1),P(-7,4),P(7,4),P(-4,7),P(4,7),P(-1,8),P(1,8),P(-2,-8),P(2,-8),P(-8,-2),P(8,-2),P(-8,2),P(8,2),P(-2,8),P(2,8),P(-6,-6),P(6,-6),P(-6,6),P(6,6),P(-3,-8),P(3,-8),P(-8,-3),P(8,-3),P(-8,3),P(8,3),P(-3,8),P(3,8),P(-5,-7),P(5,-7),P(-7,-5),P(7,-5),P(-7,5),P(7,5),P(-5,7),P(5,7),P(-4,-8),P(4,-8),P(-8,-4),P(8,-4),P(-8,4),P(8,4),P(-4,8),P(4,8),P(0,-9),P(-9,0),P(9,0),P(0,9),
P(-1,-9),P(1,-9),P(-9,-1),P(9,-1),P(-9,1),P(9,1),P(-1,9),P(1,9),P(-2,-9),P(2,-9),P(-6,-7),P(6,-7),P(-7,-6),P(7,-6),P(-9,-2),P(9,-2),P(-9,2),P(9,2),P(-7,6),P(7,6),P(-6,7),P(6,7),P(-2,9),P(2,9),P(-5,-8),P(5,-8),P(-8,-5),P(8,-5),P(-8,5),P(8,5),P(-5,8),P(5,8),P(-3,-9),P(3,-9),P(-9,-3),P(9,-3),P(-9,3),P(9,3),P(-3,9),P(3,9),P(-4,-9),P(4,-9),P(-9,-4),P(9,-4),P(-9,4),P(9,4),P(-4,9),P(4,9),P(-7,-7),P(7,-7),P(-7,7),P(7,7),P(0,-10),P(-6,-8),P(6,-8),P(-8,-6),P(8,-6),P(-10,0),P(10,0),P(-8,6),P(8,6),P(-6,8),P(6,8),P(0,10),
P(-1,-10),P(1,-10),P(-10,-1),P(10,-1),P(-10,1),P(10,1),P(-1,10),P(1,10),P(-2,-10),P(2,-10),P(-10,-2),P(10,-2),P(-10,2),P(10,2),P(-2,10),P(2,10),P(-5,-9),P(5,-9),P(-9,-5),P(9,-5),P(-9,5),P(9,5),P(-5,9),P(5,9),P(-3,-10),P(3,-10),P(-10,-3),P(10,-3),P(-10,3),P(10,3),P(-3,10),P(3,10),P(-7,-8),P(7,-8),P(-8,-7),P(8,-7),P(-8,7),P(8,7),P(-7,8),P(7,8),P(-4,-10),P(4,-10),P(-10,-4),P(10,-4),P(-10,4),P(10,4),P(-4,10),P(4,10),P(-6,-9),P(6,-9),P(-9,-6),P(9,-6),P(-9,6),P(9,6),P(-6,9),P(6,9),P(0,-11),P(-11,0),P(11,0),P(0,11),
P(-1,-11),P(1,-11),P(-11,-1),P(11,-1),P(-11,1),P(11,1),P(-1,11),P(1,11),P(-2,-11),P(2,-11),P(-5,-10),P(5,-10),P(-10,-5),P(10,-5),P(-11,-2),P(11,-2),P(-11,2),P(11,2),P(-10,5),P(10,5),P(-5,10),P(5,10),P(-2,11),P(2,11),P(-8,-8),P(8,-8),P(-8,8),P(8,8),P(-3,-11),P(3,-11),P(-7,-9),P(7,-9),P(-9,-7),P(9,-7),P(-11,-3),P(11,-3),P(-11,3),P(11,3),P(-9,7),P(9,7),P(-7,9),P(7,9),P(-3,11),P(3,11),P(-6,-10),P(6,-10),P(-10,-6),P(10,-6),P(-10,6),P(10,6),P(-6,10),P(6,10),P(-4,-11),P(4,-11),P(-11,-4),P(11,-4),P(-11,4),P(11,4),P(-4,11),P(4,11),P(0,-12),P(-12,0),P(12,0),P(0,12),
P(-1,-12),P(1,-12),P(-8,-9),P(8,-9),P(-9,-8),P(9,-8),P(-12,-1),P(12,-1),P(-12,1),P(12,1),P(-9,8),P(9,8),P(-8,9),P(8,9),P(-1,12),P(1,12),P(-5,-11),P(5,-11),P(-11,-5),P(11,-5),P(-11,5),P(11,5),P(-5,11),P(5,11),P(-2,-12),P(2,-12),P(-12,-2),P(12,-2),P(-12,2),P(12,2),P(-2,12),P(2,12),P(-7,-10),P(7,-10),P(-10,-7),P(10,-7),P(-10,7),P(10,7),P(-7,10),P(7,10),P(-3,-12),P(3,-12),P(-12,-3),P(12,-3),P(-12,3),P(12,3),P(-3,12),P(3,12),P(-6,-11),P(6,-11),P(-11,-6),P(11,-6),P(-11,6),P(11,6),P(-6,11),P(6,11),P(-4,-12),P(4,-12),P(-12,-4),P(12,-4),P(-12,4),P(12,4),P(-4,12),P(4,12),P(-9,-9),P(9,-9),P(-9,9),P(9,9),P(-8,-10),P(8,-10),P(-10,-8),P(10,-8),P(-10,8),P(10,8),P(-8,10),P(8,10),P(0,-13),P(-5,-12),P(5,-12),P(-12,-5),P(12,-5),P(-13,0),P(13,0),P(-12,5),P(12,5),P(-5,12),P(5,12),P(0,13),
P(-1,-13),P(1,-13),P(-7,-11),P(7,-11),P(-11,-7),P(11,-7),P(-13,-1),P(13,-1),P(-13,1),P(13,1),P(-11,7),P(11,7),P(-7,11),P(7,11),P(-1,13),P(1,13),P(-2,-13),P(2,-13),P(-13,-2),P(13,-2),P(-13,2),P(13,2),P(-2,13),P(2,13),P(-3,-13),P(3,-13),P(-13,-3),P(13,-3),P(-13,3),P(13,3),P(-3,13),P(3,13),P(-6,-12),P(6,-12),P(-12,-6),P(12,-6),P(-12,6),P(12,6),P(-6,12),P(6,12),P(-9,-10),P(9,-10),P(-10,-9),P(10,-9),P(-10,9),P(10,9),P(-9,10),P(9,10),P(-4,-13),P(4,-13),P(-8,-11),P(8,-11),P(-11,-8),P(11,-8),P(-13,-4),P(13,-4),P(-13,4),P(13,4),P(-11,8),P(11,8),P(-8,11),P(8,11),P(-4,13),P(4,13),P(-7,-12),P(7,-12),P(-12,-7),P(12,-7),P(-12,7),P(12,7),P(-7,12),P(7,12),P(-5,-13),P(5,-13),P(-13,-5),P(13,-5),P(-13,5),P(13,5),P(-5,13),P(5,13),P(0,-14),P(-14,0),P(14,0),P(0,14),
P(-1,-14),P(1,-14),P(-14,-1),P(14,-1),P(-14,1),P(14,1),P(-1,14),P(1,14),P(-2,-14),P(2,-14),P(-10,-10),P(10,-10),P(-14,-2),P(14,-2),P(-14,2),P(14,2),P(-10,10),P(10,10),P(-2,14),P(2,14),P(-9,-11),P(9,-11),P(-11,-9),P(11,-9),P(-11,9),P(11,9),P(-9,11),P(9,11),P(-3,-14),P(3,-14),P(-6,-13),P(6,-13),P(-13,-6),P(13,-6),P(-14,-3),P(14,-3),P(-14,3),P(14,3),P(-13,6),P(13,6),P(-6,13),P(6,13),P(-3,14),P(3,14),P(-8,-12),P(8,-12),P(-12,-8),P(12,-8),P(-12,8),P(12,8),P(-8,12),P(8,12),P(-4,-14),P(4,-14),P(-14,-4),P(14,-4),P(-14,4),P(14,4),P(-4,14),P(4,14),P(-7,-13),P(7,-13),P(-13,-7),P(13,-7),P(-13,7),P(13,7),P(-7,13),P(7,13),P(-5,-14),P(5,-14),P(-10,-11),P(10,-11),P(-11,-10),P(11,-10),P(-14,-5),P(14,-5),P(-14,5),P(14,5),P(-11,10),P(11,10),P(-10,11),P(10,11),P(-5,14),P(5,14),P(0,-15),P(-9,-12),P(9,-12),P(-12,-9),P(12,-9),P(-15,0),P(15,0),P(-12,9),P(12,9),P(-9,12),P(9,12),P(0,15)
);
const int DEFAULT_PATCH_RADIUS = 15;
const int MIN_PATCH_RADIUS = 2;
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
int keypointIndex = thread.x + thread.y * outputSize().x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
vec2 m = vec2(0.0f);
float pot = exp2(keypoint.lod);
vec2 imageSize = vec2(textureSize(image, 0));
int scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));
int radius = max(scaledRadius, MIN_PATCH_RADIUS);
int count = diskPointCount[radius];
for(int j = 0; j < count; j++) {
vec2 offset = vec2(diskPoint[j]);
vec2 position = keypoint.position + round(pot * offset);
vec4 patchPixel = texture(image, (position + vec2(0.5f)) / imageSize);
m += offset * patchPixel.g;
}
float angle = fastAtan2(m.y, m.x);
float encodedOrientation = encodeKeypointOrientation(angle);
color = vec4(0.0f, encodedOrientation, 0.0f, 0.0f);
}`},9739:r=>{r.exports=`@include "keypoints.glsl"
@include "filters.glsl"
#if !defined(METHOD)
#error Undefined METHOD
#endif
uniform sampler2D pyramid;
uniform float lodStep;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#if METHOD == 1
uniform int threshold;
#endif
const float eps = 1e-6;
float cornerStrength(vec2 position, float lod)
{
#if METHOD == 0
return laplacian(pyramid, position, lod);
#elif METHOD == 1
float pot = exp2(lod);
float t = float(clamp(threshold, 0, 255)) / 255.0f;
#define P(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g
mat4 mp = mat4(
P(0,3),P(3,0),P(0,-3),P(-3,0),
P(1,3),P(2,2),P(3,1),P(3,-1),
P(2,-2),P(1,-3),P(-1,-3),P(-2,-2),
P(-3,-1),P(-3,1),P(-2,2),P(-1,3)
);
float c = P(0,0);
float ct = c + t, c_t = c - t;
mat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);
mat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;
const vec4 zeros = vec4(0.0f), ones = vec4(1.0f);
vec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);
bs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);
bs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);
bs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);
return max(dot(bs, ones), dot(ds, ones)) / 16.0f;
#else
#error Invalid method
#endif
}
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
color = pixel;
if(address.offset != 1)
return;
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
if(isBadKeypoint(keypoint))
return;
vec3 strength = vec3(
cornerStrength(keypoint.position, max(0.0f, keypoint.lod - lodStep)),
cornerStrength(keypoint.position, keypoint.lod),
cornerStrength(keypoint.position, keypoint.lod + lodStep)
);
vec3 p = mat3(
2, -3, 1,
-4, 4, 0,
2, -1, 0
) * strength;
float maxStrength = max(strength.x, max(strength.y, strength.z));
vec3 diffStrength = abs(strength - vec3(maxStrength));
vec3 strengthIndicators = vec3(lessThan(diffStrength, vec3(eps)));
float maxPoint = min(1.0f, dot(vec3(0.0f, 0.5f, 1.0f), strengthIndicators));
bool hasMax = p.x < -eps;
float pmax = hasMax ? -0.5f * p.y / p.x : maxPoint;
float alpha = abs(pmax - 0.5f) <= 0.5f ? pmax : maxPoint;
float lodOffset = mix(-lodStep, lodStep, alpha);
float lod = keypoint.lod + lodOffset;
color.r = encodeLod(lod);
}`},8231:r=>{r.exports=`@include "float16.glsl"
uniform sampler2D corners;
uniform int iterationNumber;
void main()
{
ivec2 thread = threadLocation();
ivec2 bounds = outputSize();
int jump = (1 << iterationNumber);
int clusterLength = jump << 1;
int clusterMask = clusterLength - 1;
ivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);
ivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);
ivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);
ivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);
vec4 p0 = threadPixel(corners);
vec4 p1 = texelFetch(corners, next1 % bounds, 0);
vec4 p2 = texelFetch(corners, next2 % bounds, 0);
vec4 p3 = texelFetch(corners, next3 % bounds, 0);
float s0 = decodeFloat16(p0.rb);
float s1 = decodeFloat16(p1.rb);
float s2 = decodeFloat16(p2.rb);
float s3 = decodeFloat16(p3.rb);
bool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;
bool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;
bool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;
color = vec4(0.0f);
color.rb = b0 ? p0.rb : (
b1 ? p1.rb : (
b2 ? p2.rb : p3.rb
)
);
}`},2518:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#if PERMUTATION_MAXLEN % 4 > 0 || PERMUTATION_MAXLEN * 4 > 16384
#error Invalid PERMUTATION_MAXLEN
#endif
layout(std140) uniform Permutation
{
ivec4 permutation[PERMUTATION_MAXLEN / 4];
};
int permutationElement(int index)
{
int base = index - (index % PERMUTATION_MAXLEN);
int offset = index - base;
ivec4 tuple = permutation[offset / 4];
int newOffset = tuple[offset & 3];
return base + newOffset;
}
void main()
{
ivec2 thread = threadLocation();
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
int otherIndex = permutationElement(myIndex);
KeypointAddress otherAddress = KeypointAddress(otherIndex * pixelsPerKeypoint, myAddress.offset);
Keypoint myKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);
Keypoint otherKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, otherAddress);
color = readKeypointData(encodedKeypoints, encoderLength, otherAddress);
}`},8096:r=>{r.exports=`@include "keypoints.glsl"
#if !defined(STAGE)
#error Undefined STAGE
#elif STAGE == 1
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#elif STAGE == 2
uniform sampler2D permutation;
uniform int blockSize;
uniform int dblLog2BlockSize;
#elif STAGE == 3
uniform sampler2D permutation;
uniform int maxKeypoints;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
#else
#error Invalid STAGE
#endif
struct PermutationElement
{
int keypointIndex;
float score;
bool valid;
};
vec4 encodePermutationElement(PermutationElement element)
{
const vec2 ONES = vec2(1.0f);
vec2 encodedScore = element.valid ? encodeFloat16(element.score) : ONES;
vec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;
return vec4(encodedIndex, encodedScore);
}
PermutationElement decodePermutationElement(vec4 pixel)
{
const vec2 ONES = vec2(1.0f);
PermutationElement element;
element.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);
element.valid = !all(equal(pixel.ba, ONES));
element.score = element.valid ? decodeFloat16(pixel.ba) : -1.0f;
return element;
}
PermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)
{
const vec4 INVALID_PIXEL = vec4(1.0f);
ivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);
vec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;
return decodePermutationElement(pixel);
}
#if STAGE == 2
PermutationElement selectKth(sampler2D permutation, int k, int la, int ra, int lb, int rb)
{
float scoreA, scoreB;
int ha, hb, ma, mb;
bool discard1stHalf, altb;
bool locked = false;
int tmp, result = 0;
int stride = outputSize().x;
int height = outputSize().y;
for(int i = 0; i < dblLog2BlockSize; i++) {
tmp = (lb > rb && !locked) ? (la+k) : result;
result = (la > ra && !locked) ? (lb+k) : tmp;
locked = locked || (la > ra) || (lb > rb);
ha = (ra - la + 1) / 2;
hb = (rb - lb + 1) / 2;
ma = la + ha;
mb = lb + hb;
scoreA = readPermutationElement(permutation, ma, stride, height).score;
scoreB = readPermutationElement(permutation, mb, stride, height).score;
discard1stHalf = (k > ha + hb);
altb = (-scoreA < -scoreB);
k -= int(discard1stHalf && altb) * (ha + 1);
k -= int(discard1stHalf && !altb) * (hb + 1);
la += int(discard1stHalf && altb) * (ma + 1 - la);
lb += int(discard1stHalf && !altb) * (mb + 1 - lb);
ra += int(!discard1stHalf && !altb) * (ma - 1 - ra);
rb += int(!discard1stHalf && altb) * (mb - 1 - rb);
}
return readPermutationElement(permutation, result, stride, height);
}
#endif
void main()
{
#if STAGE == 1
ivec2 thread = threadLocation();
int stride = outputSize().x;
int keypointIndex = thread.y * stride + thread.x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
PermutationElement element;
element.keypointIndex = keypointIndex;
element.score = keypoint.score;
element.valid = !isBadKeypoint(keypoint);
color = encodePermutationElement(element);
#elif STAGE == 2
ivec2 thread = threadLocation();
int stride = outputSize().x;
int elementIndex = thread.y * stride + thread.x;
int blockIndex = elementIndex / blockSize;
int blockOffset = elementIndex % blockSize;
int la = blockIndex * blockSize;
int lb = la + blockSize / 2;
int ra = lb - 1;
int rb = (blockIndex + 1) * blockSize - 1;
int k = blockOffset;
PermutationElement element = selectKth(permutation, k, la, ra, lb, rb);
color = encodePermutationElement(element);
#elif STAGE == 3
ivec2 thread = threadLocation();
int newEncoderLength = outputSize().x;
KeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);
int myKeypointIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
ivec2 psize = textureSize(permutation, 0);
PermutationElement element = readPermutationElement(permutation, myKeypointIndex, psize.x, psize.y);
int oldEncoderLength = textureSize(encodedKeypoints, 0).x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(element.keypointIndex * pixelsPerKeypoint, myAddress.offset);
vec4 keypointData = readKeypointData(encodedKeypoints, oldEncoderLength, address);
color = myKeypointIndex < maxKeypoints && element.valid ? keypointData : encodeNullKeypoint();
#endif
}`},5795:r=>{r.exports=`@include "keypoints.glsl"
@include "float16.glsl"
#if !defined(METHOD)
#error Must define METHOD
#endif
uniform sampler2D pyramid;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int maxIterations;
uniform float epsilon;
const int PATCH_RADIUS = 1;
const int PATCH_SIZE = 2 * PATCH_RADIUS + 1;
const int PATCH_SIZE_SQUARED = PATCH_SIZE * PATCH_SIZE;
const int LARGE_PATCH_RADIUS = PATCH_RADIUS + 1;
const int LARGE_PATCH_SIZE = 2 * LARGE_PATCH_RADIUS + 1;
const int LARGE_PATCH_SIZE_SQUARED = LARGE_PATCH_SIZE * LARGE_PATCH_SIZE;
const int LARGER_PATCH_RADIUS = LARGE_PATCH_RADIUS + 1;
const int LARGER_PATCH_SIZE = 2 * LARGER_PATCH_RADIUS + 1;
const int LARGER_PATCH_SIZE_SQUARED = LARGER_PATCH_SIZE * LARGER_PATCH_SIZE;
const float EPS = 1e-5;
float smoothPixelBuffer[LARGER_PATCH_SIZE_SQUARED];
vec2 derivativesBuffer[LARGE_PATCH_SIZE_SQUARED];
float responseBuffer[PATCH_SIZE_SQUARED];
#define patchPixelAt(u,v) smoothPixelBuffer[((v) + LARGER_PATCH_RADIUS) * LARGER_PATCH_SIZE + ((u) + LARGER_PATCH_RADIUS)]
#define derivativesAt(u,v) derivativesBuffer[((v) + LARGE_PATCH_RADIUS) * LARGE_PATCH_SIZE + ((u) + LARGE_PATCH_RADIUS)]
#define responseAt(u,v) responseBuffer[((v) + PATCH_RADIUS) * PATCH_SIZE + ((u) + PATCH_RADIUS)]
void readPixels(vec2 center, float lod)
{
ivec2 pyrBaseSize = textureSize(pyramid, 0);
float pot = exp2(lod);
int u, v;
for(int j = 0; j < LARGER_PATCH_SIZE; j++) {
for(int i = 0; i < LARGER_PATCH_SIZE; i++) {
u = i - LARGER_PATCH_RADIUS;
v = j - LARGER_PATCH_RADIUS;
patchPixelAt(u,v) = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2(u,v), pyrBaseSize).g;
}
}
}
void computeDerivatives()
{
const mat3 dx = mat3(
-1, 0, 1,
-2, 0, 2,
-1, 0, 1
);
const mat3 dy = mat3(
1, 2, 1,
0, 0, 0,
-1,-2,-1
);
int u, v;
mat3 pix, convX, convY;
const vec3 ones = vec3(1.0f);
for(int j = 0; j < LARGE_PATCH_SIZE; j++) {
for(int i = 0; i < LARGE_PATCH_SIZE; i++) {
u = i - LARGE_PATCH_RADIUS;
v = j - LARGE_PATCH_RADIUS;
pix = mat3(
patchPixelAt(u+1,v+1), patchPixelAt(u+0,v+1), patchPixelAt(u-1,v+1),
patchPixelAt(u+1,v+0), patchPixelAt(u+0,v+0), patchPixelAt(u-1,v+0),
patchPixelAt(u+1,v-1), patchPixelAt(u+0,v-1), patchPixelAt(u-1,v-1)
);
convX = matrixCompMult(dx, pix);
convY = matrixCompMult(dy, pix);
derivativesAt(u,v) = vec2(
dot(ones, vec3(
dot(convX[0], ones),
dot(convX[1], ones),
dot(convX[2], ones)
)),
dot(ones, vec3(
dot(convY[0], ones),
dot(convY[1], ones),
dot(convY[2], ones)
))
);
}
}
}
vec2 computeResponseMap()
{
float patchArea = float(PATCH_SIZE * PATCH_SIZE);
vec3 h; vec2 d, c = vec2(0.0f);
const vec3 ones = vec3(1.0f);
float response, sum = 0.0f;
int u, v;
#define H(r,s) d = derivativesAt((r),(s)); h += vec3(d.x * d.x, d.x * d.y, d.y * d.y)
for(int j = 0; j < PATCH_SIZE; j++) {
for(int i = 0; i < PATCH_SIZE; i++) {
u = i - PATCH_RADIUS;
v = j - PATCH_RADIUS;
h = vec3(0.0f);
H(u-1,v-1); H(u+0,v-1); H(u+1,v-1);
H(u-1,v+0); H(u+0,v+0); H(u+1,v+0);
H(u-1,v+1); H(u+0,v+1); H(u+1,v+1);
response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));
response /= patchArea;
responseAt(u,v) = response;
c += vec2(u,v) * response;
sum += response;
}
}
return abs(sum) > EPS ? c / sum : vec2(0.0f);
}
#if METHOD == 0
vec2 quadratic1d()
{
float a = 0.5f * (responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0));
float b = 0.5f * (responseAt(1,0) - responseAt(-1,0));
float c = responseAt(0,0);
float d = 0.5f * (responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1));
float e = 0.5f * (responseAt(0,1) - responseAt(0,-1));
float f = responseAt(0,0);
bool hasMax = a < -EPS && d < -EPS;
return hasMax ? -0.5f * vec2(b / a, e / d) : vec2(0.0f);
}
#endif
#if METHOD == 1
vec2 taylor2d()
{
float dx = (-responseAt(-1,0) + responseAt(1,0)) * 0.5f;
float dy = (-responseAt(0,-1) + responseAt(0,1)) * 0.5f;
float dxx = responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0);
float dyy = responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1);
float dxy = (responseAt(-1,-1) + responseAt(1,1) - responseAt(1,-1) - responseAt(-1,1)) * 0.25f;
float det = dxx * dyy - dxy * dxy;
mat2 inv = mat2(dyy, -dxy, -dxy, dxx);
bool hasMax = det > EPS && dxx < 0.0f;
return hasMax ? inv * vec2(dx, dy) / (-det) : vec2(0.0f);
}
#endif
#if METHOD == 2
void bilinearUpsample(ivec2 patchOffset, vec4 pixelsOfPatch)
{
int u, v, i, j;
vec2 frc, ifrc; vec4 sub;
const vec4 ones = vec4(1.0f);
float s = 1.0f / float(PATCH_SIZE - 1);
int xoff = 2 * patchOffset.x;
int yoff = 2 * patchOffset.y;
for(j = 0; j < PATCH_SIZE; j++) {
for(i = 0; i < PATCH_SIZE; i++) {
u = i - PATCH_RADIUS;
v = j - PATCH_RADIUS;
frc = vec2(i, j) * s;
ifrc = vec2(1.0f) - frc;
sub = vec4(
ifrc.x * ifrc.y,
frc.x * ifrc.y,
ifrc.x * frc.y,
frc.x * frc.y
);
patchPixelAt(u+xoff,v+yoff) = dot(sub*pixelsOfPatch, ones);
}
}
}
#endif
#if METHOD == 3
void bicubicUpsample(ivec2 patchOffset, vec4 pixelsOfPatch, vec4 dx, vec4 dy, vec4 dxy)
{
float x, y, s = 1.0f / float(PATCH_SIZE - 1);
int u, v, i, j;
float f00 = pixelsOfPatch.x;
float f10 = pixelsOfPatch.y;
float f01 = pixelsOfPatch.z;
float f11 = pixelsOfPatch.w;
float fx00 = dx.x;
float fx10 = dx.y;
float fx01 = dx.z;
float fx11 = dx.w;
float fy00 = dy.x;
float fy10 = dy.y;
float fy01 = dy.z;
float fy11 = dy.w;
float fxy00 = dxy.x;
float fxy10 = dxy.y;
float fxy01 = dxy.z;
float fxy11 = dxy.w;
mat4 bicubic = mat4(
1, 0, -3, 2,
0, 0, 3, -2,
0, 1, -2, 1,
0, 0, -1, 1
) * mat4(
f00, f10, fx00, fx10,
f01, f11, fx01, fx11,
fy00, fy10, fxy00, fxy10,
fy01, fy11, fxy01, fxy11
) * mat4(
1, 0, 0, 0,
0, 0, 1, 0,
-3, 3, -2, -1,
2, -2, 1, 1
);
int xoff = 2 * patchOffset.x;
int yoff = 2 * patchOffset.y;
for(j = 0; j < PATCH_SIZE; j++) {
for(i = 0; i < PATCH_SIZE; i++) {
u = i - PATCH_RADIUS;
v = j - PATCH_RADIUS;
x = float(i) * s;
y = float(j) * s;
patchPixelAt(u+xoff,v+yoff) = dot(
vec4(1, x, x*x, x*x*x),
bicubic * vec4(1, y, y*y, y*y*y)
);
}
}
}
#endif
#if METHOD == 2 || METHOD == 3
void upsamplePatch(int left, int top, int right, int bottom)
{
int x, y, k;
vec4 ptch[9];
vec2 d00, d10, d01, d11;
for(k = 0; k < 9; k++) {
x = -1 + (k % 3);
y = -1 + (k / 3);
ptch[k] = vec4(
patchPixelAt(left+x, top+y),
patchPixelAt(right+x, top+y),
patchPixelAt(left+x, bottom+y),
patchPixelAt(right+x, bottom+y)
);
}
for(k = 0; k < 9; k++) {
x = -1 + (k % 3);
y = -1 + (k / 3);
#if METHOD == 2
bilinearUpsample(ivec2(x, y), ptch[k]);
#elif METHOD == 3
d00 = derivativesAt(left+x, top+y);
d10 = derivativesAt(right+x, top+y);
d01 = derivativesAt(left+x, bottom+y);
d11 = derivativesAt(right+x, bottom+y);
bicubicUpsample(ivec2(x, y), ptch[k],
vec4(d00.x, d10.x, d01.x, d11.x),
vec4(d00.y, d10.y, d01.y, d11.y),
0.25f * vec4(
(patchPixelAt(left+x + 1,top+y + 1) + patchPixelAt(left+x - 1, top+y - 1)) - (patchPixelAt(left+x + 1, top+y - 1) + patchPixelAt(left+x - 1, top+y + 1)),
(patchPixelAt(right+x + 1,top+y + 1) + patchPixelAt(right+x - 1, top+y - 1)) - (patchPixelAt(right+x + 1, top+y - 1) + patchPixelAt(right+x - 1, top+y + 1)),
(patchPixelAt(left+x + 1,bottom+y + 1) + patchPixelAt(left+x - 1, bottom+y - 1)) - (patchPixelAt(left+x + 1, bottom+y - 1) + patchPixelAt(left+x - 1, bottom+y + 1)),
(patchPixelAt(right+x + 1,bottom+y + 1) + patchPixelAt(right+x - 1, bottom+y - 1)) - (patchPixelAt(right+x + 1, bottom+y - 1) + patchPixelAt(right+x - 1, bottom+y + 1))
)
);
#endif
}
}
vec2 upsampleResponseMap(int left, int top, int right, int bottom)
{
upsamplePatch(left, top, right, bottom);
computeDerivatives();
return computeResponseMap();
}
vec2 iterativeUpsample(vec2 initialGuess)
{
int refine = 1;
float scale = 0.5f;
float eps2 = epsilon * epsilon;
vec2 guess = initialGuess, localGuess = initialGuess;
for(int k = 0; k < maxIterations; k++) {
ivec4 quad = ivec4(floor(localGuess.x), floor(localGuess.y), ceil(localGuess.x), ceil(localGuess.y));
vec2 response = (refine != 0) ? upsampleResponseMap(quad.x, quad.y, quad.z, quad.w) : vec2(0.0f);
localGuess = response * scale;
guess += localGuess;
scale *= 0.5f;
refine *= int(dot(localGuess, localGuess) >= eps2);
}
return guess;
}
#endif
void main()
{
ivec2 thread = threadLocation();
int keypointIndex = thread.x + thread.y * outputSize().x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
color = encodeNullPairOfFloat16();
if(isNullKeypoint(keypoint))
return;
color = encodeDiscardedPairOfFloat16();
if(isBadKeypoint(keypoint))
return;
readPixels(keypoint.position, keypoint.lod);
computeDerivatives();
vec2 offset = computeResponseMap();
#if METHOD == 0
offset = quadratic1d();
#elif METHOD == 1
offset = taylor2d();
#elif METHOD == 2 || METHOD == 3
offset = iterativeUpsample(offset);
#else
#error Unknown METHOD
#endif
float pot = exp2(keypoint.lod);
color = encodePairOfFloat16(offset * pot);
}`},3169:r=>{r.exports=`@include "keypoints.glsl"
@include "float16.glsl"
uniform sampler2D encodedFlow;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
int len = textureSize(encodedFlow, 0).x;
KeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);
int myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
color = pixel;
if(isBadKeypoint(keypoint))
return;
ivec2 location = ivec2(myIndex % len, myIndex / len);
vec4 encodedFlow = myIndex < len * len ? pixelAt(encodedFlow, location) : encodeDiscardedKeypoint();
bool discardFlow = isDiscardedPairOfFloat16(encodedFlow);
vec2 flow = !discardFlow ? decodePairOfFloat16(encodedFlow) : vec2(0.0f);
vec4 newPosition = encodeKeypointPosition(keypoint.position + flow);
vec4 newPixel = myAddress.offset == 0 ? newPosition : pixel;
color = !discardFlow ? newPixel : encodeDiscardedKeypoint();
}`},1337:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedOrientations;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
KeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
int orientationEncoderLength = textureSize(encodedOrientations, 0).x;
ivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);
vec4 targetPixel = pixelAt(encodedOrientations, location);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);
bool isValid = !isBadKeypoint(keypoint);
float encodedOrientation = targetPixel.g;
color = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.ba) : pixel;
}`},6187:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedData;
uniform int strideOfEncodedData;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
vec4 readEncodedData(sampler2D encodedData, int strideOfEncodedData, int elementId, int pixelsPerElement, int pixelOffset)
{
int rasterIndex = elementId * pixelsPerElement + pixelOffset;
ivec2 pos = ivec2(rasterIndex % strideOfEncodedData, rasterIndex / strideOfEncodedData);
return texelFetch(encodedData, pos, 0);
}
void main()
{
ivec2 thread = threadLocation();
KeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
int headerSize = sizeofEncodedKeypointHeader();
int extraCell = myAddress.offset - headerSize / 4;
int numberOfExtraCells = extraSize / 4;
color = threadPixel(encodedKeypoints);
if(extraCell < 0 || extraCell >= numberOfExtraCells)
return;
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);
if(isBadKeypoint(keypoint))
return;
color = readEncodedData(encodedData, strideOfEncodedData, myIndex, numberOfExtraCells, extraCell);
}`},477:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedKeypoints;
uniform int startIndex;
uniform int endIndex;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#ifndef BUFFER_SIZE
#error Undefined BUFFER_SIZE
#endif
layout(std140) uniform KeypointBuffer
{
vec4 keypointBuffer[BUFFER_SIZE];
};
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
color = pixel;
if(index < startIndex)
return;
color = encodeNullKeypoint();
if(index >= endIndex)
return;
vec4 data = keypointBuffer[index - startIndex];
switch(address.offset) {
case 0: {
color = encodeKeypointPosition(data.xy);
break;
}
case 1: {
vec2 score = encodeKeypointScore(max(data.w, 0.0f));
float scale = encodeLod(data.z);
float rotation = encodeKeypointOrientation(0.0f);
color = vec4(scale, rotation, score);
break;
}
default: {
color = vec4(0.0f);
break;
}
}
}`},4050:r=>{r.exports=`uniform sampler2D image;
void main()
{
#if 1
color = texture(image, texCoord);
#else
ivec2 thread = threadLocation();
ivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));
color = pixelAt(image, pos);
#endif
}`},5545:r=>{r.exports=`uniform sampler2D image;
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = pixelAt(image, thread / 2);
color = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);
}`},7113:r=>{r.exports=`@include "subpixel.glsl"
uniform sampler2D image0;
uniform sampler2D image1;
uniform float alpha;
uniform float beta;
uniform float gamma;
const vec4 BACKGROUND = vec4(0.0f);
void main()
{
ivec2 location = threadLocation();
ivec2 size0 = textureSize(image0, 0);
ivec2 size1 = textureSize(image1, 0);
vec4 pix0 = all(lessThan(location, size0)) ? pixelAt(image0, location) : BACKGROUND;
vec4 pix1 = all(lessThan(location, size1)) ? pixelAt(image1, location) : BACKGROUND;
vec4 pix = clamp(alpha * pix0 + beta * pix1 + vec4(gamma), 0.0f, 1.0f);
color = vec4(pix.rgb, 1.0f);
}`},1202:r=>{r.exports=`@include "subpixel.glsl"
uniform sampler2D image;
void main()
{
vec2 imageSize = vec2(textureSize(image, 0));
#if !defined(INTERPOLATION_METHOD)
#error Must define INTERPOLATION_METHOD
#elif INTERPOLATION_METHOD == 0
vec2 pos = texCoord * imageSize;
color = textureLod(image, (round(pos) + vec2(0.5f)) / imageSize, 0.0f);
#elif INTERPOLATION_METHOD == 1
color = subpixelAtBI(image, texCoord * imageSize);
#else
#error Invalid INTERPOLATION_METHOD
#endif
}`},7971:r=>{r.exports=`@include "subpixel.glsl"
uniform sampler2D image;
uniform mat3 inverseHomography;
const vec4 emptyColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);
vec2 perspectiveWarp(mat3 homography, vec2 p)
{
vec3 q = homography * vec3(p, 1.0f);
return q.xy / q.z;
}
void main()
{
ivec2 location = threadLocation();
ivec2 size = outputSize();
const vec2 zero = vec2(0.0f);
vec2 target = perspectiveWarp(inverseHomography, vec2(location));
bool withinBounds = all(bvec4(greaterThanEqual(target, zero), lessThan(target, vec2(size))));
color = withinBounds ? subpixelAtBI(image, target) : emptyColor;
}`},6122:r=>{r.exports=`@include "colors.glsl"
uniform sampler2D dest, src;
uniform int destComponents;
uniform int srcComponentId;
void main()
{
vec4 destPixel = threadPixel(dest);
vec4 srcPixel = threadPixel(src);
bvec4 flags = bvec4(
(destComponents & PIXELCOMPONENT_RED) != 0,
(destComponents & PIXELCOMPONENT_GREEN) != 0,
(destComponents & PIXELCOMPONENT_BLUE) != 0,
(destComponents & PIXELCOMPONENT_ALPHA) != 0
);
color = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);
}`},371:r=>{r.exports=`#if !defined(TYPE)
#error Undefined TYPE
#elif TYPE == 1
@include "keypoints.glsl"
#define nullPixel() encodeNullKeypoint()
#elif TYPE == 2
@include "float16.glsl"
#define nullPixel() encodeNullPairOfFloat16()
#else
#error Invalid TYPE
#endif
uniform sampler2D image;
void main()
{
ivec2 thread = threadLocation();
ivec2 imageSize = textureSize(image, 0);
int rasterIndex = thread.y * outputSize().x + thread.x;
bool isValidPixel = rasterIndex < imageSize.x * imageSize.y;
ivec2 pos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);
vec4 nullpix = nullPixel();
color = isValidPixel ? texelFetch(image, pos, 0) : nullpix;
}`},7307:r=>{r.exports=`uniform sampler2D image;
void main()
{
color = threadPixel(image);
}`},8614:r=>{r.exports=`@include "colors.glsl"
uniform sampler2D image;
uniform int pixelComponents;
uniform float value;
void main()
{
vec4 pixel = threadPixel(image);
bvec4 flags = bvec4(
(pixelComponents & PIXELCOMPONENT_RED) != 0,
(pixelComponents & PIXELCOMPONENT_GREEN) != 0,
(pixelComponents & PIXELCOMPONENT_BLUE) != 0,
(pixelComponents & PIXELCOMPONENT_ALPHA) != 0
);
color = mix(pixel, vec4(value), flags);
}`},6271:r=>{r.exports=`uniform float value;
void main()
{
color = vec4(value);
}`},3016:r=>{r.exports=`void vsmain()
{
gl_Position *= vec4(1,-1,1,1);
}`},3630:r=>{r.exports=`uniform sampler2D image;
uniform int iterationNumber;
void main()
{
ivec2 thread = threadLocation();
ivec2 last = outputSize() - ivec2(1);
int jump = (1 << iterationNumber);
int clusterLength = jump << 1;
int clusterMask = clusterLength - 1;
ivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);
ivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);
ivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);
ivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);
vec4 p0 = texelFetch(image, thread, 0);
vec4 p1 = texelFetch(image, min(next1, last), 0);
vec4 p2 = texelFetch(image, min(next2, last), 0);
vec4 p3 = texelFetch(image, min(next3, last), 0);
vec4 pmax = max(max(p0, p1), max(p2, p3));
vec4 pmin = min(min(p0, p1), min(p2, p3));
color = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);
}`},8508:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
uniform sampler2D pyramid;
uniform float lod;
#define USE_VARYINGS 1
in vec2 v_pix0, v_pix1, v_pix2,
v_pix3, v_pix4, v_pix5,
v_pix6, v_pix7, v_pix8;
const mat3 hkern = mat3(
1.0f, 0.0f,-1.0f,
2.0f, 0.0f,-2.0f,
1.0f, 0.0f,-1.0f
), vkern = mat3(
1.0f, 2.0f, 1.0f,
0.0f, 0.0f, 0.0f,
-1.0f,-2.0f,-1.0f
);
#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g
#define XIP(v) textureLod(pyramid, (v), lod).g
void main()
{
const vec3 ones = vec3(1.0f);
float pot = exp2(lod);
mat3 win = mat3(
#if USE_VARYINGS
XIP(v_pix0), XIP(v_pix1), XIP(v_pix2),
XIP(v_pix3), XIP(v_pix4), XIP(v_pix5),
XIP(v_pix6), XIP(v_pix7), XIP(v_pix8)
#else
PIX(-1,-1), PIX(0,-1), PIX(1,-1),
PIX(-1,0), PIX(0,0), PIX(1,0),
PIX(-1,1), PIX(0,1), PIX(1,1)
#endif
);
mat3 dx = matrixCompMult(hkern, win);
mat3 dy = matrixCompMult(vkern, win);
vec2 df = vec2(
dot(dx[0] + dx[1] + dx[2], ones),
dot(dy[0] + dy[1] + dy[2], ones)
);
color = encodePairOfFloat16(df);
}`},8073:r=>{r.exports=`uniform mediump float lod;
out vec2 v_pix0, v_pix1, v_pix2,
v_pix3, v_pix4, v_pix5,
v_pix6, v_pix7, v_pix8;
#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)
void vsmain()
{
float pot = exp2(lod);
v_pix0 = PIX(-1,-1); v_pix1 = PIX(0,-1); v_pix2 = PIX(1,-1);
v_pix3 = PIX(-1,0); v_pix4 = PIX(0,0); v_pix5 = PIX(1,0);
v_pix6 = PIX(-1,1); v_pix7 = PIX(0,1); v_pix8 = PIX(1,1);
}`},3575:r=>{r.exports=`AGFzbQEAAAABiwETYAABfmADf39/AX9gAX8AYAN/f38AYAF9AX9gAX8Bf2ACf38Bf2AFf39/f38B
f2AFf39/f38AYAZ/f39/f38Bf2AAAX9gAn99AX9gA39/fQF/YAJ/fwF9YAF/AX1gBH9/f38AYAR/
f39/AX9gEX98fHx8fHx8fHx8fHx8fHx8AGAHf39/f39/fQF/AjsEA2VudgZtZW1vcnkCAAIDZW52
BWZhdGFsAAIDZW52CGJ5dGVmaWxsAAMDZW52CmNvcHlXaXRoaW4AAwNAPwQFBgIGAQECBwgGAwAJ
AgYCBgYKBQUFCQsFBgEBDAEBBgYGAQEMAQ0OAwgPAxAIAwYBEQEBAQEBARIBEgEBDwQFAXABBQUG
CAF/AUHwmgQLB/QDHAZtYWxsb2MABARmcmVlAAYFc3JhbmQACgxNYXQzMl9jcmVhdGUAEA1NYXQz
Ml9kZXN0cm95ABcKTWF0MzJfZGF0YQAYDk1hdDMyX2RhdGFTaXplABkPTWF0MzJfdHJhbnNwb3Nl
AB0JTWF0MzJfYWRkAB4OTWF0MzJfc3VidHJhY3QAHwtNYXQzMl9zY2FsZQAgDk1hdDMyX2NvbXBt
dWx0ACEOTWF0MzJfbXVsdGlwbHkAIg5NYXQzMl9pbnZlcnNlMQAjDk1hdDMyX2ludmVyc2UyACQO
TWF0MzJfaW52ZXJzZTMAJQ1NYXQzMl9xcl9mdWxsACwQTWF0MzJfcXJfcmVkdWNlZAAvDE1hdDMy
X3FyX29scwAwEE1hdDMyX3FyX2ludmVyc2UAMxZNYXQzMl9ob21vZ3JhcGh5X25kbHQ0ADcVTWF0
MzJfaG9tb2dyYXBoeV9uZGx0ADgUTWF0MzJfYWZmaW5lX2RpcmVjdDMAOhNNYXQzMl9hZmZpbmVf
ZGlyZWN0ADsYTWF0MzJfcHJhbnNhY19ob21vZ3JhcGh5ADwUTWF0MzJfcHJhbnNhY19hZmZpbmUA
PhtNYXQzMl90cmFuc2Zvcm1fcGVyc3BlY3RpdmUAPxZNYXQzMl90cmFuc2Zvcm1fYWZmaW5lAEAJ
CgEAQQELBA8REz0Kh7oBPyMBAX8gALwiAUGAgID8B3FBgICA/AdGIAFB////A3FBAEdxC2kBAX9B
AEEAKALAmoCAAEEBajYCwJqAgABBAEEAKAK0moCAACIBQQdxIAFqIgEgAGo2ArSagIAAAkBB8JqE
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
oZlEje21oPfGsD5jDQAgHCAFoiIYIB8gA6KhIiIgFCAIoiAcIAaiIh6gIiOiIB4gHyAEoqEiHiAU
IAeiIBigIhiioSIkmUSN7bWg98awPmMNACAcmiIlIBShIiYgIqIgHyAcoSIiIBiioUQAAAAAAADw
PyAkoyIkoiEYICIgI6IgJiAeoqEgJKIhHgJAAkAgHSAgZEEBcw0AIBMgGCAEoiAeIAOiRAAAAAAA
APA/oKAiBKIgJaMhHSAcIR8MAQsgEyAYIAaiIB4gBaJEAAAAAAAA8D+goCIEoiAfmqMhHQsgFyAE
oiAfoyETAkACQCAhICWZZEEBcw0AIBogGCAGoiAeIAWiRAAAAAAAAPA/oKAiBKIgFJqjIQcMAQsg
GiAYIAiiIB4gB6JEAAAAAAAA8D+goCIEoiAcoyEHICUhFAsgGCAdmiABoiATIAKioSIXIAeioiAd
IBsgBKIgFKMiFKIgHiATIAeaIAGiIBQgAqKhIhyioqCgIBMgB6KhIBggHSAcoqKhIB4gFyAUoqKh
mUSN7bWg98awPmMNACALIA2hIhsgECAOoSIaoiAWIA8gDaEiH6KhIiCZRI3ttaD3xrA+Yw0AIBEh
BCARIQIgESEGIBEhDiARIQEgESEDIBEhBSARIQggGyAVIBmgIhWiIBYgCSALoSANIA+hoCIZoqFE
AAAAAAAA8D8gIKMiFqIiDSAMIAqhIBogGaIgHyAVoqEgFqIiFiAMoqAiDCAJoqIgCyAJoSAWIAui
oCILIBIgDSAQoqAiEKIgFiAPIAmhIA0gD6KgIg8gCqKioKAgDyAMoqEgDSALIAqioqEgFiAQIAmi
oqGZRI3ttaD3xrA+Yw0BIBYgF6IgDSAcoqBEAAAAAAAA8D+gIQUgGCAWIBOiIA0gFKKgoCEDIB4g
FiAdoiANIAeioKAhASAMIBeiIBAgHKKgIAqgIQ4gGCAKoiAMIBOiIBAgFKKgoCEGIB4gCqIgDCAd
oiAQIAeioKAhAiALIBeiIA8gHKKgIAmgIQQgGCAJoiALIBOiIA8gFKKgoCERIB4gCaIgCyAdoiAP
IAeioKAhCAwBCyARIQQgESECIBEhBiARIQ4gESEBIBEhAyARIQUgESEICyAAKAIAIicgCLY4AgAg
JyAAQRRqKAIAIihBAnRqIBG2OAIAICcgKEEDdGogBLY4AgAgJyAAKAIQIgBBAnRqIAK2OAIAICcg
ACAoaiIpQQJ0aiAGtjgCACAnIAAgKEEBdGpBAnRqIA62OAIAICcgAEEDdGogAbY4AgAgJyAoIABB
AXRqQQJ0aiADtjgCACAnIClBA3RqIAW2OAIAC7oHAhZ/Cn0CQAJAIAAoAghBA0cNACAAKAIMQQNH
DQAgASgCCEECRw0AIAEoAgwiA0EESA0AIAIoAghBAkcNACACKAIMIANGDQELQbKTgIAAEICAgIAA
IAEoAgwhAwsgA0EBdCIEQQgQkoCAgAAhBSAEQQEQkoCAgAAhBkEIQQEQkoCAgAAhBwJAIANBAUgN
ACAFQRRqKAIAIgRBDGwgBSgCECIIQQJ0IglqIQogBEEEdCAJaiELIARBFGwgCWohDCAEQRhsIg0g
CWohDiAEQRxsIg8gCWohECACKAIQQQJ0IREgASgCEEECdCESIAhBA3QhCCAGKAIQIglBA3QhEyAJ
QQJ0IRQgAkEUaigCAEECdCEVIAFBFGooAgBBAnQhFiAEQQN0IRcgBEECdCEYIAYoAgAhCSAFKAIA
IQQgAigCACECIAEoAgAhAQNAIAIgEWoqAgAhGSABIBJqKgIAIRogAioCACEbIAQgASoCACIcOAIA
IAQgGGogGjgCACAEIBdqQYCAgPwDNgIAIAQgCmogHDgCACAEIAtqIBo4AgAgBCAMakGAgID8AzYC
ACAEIA1qIBsgHIwiHJQ4AgAgBCAOaiAZIByUOAIAIAQgD2ogGyAajCIalDgCACAEIBBqIBkgGpQ4
AgAgCSAbOAIAIAkgFGogGTgCACACIBVqIQIgASAWaiEBIAQgCGohBCAJIBNqIQkgA0F/aiIDDQAL
CyAHIAUgBkEDELCAgIAAGgJAAkAgBygCACIEKgIAIhkgBCAHKAIQIglBBHRqKgIAIhqUIAQgCUEC
dGoqAgAiGyAEIAlBFGxqKgIAIhyUIAQgCUEYbGoqAgAiHZSSIAQgCUEDdGoqAgAiHiAEIAlBDGxq
KgIAIh+UIAQgCUEcbGoqAgAiIJSSIBsgH5STIBkgHJQgIJSTIB4gGpQgHZSTIiEQg4CAgAANAEMA
AIA/ISIgIYu7RI3ttaD3xrA+Y0EBcw0BC0EAKgKAiICAACIZIRsgGSEeIBkhHyAZIRogGSEcIBkh
HSAZISAgGSEiCyAAKAIAIgQgGTgCACAEIABBFGooAgAiCUECdGogGzgCACAEIAlBA3RqIB44AgAg
BCAAKAIQIgJBAnRqIB84AgAgBCACIAlqIgFBAnRqIBo4AgAgBCACIAlBAXRqQQJ0aiAcOAIAIAQg
AkEDdGogHTgCACAEIAkgAkEBdGpBAnRqICA4AgAgBCABQQN0aiAiOAIAIAcQl4CAgAAaIAYQl4CA
gAAaIAUQl4CAgAAaIAALnwgKAX8BfQF/An0Bfwp9AX8BfQN/AX0CQAJAIAAoAghBA0cNACAAKAIM
QQNHDQAgASgCCEECRw0AIAEoAgxBBEcNACACKAIIQQJHDQAgAigCDEEERg0BC0HZk4CAABCAgICA
AAsgACABKAIAIgMqAgAiBCAEIAMgAUEUaigCACIFQQJ0aioCACIGkiADIAVBA3RqKgIAIgeSIAMg
BUEDbCIIQQJ0aioCACIJkkMAAIA+lCIKkyIEQwAAAEEgAyAIIAEoAhAiAWpBAnRqKgIAIgsgCyAD
IAFBAnRqKgIAIgwgAyAFIAFqQQJ0aioCACINkiADIAVBAXQgAWpBAnRqKgIAIg6SkkMAAIA+lCIP
kyILIAuUIAkgCpMiCSAJlCAOIA+TIg4gDpQgByAKkyIHIAeUIA0gD5MiDSANlCAGIAqTIgYgBpQg
BCAElCAMIA+TIgwgDJSSkpKSkpKSlZEiBJS7IAwgBJS7IAYgBJS7IA0gBJS7IAcgBJS7IA4gBJS7
IAkgBJS7IAsgBJS7IAIoAgAiAyoCACILIAsgAyACQRRqKAIAIgVBAnRqKgIAIhCSIAMgBUEDdGoq
AgAiDJIgAyAFQQNsIghBAnRqKgIAIg2SQwAAgD6UIgmTIgtDAAAAQSADIAggAigCECIBakECdGoq
AgAiDiAOIAMgAUECdGoqAgAiESADIAUgAWpBAnRqKgIAIhKSIAMgBUEBdCABakECdGoqAgAiBpKS
QwAAgD6UIg6TIgcgB5QgDSAJkyINIA2UIAYgDpMiBiAGlCAMIAmTIgwgDJQgEiAOkyISIBKUIBAg
CZMiECAQlCALIAuUIBEgDpMiESARlJKSkpKSkpKVkSILlLsgESALlLsgECALlLsgEiALlLsgDCAL
lLsgBiALlLsgDSALlLsgByALlLsQtYCAgAAgACgCACIDIABBFGooAgAiBUEBdCICIAAoAhAiAUEB
dCIIakECdGoqAgAhECADIAggBWpBAnRqIggqAgAhByADIAIgAWpBAnRqIgIqAgAhESADIAVBA3Rq
IhMqAgAhFCADIAUgAWoiFUECdGoiFioCACEGIAMgBUECdGoiBSoCACEMIAMgAUECdGoiFyoCACES
IAMgBCAJIAMgAUEDdGoiASoCACINlCADKgIAIhhDAACAPyALlSILlJKUOAIAIBcgBCAOIA2UIBIg
C5SSlDgCACABIAQgDZQ4AgAgBSAEIAkgB5QgDCALlJKUOAIAIBYgBCAOIAeUIAYgC5SSlDgCACAI
IAQgB5Q4AgAgEyAUIAQgCiAYlCAPIAyUkpSTIAuUIAkgECAEIAogDZQgDyAHlJKUkyIHlJI4AgAg
AiARIAQgCiASlCAPIAaUkpSTIAuUIA4gB5SSOAIAIAMgFUEDdGogBzgCACAAC5sCAQZ/AkACQCAA
KAIIQQNHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMIgNBBEgNACACKAIIQQJHDQAgAigCDCAD
Rg0BC0GAlICAABCAgICAACABKAIMIQMLQQIgAxCSgICAACEEQQIgAxCSgICAACEFQQNBAxCSgICA
ACEGQQNBAxCSgICAACEHQQNBAxCSgICAACEIIAQgASAGQQNBAxCSgICAACIDEMGAgIAAIAUgAiAD
IAcQwYCAgAAgAyAIIAQgBRC2gICAACIBIAYQp4CAgAAaIAAgByADEKeAgIAAGiADEJeAgIAAGiAB
EJeAgIAAGiAHEJeAgIAAGiAGEJeAgIAAGiAFEJeAgIAAGiAEEJeAgIAAGiAAC/kFAhZ/Bn0CQAJA
IAAoAghBAkcNACAAKAIMQQNHDQAgASgCCEECRw0AIAEoAgwiA0EDSA0AIAIoAghBAkcNACACKAIM
IANGDQELQaeUgIAAEICAgIAAIAEoAgwhAwsgA0EBdCIEQQYQkoCAgAAhBSAEQQEQkoCAgAAhBkEG
QQEQkoCAgAAhBwJAIANBAUgNACAFQRRqKAIAIgRBDGwgBSgCECIIQQJ0IglqIQogBEEEdCAJaiEL
IARBFGwgCWohDCACKAIQQQJ0IQ0gASgCEEECdCEOIAhBA3QhDyAGKAIQIglBA3QhECAJQQJ0IREg
AkEUaigCAEECdCESIAFBFGooAgBBAnQhEyAEQQN0IRQgBEECdCEVIAYoAgAhCSAFKAIAIQQgAigC
ACECIAEoAgAhAQNAIAIgDWooAgAhFiABIA5qKAIAIQggAigCACEXIAQgASgCACIYNgIAIAQgFWog
CDYCACAEIBRqQYCAgPwDNgIAIAQgCmogGDYCACAEIAtqIAg2AgAgBCAMakGAgID8AzYCACAJIBc2
AgAgCSARaiAWNgIAIAIgEmohAiABIBNqIQEgBCAPaiEEIAkgEGohCSADQX9qIgMNAAsLIAcgBSAG
QQMQsICAgAAaAkACQCAHKAIAIgQqAgAiGSAEIAcoAhAiCUECdGoqAgAiGpIgBCAJQQN0aioCACIb
kiAEIAlBDGxqKgIAIhySIAQgCUEEdGoqAgAiHZIgBCAJQRRsaioCACIekhCDgICAAA0AIBkgHZQg
GiAclJOLu0SN7bWg98awPmNBAXMNAQtBACoCgIiAgAAiGSEaIBkhGyAZIRwgGSEdIBkhHgsgACgC
ACIEIBk4AgAgBCAAQRRqKAIAIglBAnRqIBo4AgAgBCAJQQN0aiAbOAIAIAQgACgCECICQQJ0aiAc
OAIAIAQgAiAJakECdGogHTgCACAEIAIgCUEBdGpBAnRqIB44AgAgBxCXgICAABogBhCXgICAABog
BRCXgICAABogAAvNBQMBfAJ/FXwCQAJAIAAoAghBAkcNACAAKAIMQQNHDQAgASgCCEECRw0AIAEo
AgxBA0cNACACKAIIQQJHDQAgAigCDEEDRg0BC0HKlICAABCAgICAAAtBACoCgIiAgAC7IQMCQAJA
IAEoAgAiBCABKAIQIgVBAnRqKgIAuyIGIAQgAUEUaigCACIBIAVqQQJ0aioCALsiB6EiCCAEIAFB
A3RqKgIAuyIJoiAHIAQgAUEBdCAFakECdGoqAgC7IgqhIgsgBCoCALsiDKIgCiAGoSINIAQgAUEC
dGoqAgC7Ig6ioKAiD5lEje21oPfGsD5jDQAgAigCACIEIAIoAhAiBUECdGoqAgC7IhAgBCACQRRq
KAIAIgEgBWpBAnRqKgIAuyIRoSAEIAFBA3RqKgIAuyISoiARIAQgAUEBdCAFakECdGoqAgC7IhOh
IAQqAgC7IhSiIBMgEKEgBCABQQJ0aioCALsiFaKgoJlEje21oPfGsD5jDQBEAAAAAAAA8D8gD6Mi
FiALIBSiIA0gFaKgIAggEqKgoiIPIBYgCSAOoSIXIBCiIAwgCaEiGCARoqAgDiAMoSIZIBOioKIi
GqIgFiAXIBSiIBggFaKgIBkgEqKgoiIXIBYgCyAQoiANIBGioCAIIBOioKIiCKKhmUSN7bWg98aw
PmNBAXNFDQAgFiAOIAqiIAcgCaKhIgMgEKIgBiAJoiAMIAqioSIKIBGioCAMIAeiIAYgDqKhIgcg
E6KgoiEGIBYgAyAUoiAKIBWioCAHIBKioKIhAwwBCyADIQ8gAyEXIAMhCCADIRogAyEGCyAAKAIA
IgQgD7Y4AgAgBCAAQRRqKAIAIgFBAnRqIBe2OAIAIAQgAUEDdGogA7Y4AgAgBCAAKAIQIgVBAnRq
IAi2OAIAIAQgBSABakECdGogGrY4AgAgBCAFIAFBAXRqQQJ0aiAGtjgCACAAC4EDAQl/AkACQCAA
KAIIQQJHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMIgNBA0gNACACKAIIQQJHDQAgAigCDCAD
Rg0BC0HtlICAABCAgICAACABKAIMIQMLQQIgAxCSgICAACEEQQIgAxCSgICAACEFQQNBAxCSgICA
ACEGQQNBAxCSgICAACEHQQNBAxCUgICAACEIEJaAgIAAIAhBAEEBQQBBAhCagICAACEJQQNBAxCS
gICAACEDQQNBAxCSgICAACEKEJaAgIAAIApBAEEBQQBBAhCagICAACELIAQgASAGIAMQwYCAgAAg
BSACIAMgBxDBgICAACAJIAQgBRC5gICAACEBIAMgCCAGEKeAgIAAGiAKIAcgAxCngICAABogACAL
EJWAgIAAGiALEJeAgIAAGiAKEJeAgIAAGiADEJeAgIAAGiABEJeAgIAAGiAIEJeAgIAAGiAHEJeA
gIAAGiAGEJeAgIAAGiAFEJeAgIAAGiAEEJeAgIAAGiAAC5kUAhx/DX0jgICAgABBEGsiBySAgICA
AAJAAkAgACgCCEEDRw0AIAAoAgxBA0cNACACKAIIQQJHDQAgAigCDCIIQQRIDQAgAygCCEECRw0A
IAMoAgwgCEcNAAJAIAFFDQAgASgCCEEBRw0BIAEoAgwgCEcNAQsgBEEBSA0AIAVBAUgNACAGQwAA
AABgDQELQZCVgIAAEICAgIAAIAIoAgwhCAsCQCABRQ0AIAFDAAAAABCbgICAABoLIAhBAnQiCUGy
lYCAABCFgICAACEKIAlB0ZWAgAAQhYCAgAAgCBCNgICAACILIAhBBBCOgICAACAIIARBAnQiDCAI
b2sgDGoiDUECdEHwlYCAABCFgICAACEOAkAgDUEBSA0AQQAhDyAIQQFIIRAgDiERA0ACQCAQDQBB
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
NgIACwv2EgMAQYAIC7ISAAD4f091dCBvZiBtZW1vcnkhAERvdWJsZSBmcmVlAEFzc2VydGlvbiBm
YWlsZWQgYXQgbWF0MzIuYzo2MQBPdXQgb2YgbWVtb3J5IGF0IG1hdDMyLmM6NjMAQXNzZXJ0aW9u
IGZhaWxlZCBhdCBtYXQzMi5jOjg0AE91dCBvZiBtZW1vcnkgYXQgbWF0MzIuYzo4NgBPdXQgb2Yg
bWVtb3J5IGF0IG1hdDMyLmM6ODkAT3V0IG9mIG1lbW9yeSBhdCBtYXQzMi5jOjEzNgAAAGANAAAB
AAAAAAAAAAAAAAABAAAAAQAAAAIAAABEb3VibGUgZnJlZSBhdCBtYXQzMi5jOjE0OQBBc3NlcnRp
b24gZmFpbGVkIGF0IG1hdDMyLmM6MTg0AEFzc2VydGlvbiBmYWlsZWQgYXQgbWF0MzIuYzoxODgA
QXNzZXJ0aW9uIGZhaWxlZCBhdCBtYXQzMi5jOjI3NQBEb3VibGUgZnJlZSBhdCBtYXQzMi5jOjI5
AEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMyLmM6MzYAQXNzZXJ0aW9uIGZhaWxlZCBh
dCBhcml0aG1ldGljMzIuYzo1OABBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjgw
AEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMyLmM6OTkAQXNzZXJ0aW9uIGZhaWxlZCBh
dCBhcml0aG1ldGljMzIuYzoxMjEAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzox
NDMAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzoxNjgAQXNzZXJ0aW9uIGZhaWxl
ZCBhdCBhcml0aG1ldGljMzIuYzoxODkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIu
YzoyMTgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzoyNzEAQXNzZXJ0aW9uIGZh
aWxlZCBhdCBhcml0aG1ldGljMzIuYzozMjIAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGlj
MzIuYzozNTYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzozNzgAQXNzZXJ0aW9u
IGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzo0MjAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1l
dGljMzIuYzo0MzYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6MjYxAEFzc2VydGlvbiBmYWls
ZWQgYXQgcXIzMi5jOjI2NQBBc3NlcnRpb24gZmFpbGVkIGF0IHFyMzIuYzoyODYAQXNzZXJ0aW9u
IGZhaWxlZCBhdCBxcjMyLmM6MjkwAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjMyMQBBc3Nl
cnRpb24gZmFpbGVkIGF0IHFyMzIuYzozMjUAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6Mzc5
AE91dCBvZiBtZW1vcnkgYXQgcXIzMi5jOjM2AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjY5
AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjczAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5j
OjE4NABEb3VibGUgZnJlZSBhdCBxcjMyLmM6NTUAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6
MTQ4AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjIyNABBc3NlcnRpb24gZmFpbGVkIGF0IHFy
MzIuYzoyMjgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzoyNDQAQXNzZXJ0aW9u
IGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzoyODAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3Jh
cGh5MzIuYzozNTkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzo0NDQAQXNzZXJ0
aW9uIGZhaWxlZCBhdCBhZmZpbmUzMi5jOjExOQBBc3NlcnRpb24gZmFpbGVkIGF0IGFmZmluZTMy
LmM6MTk2AEFzc2VydGlvbiBmYWlsZWQgYXQgYWZmaW5lMzIuYzoyMjkAQXNzZXJ0aW9uIGZhaWxl
ZCBhdCByYW5zYWMzMi5jOjcxAE91dCBvZiBtZW1vcnkgYXQgcmFuc2FjMzIuYzo4NABPdXQgb2Yg
bWVtb3J5IGF0IHJhbnNhYzMyLmM6ODgAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjkzAE91
dCBvZiBtZW1vcnkgYXQgcmFuc2FjMzIuYzoxMDcARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoy
MzYARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoyNDMARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIu
YzoyNDYARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoyNDkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBy
YW5zYWMzMi5jOjI3NQBPdXQgb2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6Mjg4AE91dCBvZiBtZW1v
cnkgYXQgcmFuc2FjMzIuYzoyOTIAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjI5NwBPdXQg
b2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6MzExAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDM2
AERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDQzAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6
NDQ2AERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDQ5AEFzc2VydGlvbiBmYWlsZWQgYXQgdHJh
bnNmb3JtMzIuYzozOQBBc3NlcnRpb24gZmFpbGVkIGF0IHRyYW5zZm9ybTMyLmM6NzcAQXNzZXJ0
aW9uIGZhaWxlZCBhdCB0cmFuc2Zvcm0zMi5jOjExNAAAQbQaCwwIAAAAUA0AAAEAAAAAQcAaCyQA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
`}},t={};function n(r){var a=t[r];if(a!==void 0)return a.exports;var A=t[r]={exports:{}};return _[r](A,A.exports,n),A.exports}n.d=(r,a)=>{for(var A in a)n.o(a,A)&&!n.o(r,A)&&Object.defineProperty(r,A,{enumerable:!0,get:a[A]})},n.o=(r,a)=>Object.prototype.hasOwnProperty.call(r,a),n.r=r=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})};var o={};return(()=>{"use strict";n.d(o,{default:()=>Kr});var r=n(1001),a=n(9037),A=n(2199),c=n(9192);let u=[],g=[],f="asap"+Math.random().toString(36).substr(1);window.addEventListener("message",C=>{if(C.source!==window||C.data!==f||(C.stopPropagation(),u.length==0))return;let e=u.pop(),i=g.pop();e.apply(void 0,i)},!0);function b(C,...e){u.unshift(C),g.unshift(e),window.postMessage(f,"*")}var d=n(8581);let y=2,I=navigator.userAgent.includes("Firefox")?(C,...e)=>setTimeout(C,10,...e):(C,...e)=>requestAnimationFrame(()=>C.apply(void 0,e));class x{constructor(e=y){a.A.assert(e>0),this._initialized=!1,this._pixelBuffer=new Array(e).fill(null).map(()=>new Uint8Array(0)),this._pbo=new Array(e).fill(null),this._consumerIndex=0,this._producerIndex=e-1,this._promise=Array.from({length:e},()=>c.i.resolve()),this._busy=new Array(e).fill(!1),this._ready=new Array(e).fill(!0)}init(e){this._allocatePBOs(e),e.subscribe(this._allocatePBOs,this,e),this._initialized=!0}release(e){return e.unsubscribe(this._allocatePBOs,this),this._deallocatePBOs(e),this._initialized=!1,null}readPixelsSync(e,i=0,s=0,l=e.width,p=e.height){a.A.assert(this._initialized);let h=e.gl,m=e.glFbo;l=Math.max(0,Math.min(l,e.width)),p=Math.max(0,Math.min(p,e.height)),i=Math.max(0,Math.min(i,e.width-l)),s=Math.max(0,Math.min(s,e.height-p));let P=l*p*4;return this._reallocate(P),h.isContextLost()?this._pixelBuffer[0].subarray(0,P):(h.bindFramebuffer(h.FRAMEBUFFER,m),h.readPixels(i,s,l,p,h.RGBA,h.UNSIGNED_BYTE,this._pixelBuffer[0]),h.bindFramebuffer(h.FRAMEBUFFER,null),this._pixelBuffer[0].subarray(0,P))}readPixelsAsync(e,i=0,s=0,l=e.width,p=e.height,h=!1){a.A.assert(this._initialized);let m=e.gl,P=e.glFbo;l=Math.max(0,Math.min(l,e.width)),p=Math.max(0,Math.min(p,e.height)),i=Math.max(0,Math.min(i,e.width-l)),s=Math.max(0,Math.min(s,e.height-p));let v=l*p*4;if(this._reallocate(v),m.isContextLost())return c.i.resolve(this._pixelBuffer[0].subarray(0,v));if(!h){let L=this._pixelBuffer[0].subarray(0,v);return x._readPixelsViaPBO(m,this._pbo[0],L,P,i,s,l,p).then(()=>L)}let w=this._pixelBuffer.length,T=this._producerIndex;if(!this._busy[T]){let L=this._pbo[T],H=this._pixelBuffer[T].subarray(0,v);this._producerIndex=(T+1)%w,this._ready[T]=!1,this._busy[T]=!0,this._promise[T]=x._readPixelsViaPBO(m,L,H,P,i,s,l,p).then(()=>{this._busy[T]=!1,this._ready[T]=!0})}let k=this._consumerIndex;return this._consumerIndex=(k+1)%w,this._ready[k]?(this._ready[k]=!1,c.i.resolve(this._pixelBuffer[k])):this._promise[k].then(()=>(this._ready[k]=!1,this._pixelBuffer[k]))}_reallocate(e){if(!(e<=this._pixelBuffer[0].byteLength))for(let i=0;i<this._pixelBuffer.length;i++){let s=new Uint8Array(e);this._pixelBuffer[i]=s}}_allocatePBOs(e){let i=e.gl;for(let s=0;s<this._pbo.length;s++)this._pbo[s]=i.createBuffer()}_deallocatePBOs(e){let i=e.gl;for(let s=this._pbo.length-1;s>=0;s--)i.deleteBuffer(this._pbo[s]),this._pbo[s]=null}static _readPixelsViaPBO(e,i,s,l,p,h,m,P){let v=m*P*4;a.A.assert(s.byteLength>=v,"Invalid buffer size"),e.bindBuffer(e.PIXEL_PACK_BUFFER,i),e.bufferData(e.PIXEL_PACK_BUFFER,v,e.DYNAMIC_READ),e.bindFramebuffer(e.FRAMEBUFFER,l),e.readPixels(p,h,m,P,e.RGBA,e.UNSIGNED_BYTE,0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindBuffer(e.PIXEL_PACK_BUFFER,null);let w=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),new c.i((T,k)=>{A.w.gpuPollingMode!="asap"?I(x._clientWaitAsync,e,w,0,T,k):b(x._clientWaitAsync,e,w,0,T,k)}).then(()=>{e.bindBuffer(e.PIXEL_PACK_BUFFER,i),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,s),e.bindBuffer(e.PIXEL_PACK_BUFFER,null)}).catch(T=>{throw new d.Er("Can't getBufferSubDataAsync(): error in clientWaitAsync()",T)}).finally(()=>{e.deleteSync(w)})}static _clientWaitAsync(e,i,s,l,p,h=10,m=1e3){(function P(){let v=e.clientWaitSync(i,s,0);m--<=0?p(new d.MU("GPU polling timeout",d.wB.from(e))):v===e.CONDITION_SATISFIED||v===e.ALREADY_SIGNALED?l():A.w.gpuPollingMode!="asap"?requestAnimationFrame(P):b(P)})()}}var S=n(3816);class M{constructor(e,i,s,l=e.RGBA,p=e.RGBA8,h=e.UNSIGNED_BYTE,m=e.NEAREST,P=e.MIRRORED_REPEAT){this._gl=e,this._width=Math.max(1,i|0),this._height=Math.max(1,s|0),this._hasMipmaps=!1,this._format=l,this._internalFormat=p,this._dataType=h,this._filter=m,this._wrap=P,this._glTexture=M._createTexture(this._gl,this._width,this._height,this._format,this._internalFormat,this._dataType,this._filter,this._wrap)}release(){let e=this._gl;if(this._glTexture==null)throw new d.Er("The SpeedyTexture has already been released");return this.discardMipmaps(),e.deleteTexture(this._glTexture),this._glTexture=null,this._width=this._height=0,null}upload(e,i=this._width,s=this._height){let l=this._gl;return e instanceof HTMLVideoElement&&e.readyState<2?this:(a.A.assert(i>0&&s>0),this.discardMipmaps(),this._width=i,this._height=s,this._internalFormat=l.RGBA8,this._format=l.RGBA,this._dataType=l.UNSIGNED_BYTE,M._upload(l,this._glTexture,this._width,this._height,e,0,this._format,this._internalFormat,this._dataType),this)}clear(){let e=this._gl;return e.isContextLost()?this:(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texImage2D(e.TEXTURE_2D,0,this._internalFormat,this._width,this._height,0,this._format,this._dataType,null),e.bindTexture(e.TEXTURE_2D,null),this.discardMipmaps(),this)}resize(e,i){let s=this._gl;if(this._width===e&&this._height===i)return this;if(e|=0,i|=0,e>S.MAX_TEXTURE_LENGTH||i>S.MAX_TEXTURE_LENGTH)throw new d.EM(`Maximum texture size exceeded. Using ${e} x ${i}, expected up to ${S.MAX_TEXTURE_LENGTH} x ${S.MAX_TEXTURE_LENGTH}.`);if(e<1||i<1)throw new d.qw(`Invalid texture size: ${e} x ${i}`);return s.isContextLost()?this:(this._width=e,this._height=i,s.bindTexture(s.TEXTURE_2D,this._glTexture),s.texImage2D(s.TEXTURE_2D,0,this._internalFormat,this._width,this._height,0,this._format,this._dataType,null),s.bindTexture(s.TEXTURE_2D,null),this.discardMipmaps(),this)}generateMipmaps(e=[]){let i=this._gl;if(this._hasMipmaps)return this;if(i.bindTexture(i.TEXTURE_2D,this._glTexture),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST_MIPMAP_LINEAR),i.generateMipmap(i.TEXTURE_2D),i.bindTexture(i.TEXTURE_2D,null),e.length>0){let s=this.width,l=this.height,p=1+Math.floor(Math.log2(Math.max(s,l)));a.A.assert(e.length<=p);for(let h=1;h<e.length;h++){let m=Math.max(1,s>>>h),P=Math.max(1,l>>>h);a.A.assert(e[h].width===m&&e[h].height===P),e[h].copyTo(this,h)}}return this._hasMipmaps=!0,this}discardMipmaps(){let e=this._gl;this._hasMipmaps&&(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,this._filter),e.bindTexture(e.TEXTURE_2D,null),this._hasMipmaps=!1)}hasMipmaps(){return this._hasMipmaps}isReleased(){return this._glTexture==null}get glTexture(){return this._glTexture}get width(){return this._width}get height(){return this._height}get gl(){return this._gl}static _createTexture(e,i,s,l,p,h,m,P){a.A.assert(i>0&&s>0);let v=e.createTexture();return e.bindTexture(e.TEXTURE_2D,v),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,m),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,m),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,P),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,P),e.texImage2D(e.TEXTURE_2D,0,p,i,s,0,l,h,null),e.bindTexture(e.TEXTURE_2D,null),v}static _upload(e,i,s,l,p,h,m,P,v){return e.bindTexture(e.TEXTURE_2D,i),e.texImage2D(e.TEXTURE_2D,h,P,s,l,0,m,v,p),e.bindTexture(e.TEXTURE_2D,null),i}}class N extends M{constructor(e,i,s,l=void 0,p=void 0,h=void 0,m=void 0,P=void 0){super(e,i,s,l,p,h,m,P),this._glFbo=N._createFramebuffer(e,this._glTexture)}release(){let e=this._gl;if(this._glFbo==null)throw new d.Er("The SpeedyDrawableTexture has already been released");return e.deleteFramebuffer(this._glFbo),this._glFbo=null,super.release()}get glFbo(){return this._glFbo}copyTo(e,i=0){let s=this._gl;if(s.isContextLost())return;let l=1<<(i|=0),p=Math.max(1,Math.floor(e.width/l)),h=Math.max(1,Math.floor(e.height/l));a.A.assert(this._width===p&&this._height===h),N._copyToTexture(s,this._glFbo,e.glTexture,0,0,this._width,this._height,i)}clear(){return this.clearToColor(0,0,0,0)}clearToColor(e,i,s,l){let p=this._gl;return p.isContextLost()?this:(e=Math.max(0,Math.min(+e,1)),i=Math.max(0,Math.min(+i,1)),s=Math.max(0,Math.min(+s,1)),l=Math.max(0,Math.min(+l,1)),this.discardMipmaps(),p.bindFramebuffer(p.FRAMEBUFFER,this._glFbo),p.viewport(0,0,this._width,this._height),p.clearColor(e,i,s,l),p.clear(p.COLOR_BUFFER_BIT),p.bindFramebuffer(p.FRAMEBUFFER,null),this)}inspect(e,i){if(i===void 0){i=new x,i.init(e);let s=i.readPixelsSync(this);return i.release(e),new Uint8Array(s)}else{let s=i.readPixelsSync(this);return new Uint8Array(s)}}inspect32(e,i){return a.A.assert(S.LITTLE_ENDIAN),new Uint32Array(this.inspect(e,i).buffer)}static _createFramebuffer(e,i){let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,i,0);let l=e.checkFramebufferStatus(e.FRAMEBUFFER);if(l!=e.FRAMEBUFFER_COMPLETE){let p=["FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"].filter(h=>e[h]===l)[0]||"unknown error";throw new d.wB(`Can't create framebuffer: ${p} (${l})`)}return e.bindFramebuffer(e.FRAMEBUFFER,null),s}static _copyToTexture(e,i,s,l,p,h,m,P=0){return e.bindTexture(e.TEXTURE_2D,s),e.bindFramebuffer(e.FRAMEBUFFER,i),e.copyTexSubImage2D(e.TEXTURE_2D,P,0,0,l,p,h,m),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),s}}var E=n(9420);let R=Object.freeze({sampler2D:"uniform1i",isampler2D:"uniform1i",usampler2D:"uniform1i",float:"uniform1f",int:"uniform1i",uint:"uniform1ui",bool:"uniform1i",vec2:"uniform2f",vec3:"uniform3f",vec4:"uniform4f",ivec2:"uniform2i",ivec3:"uniform3i",ivec4:"uniform4i",uvec2:"uniform2ui",uvec3:"uniform3ui",uvec4:"uniform4ui",bvec2:"uniform2i",bvec3:"uniform3i",bvec4:"uniform4i",mat2:"uniformMatrix2fv",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"});class B extends Function{constructor(e,i,s={}){return super("...args","return this._self._call(...args)"),this._self=this.bind(this),this._self._init(e,i,s),this._self}_init(e,i,s){if(e.isContextLost())throw new d.Er("Can't initialize SpeedyProgram: lost context");s=Object.assign({renderToTexture:!0,pingpong:!1},s),this._gl=e,this._program=B._compile(e,i.vertexSource,i.fragmentSource),this._geometry=new Q(e,{position:i.locationOfAttributes.position,texCoord:i.locationOfAttributes.texCoord}),this._argnames=i.arguments,this._argIsArray=new Array(this._argnames.length).fill(!1),this._ubo=null,this._renderToTexture=!!s.renderToTexture,this._width=1,this._height=1,this._size=[1,1],this._texture=new Array(s.pingpong?2:1).fill(null),this._textureIndex=0,this._uniform=new Map,this._shaderdecl=i,e.useProgram(this._program);for(let l of i.uniforms){let p=i.uniformType(l),h=e.getUniformLocation(this._program,l);this._uniform.set(l,new U(p,h))}for(let l=0;l<this._argnames.length;l++){let p=this._argnames[l];if(!this._uniform.has(p)&&(this._argIsArray[l]=this._uniform.has(D(p,0)),!this._argIsArray[l]))throw new d.Er(`Expected uniform "${p}", as declared in the argument list`)}}_call(...e){let i=this._gl,s=this._argnames,l=this._texture[this._textureIndex];if(e.length!=s.length)throw new d.qw(`Can't run shader: incorrect number of arguments (expected ${s.length}, got ${e.length})`);for(let m=e.length-1;m>=0;m--)if(e[m]===l)throw new d.EM("Can't run shader: don't use its output texture as an input to itself. Consider using pingpong rendering!");if(i.isContextLost())return l;i.useProgram(this._program),i.bindVertexArray(this._geometry.vao);let p=this._renderToTexture?l.glFbo:null,h=this._uniform.get("texSize");this._size[0]=this._width,this._size[1]=this._height,h.setValue(i,this._size);for(let m=0,P=0;m<e.length;m++){let v=s[m];if(!this._argIsArray[m])P=this._uniform.get(v).setValue(i,e[m],P);else{let w=e[m];if(Array.isArray(w)){if(this._uniform.has(D(v,w.length)))throw new d.qw(`Can't run shader: too few elements in the "${v}" array`);for(let T=0,k=void 0;(k=this._uniform.get(D(v,T)))!==void 0;T++)P=k.setValue(i,w[T],P)}else throw new d.qw(`Can't run shader: expected an array for "${v}"`)}}return this._ubo!==null&&this._ubo.update(),i.bindFramebuffer(i.FRAMEBUFFER,p),i.viewport(0,0,this._width,this._height),i.drawArrays(i.TRIANGLES,0,6),i.bindFramebuffer(i.FRAMEBUFFER,null),i.bindVertexArray(null),l?.discardMipmaps(),this._pingpong(),l}outputs(e,i,...s){return this._setOutputTexture(...s),this._setOutputSize(e,i),this}_setOutputSize(e,i){a.A.assert(e>0&&i>0),this._width=e|0,this._height=i|0;for(let s=0;s<this._texture.length;s++)this._texture[s]!=null&&this._texture[s].resize(this._width,this._height);return this}_setOutputTexture(...e){a.A.assert(e.length===this._texture.length,`Incorrect number of textures (expected ${this._texture.length})`);for(let i=0;i<this._texture.length;i++)this._texture[i]=e[i];return this._textureIndex=0,this}clear(){let e=this._texture[this._textureIndex];for(let i=0;i<this._texture.length;i++)this._texture[i].clear();return this._pingpong(),e}setUBO(e,i){return this._ubo===null&&(this._ubo=new F(this._gl,this._program)),this._ubo.set(e,i),this}release(){let e=this._gl;return this._ubo!=null&&(this._ubo=this._ubo.release()),this._texture.fill(null),this._geometry=this._geometry.release(),e.deleteProgram(this._program),this._program=null,null}definedConstant(e){return this._shaderdecl.definedConstant(e)}_pingpong(){this._texture.length>1&&(this._textureIndex=1-this._textureIndex)}static _compile(e,i,s){let l=e.createProgram(),p=e.createShader(e.VERTEX_SHADER),h=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(p,i),e.compileShader(p),e.attachShader(l,p),e.shaderSource(h,s),e.compileShader(h),e.attachShader(l,h),e.linkProgram(l),e.validateProgram(l),e.getProgramParameter(l,e.LINK_STATUS))return l;let m=[e.getShaderInfoLog(h),e.getShaderInfoLog(p),e.getProgramInfoLog(l)];e.deleteProgram(l),e.deleteShader(h),e.deleteShader(p);let P=k=>Math.max(0,2-Math.floor(Math.log10(k))),v=k=>new Array(P(k)).fill(" ").join("")+k+". ",T=(m[0]?s:i).split(`
`).map((k,L)=>v(1+L)+k).join(`
`);throw new d.wB(`

---------- ERROR ----------

`+m.filter(k=>k).join(`
`)+`

---------- SOURCE CODE ----------

`+T+`
`)}}function Q(C,e){return this.vao=C.createVertexArray(),this.vbo=Object.freeze({position:C.createBuffer(),texCoord:C.createBuffer()}),this._gl=C,C.bindVertexArray(this.vao),C.bindBuffer(C.ARRAY_BUFFER,this.vbo.position),C.bufferData(C.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),C.STATIC_DRAW),C.enableVertexAttribArray(e.position),C.vertexAttribPointer(e.position,2,C.FLOAT,!1,0,0),C.bindBuffer(C.ARRAY_BUFFER,this.vbo.texCoord),C.bufferData(C.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),C.STATIC_DRAW),C.enableVertexAttribArray(e.texCoord),C.vertexAttribPointer(e.texCoord,2,C.FLOAT,!1,0,0),C.bindBuffer(C.ARRAY_BUFFER,null),C.bindVertexArray(null),Object.freeze(this)}Q.prototype.release=function(){let C=this._gl;return C.deleteVertexArray(this.vao),C.deleteBuffer(this.vbo.position),C.deleteBuffer(this.vbo.texCoord),null};function U(C,e){if(this.type=String(C),!Object.prototype.hasOwnProperty.call(R,this.type))throw new d.EM(`Unsupported uniform type: ${this.type}`);this.location=e,this.setter=R[this.type];let i=Number(this.setter.match(/^uniform(Matrix)?(\d)/)[2])|0;this.dim=this.type.startsWith("mat")?2:this.type.indexOf("vec")>=0?1:0,this.length=this.dim==2?i*i:i,this._value=null}U.prototype.setValue=function(C,e,i=-1){let s=C[this.setter];if(typeof e=="object"&&this.type.endsWith("sampler2D")){if(i>=C.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw new d.EM(`Can't activate texture unit ${i}: max is ${C.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);if(Array.isArray(e))throw new d.EM("Can't pass arrays of textures to shaders");if(e==null)throw new d.qw(`Can't run shader: cannot use ${e} as an input texture`);if(i<0)throw new d.qw("Missing texNo");let l=e;C.activeTexture(C.TEXTURE0+i),C.bindTexture(C.TEXTURE_2D,l.glTexture),C.uniform1i(this.location,i),i++}else if(!(e===this._value&&typeof e!="object"))if(typeof e=="number"||typeof e=="boolean")s.call(C,this.location,e);else if(Array.isArray(e))if(e.length===this.length)this.dim==2?s.call(C,this.location,!1,e):s.call(C,this.location,...e);else throw new d.qw(`Can't run shader: incorrect number of values for ${this.type}: "${e}"`);else throw new d.qw(`Can't run shader: unrecognized argument "${e}"`);return this._value=e,i};function F(C,e){this._gl=C,this._program=e,this._nextIndex=0,this._ubo=Object.create(null)}F.prototype.set=function(C,e){let i=this._gl;this._ubo[C]===void 0&&(this._ubo[C]={buffer:i.createBuffer(),blockBindingIndex:this._nextIndex++,blockIndex:-1,data:null});let s=this._ubo[C];if(s.blockIndex<0){let l=i.getUniformBlockIndex(this._program,C);i.uniformBlockBinding(this._program,l,s.blockBindingIndex),s.blockIndex=l}s.data=e},F.prototype.update=function(){let C=this._gl;for(let e in this._ubo){let i=this._ubo[e];C.bindBuffer(C.UNIFORM_BUFFER,i.buffer),C.bufferData(C.UNIFORM_BUFFER,i.data,C.DYNAMIC_DRAW),C.bindBufferBase(C.UNIFORM_BUFFER,i.blockBindingIndex,i.buffer),C.bindBuffer(C.UNIFORM_BUFFER,null)}},F.prototype.release=function(){let C=this._gl;for(let e in this._ubo){let i=this._ubo[e];C.deleteBuffer(i.buffer),i.data=null}return null};function D(C,e){let i=D.cache,s=i.get(C);return s===void 0&&i.set(C,s=[]),s[e]===void 0&&(s[e]=`${C}[${e}]`),s[e]}D.cache=new Map;let z=Object.freeze({usesPingpongRendering(){return{pingpong:!0}},rendersToCanvas(){return{renderToTexture:!1}}});class q{constructor(e){this._gpu=e,this._programs=[]}declare(e,i,s={}){return Object.defineProperty(this,e,{get:(()=>{let l=Symbol(e);return()=>this[l]||(this[l]=this._createProgram(i.build(),s))})()}),this}get program(){return z}release(){for(let e=0;e<this._programs.length;e++)this._programs[e].release();return null}_createProgram(e,i={}){let s=new B(this._gpu.gl,e,i);return this._programs.push(s),s}}let j=(0,E.bf)("utils/copy.glsl").withArguments("image"),V=(0,E.bf)("utils/copy-raster.glsl").withDefines({TYPE:1}).withArguments("image"),te=(0,E.bf)("utils/copy-raster.glsl").withDefines({TYPE:2}).withArguments("image"),ge=(0,E.bf)("utils/copy.glsl","utils/flip-y.vs.glsl").withArguments("image"),Be=(0,E.bf)("utils/fill.glsl").withArguments("value"),Oe=(0,E.bf)("utils/fill-components.glsl").withArguments("image","pixelComponents","value"),Xe=(0,E.bf)("utils/copy-components.glsl").withArguments("dest","src","destComponents","srcComponentId"),qe=(0,E.bf)("utils/scan-minmax2d.glsl").withArguments("image","iterationNumber"),ce=(0,E.bf)("utils/sobel-derivatives.glsl","utils/sobel-derivatives.vs.glsl").withArguments("pyramid","lod");class K extends q{constructor(e){super(e),this.declare("renderToCanvas",ge,Object.assign({},this.program.rendersToCanvas())).declare("copy",j).declare("copyKeypoints",V).declare("copy2DVectors",te).declare("fill",Be).declare("fillComponents",Oe).declare("copyComponents",Xe).declare("scanMinMax2D",qe,Object.assign({},this.program.usesPingpongRendering())).declare("sobelDerivatives",ce)}}var J=n(1672);let ye=(0,E.bf)("filters/rgb2grey.glsl").withArguments("image"),ie=[3,5,7].reduce((C,e)=>(C[e]=(0,E.bf)("filters/convolution2d.glsl").withDefines({KERNEL_SIZE_SQUARED:e*e}).withArguments("image","kernel"),C),{}),Ie=[3,5,7,9,11,13,15].reduce((C,e)=>(C[e]=(0,E.bf)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:e,AXIS:0}).withArguments("image","kernel"),C),{}),Ye=[3,5,7,9,11,13,15].reduce((C,e)=>(C[e]=(0,E.bf)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:e,AXIS:1}).withArguments("image","kernel"),C),{}),se=[3,5,7].reduce((C,e)=>(C[e]=(0,E.bf)("filters/fast-median.glsl").withDefines({KERNEL_SIZE:e}).withArguments("image"),C),{}),W=(0,E.bf)("filters/normalize-image.glsl").withDefines({GREYSCALE:1}).withArguments("minmax2d","minValue","maxValue"),ae=(0,E.bf)("filters/normalize-image.glsl").withDefines({GREYSCALE:0}).withArguments("minmax2dRGB","minValue","maxValue"),ne=(0,E.bf)("filters/nightvision.glsl").withDefines({GREYSCALE:0}).withArguments("image","illuminationMap","gain","offset","decay"),$=(0,E.bf)("filters/nightvision.glsl").withDefines({GREYSCALE:1}).withArguments("image","illuminationMap","gain","offset","decay"),ee=C=>Math.max(1,C/6),_e=C=>a.A.gaussianKernel(ee(C),C),ve=C=>new Array(C).fill(1/C);class pe extends q{constructor(e){super(e),this.declare("rgb2grey",ye).declare("median3",se[3]).declare("median5",se[5]).declare("median7",se[7]).declare("convolution3",ie[3]).declare("convolution5",ie[5]).declare("convolution7",ie[7]).declare("convolution3x",Ie[3]).declare("convolution3y",Ye[3]).declare("convolution5x",Ie[5]).declare("convolution5y",Ye[5]).declare("convolution7x",Ie[7]).declare("convolution7y",Ye[7]).declare("convolution9x",Ie[9]).declare("convolution9y",Ye[9]).declare("convolution11x",Ie[11]).declare("convolution11y",Ye[11]).declare("convolution13x",Ie[13]).declare("convolution13y",Ye[13]).declare("convolution15x",Ie[15]).declare("convolution15y",Ye[15]).declare("normalizeGreyscale",W).declare("normalizeColored",ae).declare("nightvision",ne).declare("nightvisionGreyscale",$).declare("illuminationMapLoX",(0,J.convX)(a.A.gaussianKernel(80,31))).declare("illuminationMapLoY",(0,J.convY)(a.A.gaussianKernel(80,31))).declare("illuminationMapX",(0,J.convX)(a.A.gaussianKernel(80,63))).declare("illuminationMapY",(0,J.convY)(a.A.gaussianKernel(80,63))).declare("illuminationMapHiX",(0,J.convX)(a.A.gaussianKernel(80,255))).declare("illuminationMapHiY",(0,J.convY)(a.A.gaussianKernel(80,255))).declare("gaussian3x",(0,J.convX)([.25,.5,.25])).declare("gaussian3y",(0,J.convY)([.25,.5,.25])).declare("gaussian5x",(0,J.convX)([.05,.25,.4,.25,.05])).declare("gaussian5y",(0,J.convY)([.05,.25,.4,.25,.05])).declare("gaussian7x",(0,J.convX)(_e(7))).declare("gaussian7y",(0,J.convY)(_e(7))).declare("gaussian9x",(0,J.convX)(_e(9))).declare("gaussian9y",(0,J.convY)(_e(9))).declare("gaussian11x",(0,J.convX)(_e(11))).declare("gaussian11y",(0,J.convY)(_e(11))).declare("box3x",(0,J.convX)(ve(3))).declare("box3y",(0,J.convY)(ve(3))).declare("box5x",(0,J.convX)(ve(5))).declare("box5y",(0,J.convY)(ve(5))).declare("box7x",(0,J.convX)(ve(7))).declare("box7y",(0,J.convY)(ve(7))).declare("box9x",(0,J.convX)(ve(9))).declare("box9y",(0,J.convY)(ve(9))).declare("box11x",(0,J.convX)(ve(11))).declare("box11y",(0,J.convY)(ve(11)))}}var Se=n(6634);let Ge=4,Xt=11;class Bn extends Se.Q{static create(e,i,s){a.A.assert(s%Ge==0,`Invalid descriptorSize: ${s}`);let l=i.length,p=s/Ge,h=Math.log2(p*Math.max(l,1))/2,P=1<<Math.min(Xt,Math.ceil(h)),v=P,w=P,T=v*w/p;if(l>T)throw new d.EM(`The capacity of the descriptorDB (${T} for ${s*8}-bit descriptors) has been exceeded`);let k=new Uint8Array(v*w*Ge);for(let Y=0;Y<l;Y++){let re=Y*s,De=i[Y];a.A.assert(De.byteLength===s),a.A.assert(re+s<=k.byteLength),k.set(De,re)}let L=1048576,H=l*s;return a.A.log(`Creating a ${v}x${w} database of ${l} ${s*8}-bit descriptors (total size: ${(H/L).toFixed(2)} MB)`),e.resize(v,w),e.upload(k),e}}let Dn=8,Ir=15,kt=[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],ut=[10,11,12,13,14,15,16,17,18,19,20],_r=[32,64],Ma=(C,e,i)=>!ut.includes(e)||!kt.includes(C)?null:[{name:"x-small",bucketCapacity:1,tableCount:C,hashSize:e,capacity:on(e,1,i)},{name:"small",bucketCapacity:2,tableCount:C,hashSize:e,capacity:on(e,2,i)},{name:"small-plus",bucketCapacity:3,tableCount:C,hashSize:e,capacity:on(e,3,i)},{name:"medium",bucketCapacity:4,tableCount:C,hashSize:e,capacity:on(e,4,i)},{name:"medium-plus",bucketCapacity:5,tableCount:C,hashSize:e,capacity:on(e,5,i)},{name:"large",bucketCapacity:6,tableCount:C,hashSize:e,capacity:on(e,6,i)},{name:"x-large",bucketCapacity:8,tableCount:C,hashSize:e,capacity:on(e,8,i)}],it=Math.max(...ut),mn=Math.max(...kt),fo=C=>(a.A.range(mn).forEach(e=>C.subarray(e*it,(e+1)*it).sort()),C),mo=(C,e)=>(a.A.range(mn).forEach(i=>e.subarray((i+1)*it-C,(i+1)*it).fill(195939070)),e),yr=(C=>ut.reduce((e,i)=>(e[i]=C(i),e),{}))(C=>({32:fo(mo(it-C,new Uint32Array([...a.A.shuffle(a.A.range(256)),...a.A.shuffle(a.A.range(256)),...a.A.shuffle(a.A.range(256))].slice(0,mn*it)))),64:fo(mo(it-C,new Uint32Array([...a.A.shuffle(a.A.range(512)),...a.A.shuffle(a.A.range(512))].slice(0,mn*it))))})),jn=4,Ta=C=>C>1?1<<Math.ceil(Math.log2(C)):1;class Ba{constructor(e,i,s,l=Dn,p=Ir,h=.95){let m=s.length,P=m>0?s[0].byteLength:0,v=Ma(l,p,h);a.A.assert(m>0,"Can't build LSH tables without descriptors!"),a.A.assert(_r.includes(P),`Can't build LSH tables: unacceptable descriptor size of ${P} bytes`),a.A.assert(s.findIndex(w=>w.byteLength!==P)<0,`Can't build LSH tables: incorrectly sized descriptors. Expected ${P} bytes for each`),a.A.assert(m<S.MATCH_MAX_INDEX,`Can't build LSH tables: too many descriptors (${s.length})`),a.A.assert(v!=null,`Can't build LSH tables: unacceptable number of tables (${l}) x hash size (${p})`),this._profile=v.find(w=>m<=w.capacity)||v[v.length-1],this._descriptorSize=P,this._descriptorCount=m,this._sequences=this._pickSequences(this._descriptorSize),this._tables=this._createStaticTables(e,this._sequences,s,P),this._descriptorDB=Bn.create(i,s,P)}get descriptorSize(){return this._descriptorSize}get descriptorCount(){return this._descriptorCount}get sequences(){return this._sequences}get hashSize(){return this._profile.hashSize}get bucketCapacity(){return this._profile.bucketCapacity}get bucketsPerTable(){return 1<<this._profile.hashSize}get tableCount(){return this._profile.tableCount}get tableSize(){return this.bucketsPerTable*this.bucketCapacity*jn}get totalSize(){return this.tableCount*this.tableSize}get tables(){return this._tables}get descriptorDB(){return this._descriptorDB}_pickSequences(e){return a.A.assert(Object.prototype.hasOwnProperty.call(yr,this.hashSize)),a.A.assert(Object.prototype.hasOwnProperty.call(yr[this.hashSize],e)),yr[this.hashSize][e]}_createStaticTables(e,i,s,l){let h=this._profile.name,m=this._profile.capacity,P=this.tableCount,v=this.bucketsPerTable,w=this.bucketCapacity*jn,T=this.hashSize,k=this.tableCount*this.bucketsPerTable*this.bucketCapacity,L=Math.min(Ta(Math.sqrt(k)),4096),H=Math.ceil(k/L),Y=s.length;a.A.assert(T<=it),a.A.assert(P<=mn),a.A.assert(k<=L*H);let re=1048576;if(a.A.log(`Building ${P} ${h} LSH tables with ${Y} ${l*8}-bit descriptors each and hashSize = ${T} bits (${L}x${H}, with ${(this.tableSize/re).toFixed(2)} MB per table and total size = ${(this.totalSize/re).toFixed(2)} MB), `),Y>m){let ue=100*Y/m;a.A.warning(`There are too many descriptors (${Y}) for a ${h} LSH table. That's ${ue.toFixed(2)}% of its theoretical capacity. Consider increasing the hashSize (currently set to ${T}) or reducing the number of descriptors to avoid degradation.`)}let De=new ArrayBuffer(L*H*jn),Qe=new Uint8Array(De).fill(255),xe=new DataView(De),Ce=a.A.shuffle(a.A.range(Y)),Je=new Array(P).fill(0);for(let ue=0;ue<Y;ue++){let at=Ce[ue],Wt=this._hashCodes(s[at],i);for(let Et=0;Et<P;Et++){let Lt=Wt[Et],Rn=Et*v*w+Lt*w,Yt=4294967295;for(let cn=0;cn<w;cn+=jn){let Oo=Rn+cn;if(Yt=xe.getUint32(Oo,!0),Yt==4294967295){xe.setUint32(Oo,at,!0);break}}Yt!=4294967295&&Je[Et]++}}let je=Je.reduce((ue,at)=>ue+at,0),st=Je.map(ue=>100*ue/Y);return a.A.log(`When building ${P} ${h} LSH tables with ${Y} ${l*8}-bit descriptors each and hashSize = ${T} bits, I got the following discard profile: `+st.map(ue=>ue.toFixed(2)+"%").join(", ")+`. Average: ${(100*je/(P*Y)).toFixed(2)}%. Minimum: ${Math.min(...st).toFixed(2)}%. Table capacity: ${m}.`),e.resize(L,H),e.upload(Qe),e}_hashCodes(e,i){let s=this.tableCount,l=this.hashSize,p=this.bucketsPerTable,h=new Array(s);a.A.assert(l<=it&&i.length>=it*s);for(let m=0;m<s;m++){let P=it*m,v=0;for(let w=0;w<l;w++){let T=i[P+w],k=T>>>3,L=1<<(T&7);v=v<<1|(e[k]&L)!=0}a.A.assert(v>=0&&v<p),h[m]=v}return h}}function Da(C,e){let i=Math.exp(-C),s=1,l=1,p=1;for(let h=1;h<=e;h++)s+=(p*=C)/(l*=h);return s*i}function on(C,e,i=.99){let s=1<<C,l=e,p=i,h=1,m=s*l,P=0,v=0;for(;h<m;)P=Math.floor((h+m)/2),v=Da(P/s,l),v>p?h=P+1:m=P;return P}let Na=(0,E.bf)("keypoints/fast.glsl","keypoints/fast.vs.glsl").withDefines({FAST_TYPE:916}).withArguments("corners","pyramid","lod","threshold"),Zn=[1,3,5,7].reduce((C,e)=>(C[e]=(0,E.bf)("keypoints/harris.glsl").withDefines({WINDOW_SIZE:e}).withArguments("corners","pyramid","derivatives","lod","lodStep","gaussian"),C),{}),Ra=(0,E.bf)("keypoints/score-findmax.glsl").withArguments("corners","iterationNumber"),ka=(0,E.bf)("keypoints/harris-cutoff.glsl").withArguments("corners","maxScore","quality"),Qa=(0,E.bf)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:0}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),Ka=(0,E.bf)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:1}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),La=(0,E.bf)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:2}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),Oa=(0,E.bf)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:3}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),za=(0,E.bf)("keypoints/refine-scale.glsl").withDefines({METHOD:0}).withArguments("pyramid","lodStep","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Fa=(0,E.bf)("keypoints/refine-scale.glsl").withDefines({METHOD:1}).withArguments("pyramid","lodStep","encodedKeypoints","descriptorSize","extraSize","encoderLength","threshold"),Ua=(0,E.bf)("keypoints/allocate-descriptors.glsl").withArguments("inputEncodedKeypoints","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),Xa=(0,E.bf)("keypoints/allocate-extra.glsl").withArguments("inputEncodedKeypoints","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),Ga=(0,E.bf)("keypoints/transfer-to-extra.glsl").withArguments("encodedData","strideOfEncodedData","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Ha=(0,E.bf)("keypoints/orb-descriptor.glsl").withArguments("image","encodedCorners","extraSize","encoderLength"),qa=(0,E.bf)("keypoints/orb-orientation.glsl").withArguments("image","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Wa=(0,E.bf)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:0}).withArguments("image","lodStep"),Ya=(0,E.bf)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:1}).withArguments("image","lodStep"),Va=(0,E.bf)("keypoints/nonmax-space.glsl").withArguments("corners"),Ja=(0,E.bf)("keypoints/nonmax-scale.glsl").withDefines({USE_LAPLACIAN:1}).withArguments("corners","pyramid","pyrLaplacian","lodStep"),ja=(0,E.bf)("keypoints/nonmax-scale.glsl").withDefines({USE_LAPLACIAN:0}).withArguments("corners","pyramid","lodStep"),Za=(0,E.bf)("keypoints/laplacian.glsl").withArguments("corners","pyramid","lodStep","lodOffset"),St=[3,5,7,9,11,13,15,17,19,21].reduce((C,e)=>(C[e]=(0,E.bf)("keypoints/lk.glsl").withDefines({WINDOW_SIZE:e}).withArguments("encodedFlow","prevKeypoints","nextPyramid","prevPyramid","level","depth","numberOfIterations","discardThreshold","epsilon","descriptorSize","extraSize","encoderLength"),C),{}),$a=(0,E.bf)("keypoints/transfer-flow.glsl").withArguments("encodedFlow","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ec=(0,E.bf)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:0}),tc=(0,E.bf)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:1}),nc=(0,E.bf)("keypoints/knn-transfer.glsl").withArguments("encodedMatches","encodedKthMatches","numberOfMatchesPerKeypoint","kthMatch"),ic=(0,E.bf)("keypoints/bf-knn.glsl").withDefines({DESCRIPTOR_SIZE:32,NUMBER_OF_KEYPOINTS_PER_PASS:16}).withArguments("encodedMatches","encodedFilters","matcherLength","dbEncodedKeypoints","dbDescriptorSize","dbExtraSize","dbEncoderLength","encodedKeypoints","descriptorSize","extraSize","encoderLength","passId"),rc=(0,E.bf)("keypoints/bf-knn.glsl").withDefines({DESCRIPTOR_SIZE:64,NUMBER_OF_KEYPOINTS_PER_PASS:8}).withArguments("encodedMatches","encodedFilters","matcherLength","dbEncodedKeypoints","dbDescriptorSize","dbExtraSize","dbEncoderLength","encodedKeypoints","descriptorSize","extraSize","encoderLength","passId"),oc=(0,E.bf)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:0}),sc=(0,E.bf)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:1}),$n=_r.reduce((C,e)=>(C[e]=ut.reduce((i,s)=>(i[s]=[0,1,2].reduce((l,p)=>(l[p]=(0,E.bf)("keypoints/lsh-knn.glsl").withDefines({DESCRIPTOR_SIZE:e,HASH_SIZE:s,LEVEL:p,SEQUENCE_MAXLEN:it,SEQUENCE_COUNT:mn}).withArguments("candidates","filters","matcherLength","tables","descriptorDB","tableIndex","bucketCapacity","bucketsPerTable","tablesStride","descriptorDBStride","encodedKeypoints","descriptorSize","extraSize","encoderLength"),l),{}),i),{}),C),{}),ac=(0,E.bf)("keypoints/knn-transfer.glsl").withArguments("encodedMatches","encodedKthMatches","numberOfMatchesPerKeypoint","kthMatch"),cc=(0,E.bf)("keypoints/sort-keypoints.glsl").withDefines({STAGE:1}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength"),lc=(0,E.bf)("keypoints/sort-keypoints.glsl").withDefines({STAGE:2}).withArguments("permutation","blockSize","dblLog2BlockSize"),Ac=(0,E.bf)("keypoints/sort-keypoints.glsl").withDefines({STAGE:3}).withArguments("permutation","maxKeypoints","encodedKeypoints","descriptorSize","extraSize"),dc=(0,E.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:1}).withArguments("encodedKeypointsA","encodedKeypointsB","encoderLengthA","encoderLengthB","encoderCapacityA","encoderCapacityB","descriptorSize","extraSize","encoderLength"),pc=(0,E.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:2}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","maxKeypoints"),uc=(0,E.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:3}).withArguments("array","blockSize"),hc=(0,E.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:5}).withArguments("array"),gc=(0,E.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:4}).withArguments("array","encodedKeypoints","descriptorSize","extraSize","encoderLength"),fc=(0,E.bf)("keypoints/lookup-of-locations.glsl").withDefines({FS_OUTPUT_TYPE:2,STAGE:1}).withArguments("corners"),mc=(0,E.bf)("keypoints/lookup-of-locations.glsl","keypoints/lookup-of-locations.vs.glsl").withDefines({FS_OUTPUT_TYPE:2,FS_USE_CUSTOM_PRECISION:1,STAGE:2}).withArguments("lookupTable","blockSize","width","height"),Ic=(0,E.bf)("keypoints/lookup-of-locations.glsl").withDefines({STAGE:-1}).withArguments("lookupTable"),_c=(0,E.bf)("keypoints/encode-keypoints.glsl").withArguments("corners","lookupTable","stride","descriptorSize","extraSize","encoderLength","encoderCapacity"),yc=(0,E.bf)("keypoints/encode-keypoint-offsets.glsl").withArguments("corners","imageSize"),Sc=(0,E.bf)("keypoints/encode-keypoint-long-offsets.glsl").withDefines({MAX_ITERATIONS:6}).withArguments("offsetsImage","imageSize"),Ec=(0,E.bf)("keypoints/encode-keypoint-positions.glsl").withArguments("offsetsImage","imageSize","passId","numPasses","keypointLimit","encodedKeypoints","descriptorSize","extraSize","encoderLength"),xc=(0,E.bf)("keypoints/encode-keypoint-properties.glsl").withArguments("corners","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Cc=(0,E.bf)("keypoints/encode-null-keypoints.glsl").withArguments(),Pc=(0,E.bf)("keypoints/transfer-orientation.glsl").withArguments("encodedOrientations","encodedKeypoints","descriptorSize","extraSize","encoderLength"),vc=(0,E.bf)("keypoints/upload-keypoints.glsl").withDefines({BUFFER_SIZE:1024}).withArguments("encodedKeypoints","startIndex","endIndex","descriptorSize","extraSize","encoderLength"),bc=(0,E.bf)("keypoints/apply-homography.glsl").withArguments("homography","encodedKeypoints","descriptorSize","extraSize","encoderLength"),wc=(0,E.bf)("keypoints/clip-border.glsl").withArguments("imageWidth","imageHeight","borderTop","borderRight","borderBottom","borderLeft","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Mc=(0,E.bf)("keypoints/distance-filter.glsl").withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),Tc=(0,E.bf)("keypoints/hamming-distance-filter.glsl").withDefines({DESCRIPTOR_SIZE:32}).withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),Bc=(0,E.bf)("keypoints/hamming-distance-filter.glsl").withDefines({DESCRIPTOR_SIZE:64}).withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),Dc=(0,E.bf)("keypoints/shuffle.glsl").withDefines({PERMUTATION_MAXLEN:2048}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength"),Nc=(0,E.bf)("keypoints/clip.glsl").withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","maxKeypoints");class Rc extends q{constructor(e){super(e),this.declare("fast9_16",Na,Object.assign({},this.program.usesPingpongRendering())).declare("harris1",Zn[1],Object.assign({},this.program.usesPingpongRendering())).declare("harris3",Zn[3],Object.assign({},this.program.usesPingpongRendering())).declare("harris5",Zn[5],Object.assign({},this.program.usesPingpongRendering())).declare("harris7",Zn[7],Object.assign({},this.program.usesPingpongRendering())).declare("harrisScoreFindMax",Ra,Object.assign({},this.program.usesPingpongRendering())).declare("harrisScoreCutoff",ka).declare("subpixelQuadratic1d",Qa).declare("subpixelTaylor2d",Ka).declare("subpixelBicubic",Oa).declare("subpixelBilinear",La).declare("refineScaleLoG",za).declare("refineScaleFAST916",Fa).declare("allocateDescriptors",Ua).declare("allocateExtra",Xa).declare("transferToExtra",Ga).declare("orbDescriptor",Ha).declare("orbOrientation",qa).declare("nonmax",Wa).declare("pyrnonmax",Ya).declare("nonmaxSpace",Va).declare("nonmaxScale",Ja).declare("nonmaxScaleSimple",ja).declare("laplacian",Za).declare("lk21",St[21],Object.assign({},this.program.usesPingpongRendering())).declare("lk19",St[19],Object.assign({},this.program.usesPingpongRendering())).declare("lk17",St[17],Object.assign({},this.program.usesPingpongRendering())).declare("lk15",St[15],Object.assign({},this.program.usesPingpongRendering())).declare("lk13",St[13],Object.assign({},this.program.usesPingpongRendering())).declare("lk11",St[11],Object.assign({},this.program.usesPingpongRendering())).declare("lk9",St[9],Object.assign({},this.program.usesPingpongRendering())).declare("lk7",St[7],Object.assign({},this.program.usesPingpongRendering())).declare("lk5",St[5],Object.assign({},this.program.usesPingpongRendering())).declare("lk3",St[3],Object.assign({},this.program.usesPingpongRendering())).declare("transferFlow",$a).declare("bfMatcherInitCandidates",ec).declare("bfMatcherInitFilters",tc).declare("bfMatcherTransfer",nc,Object.assign({},this.program.usesPingpongRendering())).declare("bfMatcher32",ic,Object.assign({},this.program.usesPingpongRendering())).declare("bfMatcher64",rc,Object.assign({},this.program.usesPingpongRendering())).declare("lshKnnInitCandidates",oc).declare("lshKnnInitFilters",sc).declare("lshKnnTransfer",ac,Object.assign({},this.program.usesPingpongRendering())).declare("sortCreatePermutation",cc).declare("sortMergePermutation",lc,Object.assign({},this.program.usesPingpongRendering())).declare("sortApplyPermutation",Ac).declare("mixKeypointsPreInit",dc).declare("mixKeypointsInit",pc).declare("mixKeypointsSort",uc,Object.assign({},this.program.usesPingpongRendering())).declare("mixKeypointsView",hc).declare("mixKeypointsApply",gc).declare("encodeNullKeypoints",Cc).declare("encodeKeypoints",_c).declare("initLookupTable",fc).declare("sortLookupTable",mc,Object.assign({},this.program.usesPingpongRendering())).declare("viewLookupTable",Ic).declare("encodeKeypointSkipOffsets",yc).declare("encodeKeypointLongSkipOffsets",Sc,Object.assign({},this.program.usesPingpongRendering())).declare("encodeKeypointPositions",Ec,Object.assign({},this.program.usesPingpongRendering())).declare("encodeKeypointProperties",xc).declare("transferOrientation",Pc).declare("uploadKeypoints",vc,Object.assign({},this.program.usesPingpongRendering())).declare("applyHomography",bc).declare("clipBorder",wc).declare("distanceFilter",Mc).declare("hammingDistanceFilter32",Tc).declare("hammingDistanceFilter64",Bc).declare("shuffle",Dc).declare("clip",Nc);for(let i of Object.keys($n))for(let s of Object.keys($n[i]))for(let l of Object.keys($n[i][s])){let p=`lshKnn${i}h${s}lv${l}`;this.declare(p,$n[i][s][l],Object.assign({},this.program.usesPingpongRendering()))}}}let kc=(0,E.bf)("pyramids/upsample2.glsl").withArguments("image"),Qc=(0,E.bf)("pyramids/downsample2.glsl").withArguments("image");class Kc extends q{constructor(e){super(e),this.declare("upsample2",kc).declare("downsample2",Qc).declare("smoothX",(0,J.convX)([.05,.25,.4,.25,.05])).declare("smoothY",(0,J.convY)([.05,.25,.4,.25,.05])).declare("smoothX2",(0,J.convX)([.1,.5,.8,.5,.1])).declare("smoothY2",(0,J.convY)([.1,.5,.8,.5,.1],1/2))}}let Lc=(0,E.bf)("transforms/warp-perspective.glsl").withArguments("image","inverseHomography"),Oc=(0,E.bf)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:0}).withArguments("image"),zc=(0,E.bf)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:1}).withArguments("image"),Fc=(0,E.bf)("transforms/additive-mix.glsl").withArguments("image0","image1","alpha","beta","gamma");class Uc extends q{constructor(e){super(e),this.declare("warpPerspective",Lc).declare("resizeNearest",Oc).declare("resizeBilinear",zc).declare("additiveMix",Fc)}}class Io{constructor(e){this._gpu=e,this._filters=null,this._transforms=null,this._pyramids=null,this._keypoints=null,this._utils=null}get filters(){return this._filters||(this._filters=new pe(this._gpu))}get transforms(){return this._transforms||(this._transforms=new Uc(this._gpu))}get pyramids(){return this._pyramids||(this._pyramids=new Kc(this._gpu))}get keypoints(){return this._keypoints||(this._keypoints=new Rc(this._gpu))}get utils(){return this._utils||(this._utils=new K(this._gpu))}release(){for(let e in this)if(Object.prototype.hasOwnProperty.call(this,e)&&this[e]!=null){let i=this[e];i instanceof q&&i.release()}return null}}let Xc=1024,_o=Symbol("Bucket");class Gc{constructor(e,i,s){this.texture=e,this.index=i,this.next=s,this.free=!0}}class ei{constructor(e,i=Xc){a.A.assert(i>0),this._bucket=Array.from({length:i},(s,l)=>new Gc(null,l,l-1)),this._head=i-1,this._gpu=e}allocate(){if(this._head<0)throw new d.l(`Exhausted pool (capacity: ${this._bucket.length})`);let e=this._bucket[this._head];return e.free=!1,this._head=e.next,e.texture==null&&(e.texture=ei._createManagedTexture(this._gpu.gl,e)),e.texture}free(e){let i=e[_o];return a.A.assert(i!==void 0&&!i.free,"Unmanaged texture or double free"),i.next=this._head,i.free=!0,this._head=i.index,null}release(){for(let e=0;e<this._bucket.length;e++)this._bucket[e].texture!=null&&(this._bucket[e].texture=this._bucket[e].texture.release());return null}static _createManagedTexture(e,i){let s=new N(e,1,1);return Object.defineProperty(s,_o,{configurable:!1,enumerable:!1,writable:!1,value:i})}}var de=n(6049);let Gt=Symbol();class Ht{constructor(e){if(e!==Gt)throw new d.Er;this._data=null}static load(e){if(e instanceof HTMLImageElement)return ti.load(e);if(e instanceof HTMLVideoElement)return In.load(e);if(e instanceof HTMLCanvasElement)return ni.load(e);if(typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas)return ii.load(e);if(e instanceof ImageBitmap)return ri.load(e);if(e instanceof ImageData)return oi.load(e);throw new d.qw(`Unsupported media type: ${e}`)}get data(){return this._data}isLoaded(){return this._data!==null}get type(){throw new d.aQ}get width(){throw new d.aQ}get height(){throw new d.aQ}clone(){throw new d.aQ}release(){return this._data=null}_load(e){throw new d.aQ}static _waitUntil(e,i,s=3e4){return new c.i((l,p)=>{a.A.log(`Waiting for ${i} to be triggered in ${e}...`);let h=setTimeout(()=>{m(),p(new d.MU(`${i} has not been triggered in ${e}: timeout (${s}ms)`))},s);function m(){clearTimeout(h),e.removeEventListener("error",P,!1),e.removeEventListener(i,v,!1)}function P(){let T=e.error!==null&&typeof e.error=="object"?e.error:{code:-1,message:""},k=`${T.message} (error code ${T.code})`;m(),p(new d.FJ(`Can't load ${e}. ${k}`))}function v(){m(),l(e)}e.addEventListener("error",P,!1),e.addEventListener(i,v,!1)})}}class ti extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return de.zu.Image}get width(){return this._data?this._data.naturalWidth:0}get height(){return this._data?this._data.naturalHeight:0}clone(){if(this._data==null)throw new d.Er("Media not loaded");let e=this._data.cloneNode(!0);return ti.load(e)}_load(e){return this.isLoaded()&&this.release(),e.complete&&e.naturalWidth!==0?new c.i(i=>{this._data=e,i(this)}):Ht._waitUntil(e,"load").then(()=>(this._data=e,this))}static load(e){return new ti(Gt)._load(e)}}class In extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return de.zu.Video}get width(){return this._data?this._data.videoWidth:0}get height(){return this._data?this._data.videoHeight:0}clone(){if(this._data==null)throw new d.Er("Media not loaded");let e=this._data.cloneNode(!0);return In.load(e)}_load(e){return this.isLoaded()&&this.release(),a.A.log("Loading a video..."),e.load(),In._waitUntilPlayable(e).then(()=>In._handleAutoplay(e).then(()=>(this._data=e,this)))}static load(e){return new In(Gt)._load(e)}static _handleAutoplay(e){return e.autoplay?new c.i((i,s)=>{let l=e.play();if(l===void 0){i();return}l.then(i,s)}):c.i.resolve()}static _waitUntilPlayable(e){return e.readyState>=3?c.i.resolve(e):new c.i((l,p)=>{let h=0,m=setInterval(()=>{e.readyState>=3?(clearInterval(m),l(e)):(h+=500)>=3e4&&(clearInterval(m),p(new d.MU("The video took too long to load")))},500)})}}class ni extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return de.zu.Canvas}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(this._data==null)throw new d.Er("Media not loaded");let e=a.A.createCanvas(this.width,this.height);return e.getContext("2d").drawImage(this._data,0,0),ni.load(e)}_load(e){return this.isLoaded()&&this.release(),new c.i(i=>{this._data=e,i(this)})}static load(e){return new ni(Gt)._load(e)}}class ii extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return de.zu.OffscreenCanvas}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(this._data==null)throw new d.Er("Media not loaded");let e=new OffscreenCanvas(this.width,this.height);return e.getContext("2d").drawImage(this._data,0,0),ii.load(e)}_load(e){return this.isLoaded()&&this.release(),new c.i(i=>{this._data=e,i(this)})}static load(e){return new ii(Gt)._load(e)}}class ri extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return de.zu.Bitmap}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(this._data==null)throw new d.Er("Media not loaded");return new c.i((e,i)=>{createImageBitmap(this._data).then(s=>{new ri(Gt)._load(s).then(e,i)},i)})}release(){return this._data!=null&&this._data.close(),super.release()}_load(e){return this.isLoaded()&&this.release(),new c.i(i=>{this._data=e,i(this)})}static load(e){return new ri(Gt)._load(e)}}class oi extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return de.zu.Data}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(this._data==null)throw new d.Er("Media not loaded");let e=new ImageData(new Uint8ClampedArray(this._data.data),this._data.width,this._data.height);return oi.load(e)}_load(e){return this.isLoaded()&&this.release(),new c.i(i=>{this._data=e,i(this)})}static load(e){return new oi(Gt)._load(e)}}var Hc=n(3211);class qc extends Hc.c{constructor(){super(),this._speedyGL=r.c.instance,this._programs=new Io(this),this._texturePool=new ei(this),this._speedyGL.subscribe(this._reset,this)}get programs(){return this._programs}get gl(){return this._speedyGL.gl}get canvas(){return this._speedyGL.canvas}get texturePool(){return this._texturePool}renderToCanvas(e){let i=e.width,s=e.height,l=this.canvas;return(i>l.width||s>l.height)&&(a.A.warning(`Resizing the canvas to ${i} x ${s}`),l.width=i,l.height=s),this.programs.utils.renderToCanvas.outputs(i,s,null),this.programs.utils.renderToCanvas(e),l}upload(e,i){return i.upload(e.data,e.width,e.height)}release(){return a.A.assert(!this.isReleased()),this._programs=this._programs.release(),this._texturePool=this._texturePool.release(),this._speedyGL.unsubscribe(this._reset),null}isReleased(){return this._programs==null}loseAndRestoreWebGLContext(){return this._speedyGL.loseAndRestoreContext().then(()=>{})}_reset(){this.isReleased()||(this._programs=new Io(this),this._texturePool=new ei(this),this._notify())}}class rt{constructor(e,i){this._width=Math.max(0,+e),this._height=Math.max(0,+i)}get width(){return this._width}set width(e){this._width=Math.max(0,+e)}get height(){return this._height}set height(e){this._height=Math.max(0,+e)}toString(){return`SpeedySize(${this.width}, ${this.height})`}equals(e){return this.width===e.width&&this.height===e.height}area(){return this.width*this.height}}let Sr=Symbol();class sn{constructor(e,i,s={}){if(e!==Sr)throw new d.Er;if(this._source=i,this._format=s.format!==void 0?s.format:de.f5.RGBA,this._options=Object.freeze(Object.assign(Object.assign({},s),{},{format:this._format})),i.isLoaded()){if(this._format!==de.f5.RGBA&&this._format!==de.f5.GREY)throw new d.qw(`Invalid format: ${this._format}`)}else throw new d.Er(`Source not loaded: ${i}`)}static load(e,i={},s=!0){return Ht.load(e).then(l=>{a.A.assert(l.width!==0&&l.height!==0);let p=new sn(Sr,l,i);return s&&a.A.log(`Loaded SpeedyMedia with a ${e}.`),p})}get source(){return this._source?this._source.data:null}get type(){if(this.isReleased())return"unknown";switch(this._source.type){case de.zu.Image:return"image";case de.zu.Video:return"video";case de.zu.Canvas:return"canvas";case de.zu.OffscreenCanvas:return"offscreen-canvas";case de.zu.Bitmap:return"bitmap";case de.zu.Data:return"data";default:return"unknown"}}get width(){return this._source?this._source.width:0}get height(){return this._source?this._source.height:0}get size(){return this._source?new rt(this._source.width,this._source.height):new rt(0,0)}get options(){return this._options}release(){return this.isReleased()||(a.A.log("Releasing SpeedyMedia object..."),this._source=this._source.release()),null}isReleased(){return this._source==null}clone(){if(this.isReleased())throw new d.Er("Can't clone a SpeedyMedia that has been released");let e=new sn(Sr,this._source,this._options);return c.i.resolve(e)}toBitmap(){if(this.isReleased())throw new d.Er("Can't convert SpeedyMedia to ImageBitmap: the media has been released");if(this._source.isLoaded())return this._source.type==de.zu.Bitmap?c.i.resolve(this._source.data):new c.i((e,i)=>createImageBitmap(this._source.data).then(e,i));throw new d.Er("Can't convert SpeedyMedia to bitmap: the media hasn't been loaded")}}class Wc extends Se.Q{static get renderer(){return r.c.instance.renderer}static get vendor(){return r.c.instance.vendor}}class Ve{constructor(e,i){this._x=+e,this._y=+i}get x(){return this._x}set x(e){this._x=+e}get y(){return this._y}set y(e){this._y=+e}toString(){return`SpeedyVector2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}equals(e){return this.x===e.x&&this.y===e.y}dot(e){return this.x*e.x+this.y*e.y}distanceTo(e){let i=this.x-e.x,s=this.y-e.y;return Math.sqrt(i*i+s*s)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalized(){let e=this.length();return e>0?new Ve(this.x/e,this.y/e):new Ve(0,0)}plus(e){return new Ve(this.x+e.x,this.y+e.y)}minus(e){return new Ve(this.x-e.x,this.y-e.y)}times(e){return new Ve(this.x*e,this.y*e)}}class si{constructor(e,i){this._x=+e,this._y=+i}get x(){return this._x}set x(e){this._x=+e}get y(){return this._y}set y(e){this._y=+e}toString(){return`SpeedyPoint2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}plus(e){return new si(this.x+e.x,this.y+e.y)}minus(e){return new Ve(this.x-e.x,this.y-e.y)}equals(e){return this.x===e.x&&this.y===e.y}}var Yd=n(6306),G=n(6465),Qt=n(4188);class Yc extends Function{constructor(){return super("...args","return args.length > 1 ? this._create(...args) : this._from(args[0])"),this.bind(this)}_create(e,i=e,s=[]){return Qt.SpeedyMatrix.Create(e,i,s)}_from(e){return Qt.SpeedyMatrix.From(e)}Zeros(e,i=e){return Qt.SpeedyMatrix.Zeros(e,i)}Ones(e,i=e){return Qt.SpeedyMatrix.Ones(e,i)}Eye(e,i=e){return Qt.SpeedyMatrix.Eye(e,i)}ready(){return Qt.SpeedyMatrix.ready()}qr(e,i,s,{mode:l="reduced"}={}){let p=s,h=s.rows,m=s.columns;if(l=="reduced"){if(e.rows!=h||e.columns!=m||i.rows!=m||i.columns!=m)throw new d.qw("Invalid shape for reduced QR")}else if(l=="full"){if(e.rows!=h||e.columns!=h||i.rows!=h||i.columns!=m)throw new d.qw("Invalid shape for full QR")}else throw new d.qw(`Invalid mode for QR: "${l}"`);return G.U.ready().then(({wasm:P,memory:v})=>{let w=G.U.allocateMat32(P,v,e),T=G.U.allocateMat32(P,v,i),k=G.U.allocateMat32(P,v,p);return G.U.copyToMat32(P,v,k,p),l=="reduced"?P.exports.Mat32_qr_reduced(w,T,k):P.exports.Mat32_qr_full(w,T,k),G.U.copyFromMat32(P,v,w,e),G.U.copyFromMat32(P,v,T,i),G.U.deallocateMat32(P,v,k),G.U.deallocateMat32(P,v,T),G.U.deallocateMat32(P,v,w),[e,i]})}ols(e,i,s,{method:l="qr"}={}){let p=i.rows,h=i.columns,m=e;if(p<h||h==0)throw new d.qw("Can't solve an underdetermined system of equations");if(s.rows!=p||s.columns!=1||m.rows!=h||m.columns!=1)throw new d.qw("Invalid shapes");return G.U.ready().then(({wasm:P,memory:v})=>{let w=G.U.allocateMat32(P,v,i),T=G.U.allocateMat32(P,v,s),k=G.U.allocateMat32(P,v,m);switch(G.U.copyToMat32(P,v,w,i),G.U.copyToMat32(P,v,T,s),l){case"qr":P.exports.Mat32_qr_ols(k,w,T,2);break;default:throw new d.qw(`Invalid method: "${l}"`)}return G.U.copyFromMat32(P,v,k,m),G.U.deallocateMat32(P,v,k),G.U.deallocateMat32(P,v,T),G.U.deallocateMat32(P,v,w),e})}solve(e,i,s,{method:l="qr"}={}){let p=i.rows,h=i.columns,m=e;if(p!=h)throw new d.qw("Can't solve an over or underdetermined system of equations");if(s.rows!=p||s.columns!=1||m.rows!=p||m.columns!=1)throw new d.qw("Invalid shapes");return G.U.ready().then(({wasm:P,memory:v})=>{switch(l){case"qr":return this.ols(m,i,s,{method:l});default:throw new d.qw(`Invalid method: "${l}"`)}})}perspective(e,i,s){if(i.rows!=2||i.columns!=4||s.rows!=2||s.columns!=4)throw new d.qw("You need two 2x4 input matrices to compute a perspective transformation");if(e.rows!=3||e.columns!=3)throw new d.qw("The output of perspective() is a 3x3 homography");return G.U.ready().then(({wasm:l,memory:p})=>{let h=G.U.allocateMat32(l,p,e),m=G.U.allocateMat32(l,p,i),P=G.U.allocateMat32(l,p,s);return G.U.copyToMat32(l,p,m,i),G.U.copyToMat32(l,p,P,s),l.exports.Mat32_homography_ndlt4(h,m,P),G.U.copyFromMat32(l,p,h,e),G.U.deallocateMat32(l,p,P),G.U.deallocateMat32(l,p,m),G.U.deallocateMat32(l,p,h),e})}findHomography(e,i,s,{method:l="default",mask:p=null,reprojectionError:h=3,numberOfHypotheses:m=512,bundleSize:P=128}={}){if(i.rows!=2||i.columns<4||s.rows!=2||s.columns!=i.columns)throw new d.qw("You need two 2 x n (n >= 4) input matrices to compute a homography");if(e.rows!=3||e.columns!=3)throw new d.qw("The output of findHomography() is a 3x3 homography");if(p!=null&&(p.rows!=1||p.columns!=i.columns))throw new d.qw("Invalid shape of the inliers mask");return G.U.ready().then(({wasm:v,memory:w})=>{let T=G.U.allocateMat32(v,w,e),k=G.U.allocateMat32(v,w,i),L=G.U.allocateMat32(v,w,s),H=p!=null?G.U.allocateMat32(v,w,p):0;switch(G.U.copyToMat32(v,w,k,i),G.U.copyToMat32(v,w,L,s),l){case"pransac":a.A.assert(h>=0&&m>0&&P>0),v.exports.Mat32_pransac_homography(T,H,k,L,m,P,h);break;case"default":case"dlt":v.exports.Mat32_homography_ndlt(T,k,L);break;default:throw new d.qw(`Illegal method for findHomography(): "${l}"`)}return G.U.copyFromMat32(v,w,T,e),p!=null&&G.U.copyFromMat32(v,w,H,p),p!=null&&G.U.deallocateMat32(v,w,H),G.U.deallocateMat32(v,w,L),G.U.deallocateMat32(v,w,k),G.U.deallocateMat32(v,w,T),e})}applyPerspectiveTransform(e,i,s){if(i.rows!=2||e.rows!=2||i.columns!=e.columns)throw new d.qw("Invalid shapes");if(s.rows!=3||s.columns!=3)throw new d.qw("The perspective transformation must be a 3x3 matrix");return G.U.ready().then(({wasm:l,memory:p})=>{let h=G.U.allocateMat32(l,p,s),m=G.U.allocateMat32(l,p,i),P=G.U.allocateMat32(l,p,e);return G.U.copyToMat32(l,p,m,i),G.U.copyToMat32(l,p,h,s),l.exports.Mat32_transform_perspective(P,m,h),G.U.copyFromMat32(l,p,P,e),G.U.deallocateMat32(l,p,P),G.U.deallocateMat32(l,p,m),G.U.deallocateMat32(l,p,h),e})}affine(e,i,s){if(i.rows!=2||i.columns!=3||s.rows!=2||s.columns!=3)throw new d.qw("You need two 2x3 input matrices to compute an affine transform");if(e.rows!=2||e.columns!=3)throw new d.qw("The output of affine() is a 2x3 matrix");return G.U.ready().then(({wasm:l,memory:p})=>{let h=G.U.allocateMat32(l,p,e),m=G.U.allocateMat32(l,p,i),P=G.U.allocateMat32(l,p,s);return G.U.copyToMat32(l,p,m,i),G.U.copyToMat32(l,p,P,s),l.exports.Mat32_affine_direct3(h,m,P),G.U.copyFromMat32(l,p,h,e),G.U.deallocateMat32(l,p,P),G.U.deallocateMat32(l,p,m),G.U.deallocateMat32(l,p,h),e})}findAffineTransform(e,i,s,{method:l="default",mask:p=null,reprojectionError:h=3,numberOfHypotheses:m=512,bundleSize:P=128}={}){if(i.rows!=2||i.columns<3||s.rows!=2||s.columns!=i.columns)throw new d.qw("You need two 2 x n (n >= 3) input matrices to compute an affine transform");if(e.rows!=2||e.columns!=3)throw new d.qw("The output of findAffineTransform() is a 2x3 matrix");if(p!=null&&(p.rows!=1||p.columns!=i.columns))throw new d.qw("Invalid shape of the inliers mask");return G.U.ready().then(({wasm:v,memory:w})=>{let T=G.U.allocateMat32(v,w,e),k=G.U.allocateMat32(v,w,i),L=G.U.allocateMat32(v,w,s),H=p!=null?G.U.allocateMat32(v,w,p):0;switch(G.U.copyToMat32(v,w,k,i),G.U.copyToMat32(v,w,L,s),l){case"pransac":a.A.assert(h>=0&&m>0&&P>0),v.exports.Mat32_pransac_affine(T,H,k,L,m,P,h);break;case"default":v.exports.Mat32_affine_direct(T,k,L);break;default:throw new d.qw(`Illegal method for findAffineTransform(): "${l}"`)}return G.U.copyFromMat32(v,w,T,e),p!=null&&G.U.copyFromMat32(v,w,H,p),p!=null&&G.U.deallocateMat32(v,w,H),G.U.deallocateMat32(v,w,L),G.U.deallocateMat32(v,w,k),G.U.deallocateMat32(v,w,T),e})}applyAffineTransform(e,i,s){if(i.rows!=2||e.rows!=2||i.columns!=e.columns)throw new d.qw("Invalid shapes");if(s.rows!=2||s.columns!=3)throw new d.qw("The affine transformation must be a 2x3 matrix");return G.U.ready().then(({wasm:l,memory:p})=>{let h=G.U.allocateMat32(l,p,s),m=G.U.allocateMat32(l,p,i),P=G.U.allocateMat32(l,p,e);return G.U.copyToMat32(l,p,m,i),G.U.copyToMat32(l,p,h,s),l.exports.Mat32_transform_affine(P,m,h),G.U.copyFromMat32(l,p,P,e),G.U.deallocateMat32(l,p,P),G.U.deallocateMat32(l,p,m),G.U.deallocateMat32(l,p,h),e})}}let O=Object.freeze({Nothing:Symbol("Nothing"),Image:Symbol("Image"),Keypoints:Symbol("Keypoints"),Vector2:Symbol("Vector2"),LSHTables:Symbol("LSHTables"),KeypointMatches:Symbol("KeypointMatches")});class an{constructor(e){this._type=e}get type(){return this._type}hasType(e){return this._type===e}isEmpty(){return this.hasType(O.Nothing)}toString(){return`message of type ${Object.keys(O).find(i=>O[i]===this.type)}`}inspect(e){throw new d.aQ}set(...e){throw new d.aQ}static create(e){return tl(e)}}class yo extends an{constructor(){super(O.Nothing)}set(){return this}inspect(e){return{type:this.constructor.name}}}class Vc extends an{constructor(){super(O.Image),this._image=null,this._format=de.f5.RGBA}set(e,i=de.f5.RGBA){return this._image=e,this._format=i,this}inspect(e){let i=Object.keys(de.f5).find(s=>de.f5[s]===this.format);return{type:this.constructor.name,format:String(i),imageSize:this.image?`${this.image.width}x${this.image.height}`:"0x0",image:this.image?"<image data>":"",hasMipmaps:this.image&&this.image.hasMipmaps()?"yes":"no"}}get image(){return this._image}get format(){return this._format}}class Jc extends an{constructor(){super(O.Keypoints),this._encodedKeypoints=null,this._descriptorSize=0,this._extraSize=0,this._encoderLength=1}set(e,i,s,l){return this._encodedKeypoints=e,this._descriptorSize=i|0,this._extraSize=s|0,this._encoderLength=l|0,a.A.assert(this._descriptorSize>=0&&this._extraSize>=0),a.A.assert(this._encoderLength===this._encodedKeypoints.width,"Invalid encoderLength"),a.A.assert(this._encodedKeypoints.width===this._encodedKeypoints.height,"Invalid encodedKeypoints texture"),this}inspect(e){return{type:this.constructor.name,descriptorSize:this.descriptorSize,extraSize:this.extraSize,encoderLength:this.encoderLength,encodedKeypointsSize:this.encodedKeypoints?`${this.encodedKeypoints.width}x${this.encodedKeypoints.height}`:"0x0",encodedKeypoints:this.encodedKeypoints?a.A.formatBinaryData(this.encodedKeypoints.inspect(e).buffer):""}}get encodedKeypoints(){return this._encodedKeypoints}get descriptorSize(){return this._descriptorSize}get extraSize(){return this._extraSize}get encoderLength(){return this._encoderLength}}class jc extends an{constructor(){super(O.Vector2),this._vectors=null}set(e){return this._vectors=e,this}inspect(e){return{type:this.constructor.name,vectorsSize:this.vectors?`${this.vectors.width}x${this.vectors.height}`:"0x0",vectors:this.vectors?a.A.formatBinaryData(this.vectors.inspect(e).buffer):""}}get vectors(){return this._vectors}}class Zc extends an{constructor(){super(O.LSHTables),this._lsh=null}set(e){return this._lsh=e,this}inspect(e){return{type:this.constructor.name,lsh:"<LSH tables>"}}get lsh(){return this._lsh}}class $c extends an{constructor(){super(O.KeypointMatches),this._encodedMatches=null,this._matchesPerKeypoint=1}set(e,i){return this._encodedMatches=e,this._matchesPerKeypoint=i|0,a.A.assert(this._matchesPerKeypoint>0),this}inspect(e){return{type:this.constructor.name,matchesPerKeypoint:this.matchesPerKeypoint,encodedMatchesSize:this.encodedMatches?`${this.encodedMatches.width}x${this.encodedMatches.height}`:"0x0",encodedMatches:this.encodedMatches?a.A.formatBinaryData(this.encodedMatches.inspect(e).buffer):""}}get encodedMatches(){return this._encodedMatches}get matchesPerKeypoint(){return this._matchesPerKeypoint}}let el=Object.freeze({[O.Nothing]:yo,[O.Image]:Vc,[O.Keypoints]:Jc,[O.Vector2]:jc,[O.LSHTables]:Zc,[O.KeypointMatches]:$c});function tl(C){return new el[C]}let So=C=>!0;class nl{constructor(e,i=So){this._expectedMessageType=e,this._isValidMessage=typeof i=="function"?i:So,a.A.assert(this._expectedMessageType!=O.Nothing)}isCompatibleWith(e){return this._expectedMessageType==e._expectedMessageType}accepts(e){return e.hasType(this._expectedMessageType)&&this._isValidMessage(e)}toString(){return`Port expects ${Object.keys(O).find(i=>O[i]===this._expectedMessageType)} satisfying ${this._isValidMessage}`}get expectedMessageType(){return this._expectedMessageType}}let il="in",rl="out",ol=/^[a-z][a-zA-Z0-9]*$/,Eo=new yo;class xo{constructor(e,i,s){this._name=String(e),this._spec=i,this._node=s,this._message=Eo,a.A.assert(ol.test(this._name),`Port name "${this._name}" is not acceptable`)}get name(){return this._name}get node(){return this._node}connectTo(e){throw new d.aQ}isInputPort(){throw new d.aQ}isOutputPort(){return!this.isInputPort()}clearMessage(){this._message=Eo}hasMessage(){return!this._message.isEmpty()}read(){if(this._message.isEmpty())throw new d.Er(`Can't read from port ${this.name}: nothing to read`);return this._message}write(e){throw new d.EM(`Can't write ${e} to port ${this.name}: unsupported operation`)}inspect(e){return this._message.inspect(e)}static get DEFAULT_NAME(){throw new d.aQ}}class Er extends xo{constructor(e,i,s){super(e,i,s),this._cachedMessage=null}connectTo(e){if(!e.isInputPort())throw new d.qw(`Can't connect output port ${this.name} to port ${e.name}: expected an input port`);e.connectTo(this)}isInputPort(){return!1}write(e){if(!this._spec.accepts(e))throw new d.qw(`Can't write ${e} to port ${this.name}. ${this._spec}`);this._message=e}swrite(...e){this._cachedMessage==null&&(this._cachedMessage=an.create(this._spec.expectedMessageType)),this.write(this._cachedMessage.set(...e))}static get DEFAULT_NAME(){return rl}}class xr extends xo{constructor(e,i,s){super(e,i,s),this._incomingLink=null}get incomingLink(){return this._incomingLink}connectTo(e){if(e.isOutputPort()){if(!this._spec.isCompatibleWith(e._spec))throw new d.qw(`Can't connect port ${this.name} of "${this.node.fullName}" to port ${e.name} of "${e.node.fullName}": incompatible types`)}else throw new d.qw(`Can't connect input port ${this.name} of "${this.node.fullName}" to input port ${e.name} of "${e.node.fullName}": expected an output port`);this._incomingLink=e}disconnect(){this._incomingLink=null}isInputPort(){return!0}pullMessage(e=""){let i=e.length>0?`${this.name} of ${e}`:this.name;if(this._incomingLink==null)throw new d.Er(`No incoming link for input port ${i}`);let s=this._incomingLink.read();if(!this._spec.accepts(s))throw new d.qw(`Can't receive ${s} at port ${i}: ${this._spec}`);return this._message=s}static get DEFAULT_NAME(){return il}}class Co{constructor(e,i){this._class=e,this._name=String(i),this._type=O.Nothing,this._messageConstraint=void 0}expects(e){return a.A.assert(this._type==O.Nothing),a.A.assert(e!=O.Nothing),this._type=e,this}satisfying(e){return a.A.assert(this._type!=O.Nothing,"You must first declare what type of message this port expects"),a.A.assert(this._messageConstraint===void 0),a.A.assert(typeof e=="function"),this._messageConstraint=e,this}build(e){let i=new nl(this._type,this._messageConstraint);return Reflect.construct(this._class,[this._name,i,e])}}function Ae(C=xr.DEFAULT_NAME){return new Co(xr,C)}function fe(C=Er.DEFAULT_NAME){return new Co(Er,C)}let sl=()=>Math.random().toString(16).substr(2),al=()=>Object.create(null),cl=()=>Object.create(null);function ll(C){return C.reduce((e,i)=>(e[i.name]=i,e),al())}function Al(C){return C.reduce((e,i)=>(e[i.name]=i,e),cl())}let Po=!1;class Ee{constructor(e=sl(),i=0,s=[]){this._name=String(e),this._tex=new Array(i).fill(null);let l=s.map(m=>m.build(this)),p=l.filter(m=>m.isInputPort()),h=l.filter(m=>m.isOutputPort());if(this._inputPorts=ll(p),this._outputPorts=Al(h),this._name.length==0)throw new d.qw(`Invalid name "${this._name}" for node ${this.fullName}`);if(s.length==0)throw new d.qw(`No ports have been found in node ${this.fullName}`)}get name(){return this._name}get fullName(){return`${this.constructor.name}[${this.name}]`}input(e=xr.DEFAULT_NAME){if(e in this._inputPorts)return this._inputPorts[e];throw new d.qw(`Can't find input port ${e} in node ${this.fullName}`)}output(e=Er.DEFAULT_NAME){if(e in this._outputPorts)return this._outputPorts[e];throw new d.qw(`Can't find output port ${e} in node ${this.fullName}`)}execute(e){let i;for(i in this._outputPorts)this._outputPorts[i].clearMessage();for(i in this._inputPorts)this._inputPorts[i].pullMessage(this.fullName);let s=this._run(e);return typeof s>"u"?void this._finishExecution(e):s.then(()=>this._finishExecution(e))}_finishExecution(e){for(let i in this._outputPorts)a.A.assert(this._outputPorts[i].hasMessage(),`Did you forget to write data to the output port ${i} of ${this.fullName}?`);if(A.w.logging==="diagnostic"){a.A.log(`%c ${this.fullName} `,"font-size:12pt;font-weight:bold;color:white;background:blue");for(let i in this._inputPorts)a.A.log(`%c-> ${i}:`,"font-size:10pt;font-weight:bold",this._inputPorts[i].inspect(e));for(let i in this._outputPorts)a.A.log(`%c<- ${i}:`,"font-size:10pt;font-weight:bold",this._outputPorts[i].inspect(e))}}_run(e){throw new d.aQ}init(e){e.subscribe(this._allocateWorkTextures,this,e),this._allocateWorkTextures(e)}release(e){this._deallocateWorkTextures(e),e.unsubscribe(this._allocateWorkTextures,this)}clearPorts(){let e;for(e in this._inputPorts)this._inputPorts[e].clearMessage();for(e in this._outputPorts)this._outputPorts[e].clearMessage()}inputNodes(){let e=[];for(let i in this._inputPorts){let s=this._inputPorts[i];s.incomingLink!=null&&e.push(s.incomingLink.node)}return e}isSource(){return!1}isSink(){return!1}_allocateWorkTextures(e){for(let i=0;i<this._tex.length;i++)this._tex[i]=e.texturePool.allocate()}_deallocateWorkTextures(e){for(let i=this._tex.length-1;i>=0;i--)this._tex[i]=e.texturePool.free(this._tex[i])}_visualize(e,i){let s=e.renderToCanvas(i);Po||(document.body.appendChild(s),Po=!0)}}class Nn extends Ee{constructor(e=void 0,i=void 0,s=void 0){super(e,i,s),a.A.assert(Object.keys(this._inputPorts).length==0)}isSource(){return!0}}class Cr extends Ee{constructor(e=void 0,i=void 0,s=void 0){super(e,i,s),a.A.assert(Object.keys(this._outputPorts).length==0)}export(){throw new d.aQ}isSink(){return!0}}let dl=-1;class pl{constructor(e,i){let s=i<S.MATCH_MAX_DISTANCE;return this._index=s?e|0:dl,this._distance=s?+i:Number.POSITIVE_INFINITY,Object.freeze(this)}get index(){return this._index}get distance(){return this._distance}toString(){return`SpeedyKeypointMatch(${this.index},${this.distance})`}}class ai{constructor(e,i,s=0,l=0,p=0,h=null){this._position=new si(+e,+i),this._lod=+s,this._rotation=+l,this._score=+p,this._descriptor=h}toString(){return`SpeedyKeypoint(${this.x},${this.y})`}get position(){return this._position}get x(){return this._position.x}set x(e){this._position.x=+e}get y(){return this._position.y}set y(e){this._position.y=+e}get lod(){return this._lod}get scale(){return Math.pow(2,this._lod)}get rotation(){return this._rotation}get score(){return this._score}get descriptor(){return this._descriptor}}class ul extends ai{constructor(e,i,s=0,l=0,p=0,h=null,m=new Ve(0,0)){super(e,i,s,l,p,h),this._flow=m}get flow(){return this._flow}}class hl extends ai{constructor(e,i,s=0,l=0,p=0,h=null,m=[]){super(e,i,s,l,p,h),this._matches=m}get matches(){return this._matches}}let Kt=null,vo=0;class qt{constructor(){this._nodes=[],this._sequence=[],this._busy=!1}node(e){for(let i=0,s=this._nodes.length;i<s;i++)if(this._nodes[i].name===e)return this._nodes[i];return null}init(...e){if(this._nodes.length>0)throw new d.Er("The pipeline has already been initialized");if(e.length==0)throw new d.qw("Can't initialize the pipeline. Please specify its nodes");vo++==0&&(a.A.assert(!Kt,"Duplicate SpeedyGPU instance"),Kt=new qc);for(let i=0;i<e.length;i++){let s=e[i];this._nodes.includes(s)||this._nodes.push(s)}this._sequence=qt._tsort(this._nodes),qt._validateSequence(this._sequence);for(let i=0;i<this._sequence.length;i++)this._sequence[i].init(Kt);return this}release(){if(this._nodes.length==0)throw new d.Er("The pipeline has already been released or has never been initialized");for(let e=this._sequence.length-1;e>=0;e--)this._sequence[e].release(Kt);return this._sequence.length=0,this._nodes.length=0,--vo==0&&(Kt=Kt.release()),null}run(){if(a.A.assert(this._sequence.length>0,"The pipeline has not been initialized or has been released"),this._busy)return new c.i((s,l)=>{setTimeout(()=>this.run().then(s,l),0)});this._busy=!0;let e=this._sequence.filter(s=>s.isSink()),i=qt._createOutputTemplate(e);return A.w.logging==="diagnostic"&&a.A.log("%c RUNNING PIPELINE ","background:red;color:white;font-size:28pt;font-weight:bold"),qt._runSequence(this._sequence).then(()=>c.i.all(e.map(s=>s.export().turbocharge())).then(s=>s.reduce((l,p,h)=>(l[e[h].name]=p,l),i))).finally(()=>{for(let s=this._sequence.length-1;s>=0;s--)this._sequence[s].clearPorts();this._busy=!1,A.w.logging==="diagnostic"&&(a.A.log(`%c PIPELINE OUTPUT 
`,"background:green;color:white;font-size:16pt;font-weight:bold"),Object.keys(i).forEach(s=>{a.A.log("%c"+s+":","font-size:10pt;font-weight:bold",i[s])}))}).turbocharge()}get _gpu(){return Kt}static _runSequence(e,i=0,s=e.length){for(;i<s;i++){let l=e[i].execute(Kt);if(Kt.gl.flush(),typeof l<"u")return l.then(()=>qt._runSequence(e,i+1,s))}return c.i.resolve()}static _tsort(e){let i=qt._outlinks(e),s=e.map(m=>[m,!1]),l=new Set,p=new Array(e.length),h=p.length;for(;s.length>0;){let[m,P]=s.pop();if(P)p[--h]=m;else if(!l.has(m)){let v=i.get(m);if(l.add(m),s.push([m,!0]),s.push(...v.map(w=>[w,!1])),v.some(w=>l.has(w)&&!p.includes(w)))throw new d.Er("Pipeline networks cannot have cycles!")}}return p}static _outlinks(e){let i=new Map;for(let s=0;s<e.length;s++)i.set(e[s],[]);for(let s=0;s<e.length;s++){let l=e[s],p=l.inputNodes();for(let h=0;h<p.length;h++){let m=p[h],P=i.get(m);if(!P)throw new d.Er(`Can't initialize the pipeline. Missing node: ${m.fullName}. Did you forget to add it to the initialization list?`);P.includes(l)||P.push(l)}}return i}static _createOutputTemplate(e=[]){let i=Object.create(null);for(let s=e.length-1;s>=0;s--)i[e[s].name]=null;return i}static _validateSequence(e){if(e.length==0)throw new d.Er("Pipeline doesn't have nodes");if(e[0].isSource()){if(!e.find(i=>i.isSink()))throw new d.Er("Pipeline doesn't have a sink")}else throw new d.Er("Pipeline doesn't have a source")}}let gl=2;class fl extends Nn{constructor(e=void 0){super(e,gl,[fe().expects(O.Image)]),this._media=null,this._textureIndex=0}get media(){return this._media}set media(e){if(e!==null&&!(e instanceof sn))throw new d.qw(`Not a SpeedyMedia: ${e}`);this._media=e}_run(e){if(this._media==null)throw new d.Er(`Did you forget to set the media of ${this.fullName}?`);this._textureIndex=(this._textureIndex+1)%this._tex.length;let i=this._tex[this._textureIndex];e.upload(this._media._source,i),this.output().swrite(i,this._media._format)}}let ml="bitmap";class Il extends Cr{constructor(e="image"){super(e,0,[Ae().expects(O.Image)]),this._mediaType=ml,this._bitmap=null,this._data=null,this._format=de.f5.RGBA,this._textureReader=new x(1)}get mediaType(){return this._mediaType}set mediaType(e){if(e!="bitmap"&&e!="data")throw new d.qw(`Invalid mediaType for ${this.fullName}: "${e}"`);this._mediaType=e}init(e){super.init(e),this._textureReader.init(e)}release(e){this._textureReader.release(e),super.release(e)}export(){let e=this._mediaType!="data"?this._bitmap:this._data;return a.A.assert(e!=null),sn.load(e,{format:this._format},!1)}_run(e){let{image:i,format:s}=this.input().read();return this._mediaType!="data"?new c.i(l=>{let p=e.renderToCanvas(i);createImageBitmap(p,0,p.height-i.height,i.width,i.height).then(h=>{this._bitmap=h,this._format=s,this._data=null,l()})}):this._textureReader.readPixelsAsync(i,0,0,i.width,i.height,!1).then(l=>{let p=new Uint8ClampedArray(l.buffer);this._data=new ImageData(p,i.width,i.height),this._format=s,this._bitmap=null})}}let Pr=["in0","in1"];class _l extends Ee{constructor(e=void 0){super(e,0,[...Pr.map(i=>Ae(i).expects(O.Image)),fe().expects(O.Image)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=Pr.length)throw new d.qw(`Invalid port: ${e}`);this._port=e|0}_run(e){let i=this.input(Pr[this._port]).read();this.output().write(i)}}class yl extends Ee{constructor(e=void 0){super(e,2,[Ae().expects(O.Image),fe().expects(O.Image)]),this._pageIndex=0,this._initialized=!1,this._previousFormat=de.f5.RGBA,this._frozen=!1}get frozen(){return this._frozen}set frozen(e){this._frozen=!!e}release(e){this._initialized=!1,super.release(e)}_run(e){let{image:i,format:s}=this.input().read(),l=this._previousFormat,p=this._tex,h=p[1-this._pageIndex],m=p[this._pageIndex];if(i.hasMipmaps())throw new d.EM(`${this.fullName} can't bufferize a pyramid`);if((!this._frozen||!this._initialized)&&(this._previousFormat=s,h.resize(i.width,i.height),i.copyTo(h),this._pageIndex=1-this._pageIndex),!this._initialized){this._initialized=!0,this.output().swrite(h,s);return}this.output().swrite(m,l)}}let vr=S.PYRAMID_MAX_LEVELS,br=2*vr;class Sl extends Ee{constructor(e=void 0){super(e,br+1,[Ae().expects(O.Image),fe().expects(O.Image)])}_run(e){let{image:i,format:s}=this.input().read(),l=this._tex[0],p=e.programs.pyramids,h=i.width,m=i.height,P=1+Math.floor(Math.log2(Math.max(h,m))),v=new Array(br+1);for(let T=br;T>=1;T--)v[T-1]=this._tex[T];v[0].resize(h,m),i.copyTo(v[0]);let w=Math.min(P,vr);for(let T=1;T<w;T++){let k=Math.max(1,h>>>1),L=Math.max(1,m>>>1),H=T-1+vr;p.smoothX.outputs(h,m,v[H])(v[T-1]),p.smoothY.outputs(h,m,v[T-1])(v[H]),p.downsample2.outputs(k,L,v[T])(v[T-1]),e.gl.flush(),h=k,m=L}l.resize(i.width,i.height),l.clear(),i.copyTo(l),l.generateMipmaps(v.slice(0,w)),this.output().swrite(l,s)}}class El extends Ee{constructor(e=void 0){super(e,1,[Ae("in0").expects(O.Image),Ae("in1").expects(O.Image),fe().expects(O.Image)]),this._alpha=.5,this._beta=.5,this._gamma=0}get alpha(){return this._alpha}set alpha(e){this._alpha=+e}get beta(){return this._beta}set beta(e){this._beta=+e}get gamma(){return this._gamma}set gamma(e){this._gamma=+e}_run(e){let i=this.input("in0").read(),s=this.input("in1").read(),l=i.image,p=s.image,h=i.format,m=s.format,P=Math.max(l.width,p.width),v=Math.max(l.height,p.height),w=this._alpha,T=this._beta,k=this._gamma,L=this._tex[0];if(h!=m)throw new d.EM("Can't mix images of different formats");e.programs.transforms.additiveMix.outputs(P,v,L),e.programs.transforms.additiveMix(l,p,w,T,k),this.output().swrite(L,h)}}class bo extends Ee{constructor(e=void 0){super(e,1,[Ae().expects(O.Image)]),this._format=de.f5.RGBA,this._initialized=!1}get image(){if(!this._initialized)throw new d.Er(`Portal error: ${this.fullName} holds no data`);return this._tex[0]}get format(){if(!this._initialized)throw new d.Er(`Portal error: ${this.fullName} holds no data`);return this._format}init(e){super.init(e),this._tex[0].resize(1,1).clear(),this._format=de.f5.RGBA,this._initialized=!0}release(e){this._initialized=!1,super.release(e)}_run(e){let{image:i,format:s}=this.input().read(),l=this._tex[0];if(i.hasMipmaps())throw new d.EM(`${this.fullName} can't store a pyramid`);this._format=s,l.resize(i.width,i.height),i.copyTo(l)}}class xl extends Nn{constructor(e=void 0){super(e,0,[fe().expects(O.Image)]),this._source=null}get source(){return this._source}set source(e){if(e!==null&&!(e instanceof bo))throw new d.qw(`Incompatible source for ${this.fullName}`);this._source=e}_run(e){if(this._source==null)throw new d.Er(`${this.fullName} has no source`);this.output().swrite(this._source.image,this._source.format)}}class Cl extends Se.Q{static Source(e=void 0){return new xl(e)}static Sink(e=void 0){return new bo(e)}}class Pl extends Se.Q{static Source(e=void 0){return new fl(e)}static Sink(e=void 0){return new Il(e)}static Multiplexer(e=void 0){return new _l(e)}static Buffer(e=void 0){return new yl(e)}static Pyramid(e=void 0){return new Sl(e)}static Mixer(e=void 0){return new El(e)}static get Portal(){return Cl}}class vl extends Ee{constructor(e=void 0){super(e,1,[Ae().expects(O.Image),fe().expects(O.Image)])}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._tex[0],m=e.programs.filters;m.rgb2grey.outputs(l,p,h),m.rgb2grey(i),this.output().swrite(h,de.f5.GREY)}}let ci=Object.freeze({3:[.27901008925473514,.44197982149052983,.27901008925473514],5:[.06135959781344021,.2447701955296099,.3877404133138998,.2447701955296099,.06135959781344021],7:[.03873542500847274,.11308485700794121,.2150068609928349,.26634571398150225,.2150068609928349,.11308485700794121,.03873542500847274],9:[.028532262603370988,.067234535494912,.12400932997922749,.17904386461741617,.20236001461014655,.17904386461741617,.12400932997922749,.067234535494912,.028532262603370988],11:[.022656882730580346,.04610857898527292,.08012661469398517,.11890414969751599,.15067709325491124,.16305336127546846,.15067709325491124,.11890414969751599,.08012661469398517,.04610857898527292,.022656882730580346],13:[.018815730430644363,.03447396964662016,.05657737457255748,.08317258170844948,.10952340502389682,.12918787500405662,.13649812722755,.12918787500405662,.10952340502389682,.08317258170844948,.05657737457255748,.03447396964662016,.018815730430644363],15:[.016100340991695383,.027272329212157102,.042598338587449644,.06135478775568558,.08148767614129326,.09979838342934616,.11270444144735056,.11736740487004466,.11270444144735056,.09979838342934616,.08148767614129326,.06135478775568558,.042598338587449644,.027272329212157102,.016100340991695383]}),wr=new Ve(0,0),bl=Object.freeze({3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"}),wl=Object.freeze({3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"});class Ml extends Ee{constructor(e=void 0){super(e,2,[Ae().expects(O.Image),fe().expects(O.Image)]),this._kernelSize=new rt(5,5),this._sigma=wr,this._kernel={x:ci[this._kernelSize.width],y:ci[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){a.A.assert(e instanceof rt);let i=e.width,s=e.height;if(i<3||s<3||i>15||s>15||i%2==0||s%2==0)throw new d.EM(`Unsupported kernel size: ${i}x${s}`);this._kernelSize=e,this._updateKernel()}get sigma(){return this._sigma}set sigma(e){a.A.assert(e instanceof Ve,"Sigma must be a SpeedyVector2"),a.A.assert(e.x>=0&&e.y>=0),this._sigma=e,this._updateKernel()}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._kernel.x,m=this._kernel.y,P=bl[this._kernelSize.width],v=wl[this._kernelSize.height],w=this._tex[0],T=this._tex[1];e.programs.filters[P].outputs(l,p,w)(i,h),e.programs.filters[v].outputs(l,p,T)(w,m),this.output().swrite(T,s)}_updateKernel(){this._sigma.x==wr.x?this._kernel.x=ci[this._kernelSize.width]:this._kernel.x=a.A.gaussianKernel(this._sigma.x,this._kernelSize.width,!0),this._sigma.y==wr.y?this._kernel.y=ci[this._kernelSize.height]:this._kernel.y=a.A.gaussianKernel(this._sigma.y,this._kernelSize.height,!0)}}let li=Object.freeze({3:new Array(3).fill(1/3),5:new Array(5).fill(1/5),7:new Array(7).fill(1/7),9:new Array(9).fill(1/9),11:new Array(11).fill(1/11),13:new Array(13).fill(1/13),15:new Array(15).fill(1/15)}),Tl=Object.freeze({3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"}),Bl=Object.freeze({3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"});class Dl extends Ee{constructor(e=void 0){super(e,2,[Ae().expects(O.Image),fe().expects(O.Image)]),this._kernelSize=new rt(5,5),this._kernel={x:li[this._kernelSize.width],y:li[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){a.A.assert(e instanceof rt);let i=e.width,s=e.height;if(i<3||s<3||i>15||s>15||i%2==0||s%2==0)throw new d.EM(`Unsupported kernel size: ${i}x${s}`);this._kernelSize=e,this._kernel.x=li[this._kernelSize.width],this._kernel.y=li[this._kernelSize.height]}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._kernel.x,m=this._kernel.y,P=Tl[this._kernelSize.width],v=Bl[this._kernelSize.height],w=this._tex[0],T=this._tex[1];e.programs.filters[P].outputs(l,p,w)(i,h),e.programs.filters[v].outputs(l,p,T)(w,m),this.output().swrite(T,s)}}let Nl={3:"median3",5:"median5",7:"median7"};class Rl extends Ee{constructor(e=void 0){super(e,1,[Ae().expects(O.Image).satisfying(i=>i.format===de.f5.GREY),fe().expects(O.Image)]),this._kernelSize=new rt(5,5)}get kernelSize(){return this._kernelSize}set kernelSize(e){a.A.assert(e instanceof rt);let i=e.width;if(i==3||i==5||i==7){if(e.width!=e.height)throw new d.EM("Use a square kernel")}else throw new d.EM("Supported kernel sizes: 3x3, 5x5, 7x7");this._kernelSize=e}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._kernelSize.width,m=Nl[h],P=this._tex[0];e.programs.filters[m].outputs(l,p,P)(i),this.output().swrite(P,s)}}let kl={3:"convolution3",5:"convolution5",7:"convolution7"};class Ql extends Ee{constructor(e=void 0){super(e,1,[Ae().expects(O.Image),fe().expects(O.Image)]),this._kernel=Qt.SpeedyMatrix.Create(3,3,[0,0,0,0,1,0,0,0,0])}get kernel(){return this._kernel}set kernel(e){if(e.rows!=e.columns)throw new d.EM("Use a square kernel");if(!(e.rows==3||e.rows==5||e.rows==7))throw new d.EM("Invalid kernel size. Supported sizes: 3x3, 5x5, 7x7");this._kernel=e}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._tex[0],m=this._kernel.rows,P=kl[m],v=this._kernel.read();e.programs.filters[P].outputs(l,p,h)(i,v),this.output().swrite(h,s)}}class Kl extends Ee{constructor(e=void 0){super(e,3,[Ae().expects(O.Image).satisfying(i=>i.format===de.f5.RGBA||i.format===de.f5.GREY),fe().expects(O.Image)]),this._gain=.5,this._offset=.5,this._decay=0,this._quality="medium"}get gain(){return this._gain}set gain(e){this._gain=+e}get offset(){return this._offset}set offset(e){this._offset=+e}get decay(){return this._decay}set decay(e){this._decay=Math.max(0,Math.min(+e,1))}get quality(){return this._quality}set quality(e){if(e==="high"||e==="medium"||e==="low")this._quality=e;else throw new d.qw(`Invalid quality level for the Nightvision filter: "${e}"`)}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._gain,m=this._offset,P=this._decay,v=this._quality,w=e.programs.filters,T=this._tex[0],k=this._tex[1],L=this._tex[2];v=="medium"?(w.illuminationMapX.outputs(l,p,T),w.illuminationMapY.outputs(l,p,k),w.illuminationMapX(i),w.illuminationMapY(T)):v=="high"?(w.illuminationMapHiX.outputs(l,p,T),w.illuminationMapHiY.outputs(l,p,k),w.illuminationMapHiX(i),w.illuminationMapHiY(T)):v=="low"&&(w.illuminationMapLoX.outputs(l,p,T),w.illuminationMapLoY.outputs(l,p,k),w.illuminationMapLoX(i),w.illuminationMapLoY(T)),s===de.f5.GREY?(w.nightvisionGreyscale.outputs(l,p,L),w.nightvisionGreyscale(i,k,h,m,P)):s===de.f5.RGBA&&(w.nightvision.outputs(l,p,L),w.nightvision(i,k,h,m,P)),this.output().swrite(L,s)}}class Ll extends Ee{constructor(e=void 0){super(e,4,[Ae().expects(O.Image).satisfying(i=>i.format===de.f5.GREY),fe().expects(O.Image)]),this._minValue=0,this._maxValue=255}get minValue(){return this._minValue}set minValue(e){this._minValue=Math.max(0,Math.min(+e,255))}get maxValue(){return this._maxValue}set maxValue(e){this._maxValue=Math.max(0,Math.min(+e,255))}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._tex[3],m=this._minValue,P=this._maxValue;m>P&&(m=P=(m+P)/2);let v=this._scanMinMax(e,i,de.kQ.GREEN);e.programs.filters.normalizeGreyscale.outputs(l,p,h),e.programs.filters.normalizeGreyscale(v,m,P),this.output().swrite(h,s)}_scanMinMax(e,i,s){let l=this._tex,p=e.programs.utils,h=i.width,m=i.height,P=Math.ceil(Math.log2(Math.max(h,m)))|0;a.A.assert(de.kg[s]!==void 0),p.copyComponents.outputs(h,m,l[2]),p.scanMinMax2D.outputs(h,m,l[0],l[1]);let v=p.copyComponents(i,i,de.kQ.ALL,de.kg[s]);for(let w=0;w<P;w++)v=p.scanMinMax2D(v,w);return v}}class Ol extends Se.Q{static Greyscale(e=void 0){return new vl(e)}static GaussianBlur(e=void 0){return new Ml(e)}static SimpleBlur(e=void 0){return new Dl(e)}static MedianBlur(e=void 0){return new Rl(e)}static Convolution(e=void 0){return new Ql(e)}static Nightvision(e=void 0){return new Kl(e)}static Normalize(e=void 0){return new Ll(e)}}let zl=[0,0,0,0,0,0,0,0,1];class Fl extends Ee{constructor(e=void 0){super(e,1,[Ae().expects(O.Image),fe().expects(O.Image)]),this._transform=Qt.SpeedyMatrix.Create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(!(e.rows==3&&e.columns==3))throw new d.qw(`Not a 3x3 transformation matrix: ${e}`);this._transform=e}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._tex[0],m=this._transform.read(),P=this._inverse3(m),v=!Number.isNaN(P[0]);e.programs.transforms.warpPerspective.outputs(l,p,h),e.programs.transforms.warpPerspective(i,v?P:zl),this.output().swrite(h,s)}_inverse3(e,i=1e-6){let s=e[0],l=e[1],p=e[2],h=e[3],m=e[4],P=e[5],v=e[6],w=e[7],T=e[8],k=T*m-P*w,L=T*h-P*v,H=w*h-m*v,Y=s*k-l*L+p*H;if(Math.abs(Y)<i)e.fill(Number.NaN,0,9);else{let re=1/Y;e[0]=k*re,e[1]=-(T*l-p*w)*re,e[2]=(P*l-p*m)*re,e[3]=-L*re,e[4]=(T*s-p*v)*re,e[5]=-(P*s-p*h)*re,e[6]=H*re,e[7]=-(w*s-l*v)*re,e[8]=(m*s-l*h)*re}return e}}class Ul extends Ee{constructor(e=void 0){super(e,1,[Ae().expects(O.Image),fe().expects(O.Image)]),this._size=new rt(0,0),this._scale=new Ve(1,1),this._method="bilinear"}get size(){return this._size}set size(e){this._size=e}get scale(){return this._scale}set scale(e){this._scale=e}get method(){return this._method}set method(e){if(e!=="nearest"&&e!=="bilinear")throw new d.qw(`Invalid method method: "${e}"`);this._method=e}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._tex[0],m=this._method,P=this._size.width||Math.max(1,this._scale.x*l),v=this._size.height||Math.max(1,this._scale.y*p);m=="bilinear"?e.programs.transforms.resizeBilinear.outputs(P,v,h)(i):m=="nearest"&&e.programs.transforms.resizeNearest.outputs(P,v,h)(i),this.output().swrite(h,s)}}class Xl extends Se.Q{static Resize(e=void 0){return new Ul(e)}static PerspectiveWarp(e=void 0){return new Fl(e)}}let Gl=S.MAX_ENCODER_CAPACITY,Hl=S.DEFAULT_ENCODER_CAPACITY,ql=1.4142135623730951,Wl=2,Mr=0,wo=4,Yl=2;class ke extends Ee{constructor(e=void 0,i=0,s=void 0){super(e,i+Mr,s),this._capacity=Hl,this._oldWrapS=0,this._tex16=new Array(Wl).fill(null)}init(e){super.init(e),this._oldWrapS=this._setupSpecialTexture(e.gl.TEXTURE_WRAP_S,e.gl.REPEAT),this._allocateTex16(e),e.subscribe(this._allocateTex16,this,e)}release(e){e.unsubscribe(this._allocateTex16,this),this._deallocateTex16(e),this._setupSpecialTexture(e.gl.TEXTURE_WRAP_S,this._oldWrapS),super.release(e)}_setupSpecialTexture(e,i){if(Mr==0)return;let s=this._tex[this._tex.length-1],l=s.gl;l.bindTexture(l.TEXTURE_2D,s.glTexture);let p=l.getTexParameter(l.TEXTURE_2D,e);return l.texParameteri(l.TEXTURE_2D,e,i),l.bindTexture(l.TEXTURE_2D,null),p}get capacity(){return this._capacity}set capacity(e){this._capacity=Math.min(Math.max(0,e|0),Gl)}_encodeKeypoints(e,i,s,l=0,p=0){let h=this._capacity,m=ke.encoderLength(h,l,p),P=1<<(Math.ceil(Math.log2(i.width*i.height))>>>1),v=Math.ceil(i.width*i.height/P),w=Math.max(P,v),T=e.programs.keypoints;T.initLookupTable.outputs(P,v,this._tex16[1]),T.sortLookupTable.outputs(P,v,this._tex16[0],this._tex16[1]),T.encodeKeypoints.outputs(m,m,s);let k=T.initLookupTable(i);for(let L=1;L<w;L*=2)k=T.sortLookupTable(k,L,P,v);return T.encodeKeypoints(i,k,P,l,p,m,h)}_encodeKeypointsOLD(e,i,s,l=0,p=0){let h=this._capacity,m=ke.encoderLength(h,l,p),P=i.width,v=i.height,w=[P,v],T=this._tex.slice(this._tex.length-Mr),k=e.programs.keypoints,L=T.pop();k.encodeKeypointSkipOffsets.outputs(P,v,T[0]),k.encodeKeypointLongSkipOffsets.outputs(P,v,T[1],T[0]),k.encodeKeypointPositions.outputs(m,m,T[2],T[3]),k.encodeKeypointProperties.outputs(m,m,s),i=e.programs.utils.copy.outputs(P,v,L)(i);let H=k.encodeKeypointSkipOffsets(i,w);for(let re=0;re<Yl;re++)H=k.encodeKeypointLongSkipOffsets(H,w);let Y=T[3].clear();for(let re=0;re<wo;re++)Y=k.encodeKeypointPositions(H,w,re,wo,h,Y,l,p,m);return k.encodeKeypointProperties(i,Y,l,p,m)}_encodeZeroKeypoints(e,i,s=0,l=0){let h=ke.encoderLength(0,s,l),m=e.programs.keypoints;return m.encodeNullKeypoints.outputs(h,h,i),m.encodeNullKeypoints()}_allocateTex16(e){let i=e.gl;for(let s=0;s<this._tex16.length;s++)this._tex16[s]=new N(i,1,1,i.RGBA_INTEGER,i.RGBA16UI,i.UNSIGNED_SHORT,i.NEAREST,i.CLAMP_TO_EDGE)}_deallocateTex16(e){for(let i=0;i<this._tex16.length;i++)this._tex16[i]=this._tex16[i].release()}static encoderLength(e,i,s){let l=Math.ceil((S.MIN_KEYPOINT_SIZE+i+s)/4),p=e*l;return Math.max(S.MIN_ENCODER_LENGTH,Math.ceil(Math.sqrt(p)))}static encoderCapacity(e,i,s){let l=Math.ceil((S.MIN_KEYPOINT_SIZE+e+i)/4),p=s*s;return Math.floor(p/l)}}class Mo extends ke{constructor(e=void 0,i=void 0,s=void 0){super(e,i,s),this._levels=1,this._scaleFactor=ql}get levels(){return this._levels}set levels(e){this._levels=Math.max(1,e|0)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.max(1,Math.min(+e,2))}}let Vl=16384,Tr=1024,Jl=Float32Array.BYTES_PER_ELEMENT*4;class Ai extends Nn{constructor(e=void 0){super(e,2,[fe().expects(O.Keypoints)]),this._keypoints=[],this._buffer=Ai._createUploadBuffer(Tr),this._capacity=S.DEFAULT_ENCODER_CAPACITY}get keypoints(){return this._keypoints}set keypoints(e){if(!Array.isArray(e))throw new d.qw("Not an array of keypoints");this._keypoints=e}get capacity(){return this._capacity}set capacity(e){this._capacity=Math.min(Math.max(0,e|0),S.MAX_ENCODER_CAPACITY)}_run(e){let l=this._keypoints,p=this._capacity,h=Math.min(l.length,p),m=Math.max(1,Math.ceil(h/Tr)),P=this._buffer,v=e.programs.keypoints.uploadKeypoints,w=ke.encoderLength(p,0,0);v.outputs(w,w,this._tex[0],this._tex[1]);let T=0,k=v.clear();for(let L=0;L<m;L++){let H=Math.min(Tr,h-T),Y=T+H;v.setUBO("KeypointBuffer",Ai._fillUploadBuffer(P,l,T,Y)),k=v(k,T,Y,0,0,w),T=Y}this.output().swrite(k,0,0,w)}static _createUploadBuffer(e){let i=new ArrayBuffer(Jl*e);return a.A.assert(i.byteLength<=Vl),new Float32Array(i)}static _fillUploadBuffer(e,i,s,l){let p=l-s;for(let h=0;h<p;h++){let m=i[s+h],P=m.position!==void 0,v=h*4;e[v]=+(P?m.position.x:m.x)||0,e[v+1]=+(P?m.position.y:m.y)||0,e[v+2]=+m.lod||0,e[v+3]=+m.score||0}return e}}class Br{constructor(e){return this._data=e,Object.freeze(this)}get data(){return this._data}get size(){return this._data.byteLength}toString(){return`SpeedyKeypointDescriptor(${this._data.join(",")})`}}let jl=C=>C>1?1<<Math.ceil(Math.log2(C)):1,To=new Uint8Array([]);class Dr extends Cr{constructor(e="keypoints",i=0,s=[]){super(e,i+2,s),this._keypoints=[],this._textureReader=new x,this._page=0,this._turbo=!1,this._includeDiscarded=!1}get turbo(){return this._turbo}set turbo(e){this._turbo=!!e}get includeDiscarded(){return this._includeDiscarded}set includeDiscarded(e){this._includeDiscarded=!!e}init(e){super.init(e),this._textureReader.init(e)}release(e){this._textureReader.release(e),super.release(e)}export(){return c.i.resolve(this._keypoints)}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read();return this._download(e,i,s,l,p)}_download(e,i,s,l,p){let h=this._turbo,m=jl(p),P=Math.ceil(p*p/m),v=this._tex[this._tex.length-1-this._page];return e.programs.utils.copyKeypoints.outputs(m,P,v)(i),this._page=1-this._page,this._textureReader.readPixelsAsync(v,0,0,v.width,v.height,h).then(w=>{this._keypoints=this._decode(w,s,l,m,P)})}_decode(e,i,s,l,p){let h=S.MIN_KEYPOINT_SIZE+i+s,m=S.LOG2_PYRAMID_MAX_SCALE,P=S.PYRAMID_MAX_LEVELS,v=Math.PI/255,w=[],T=this._includeDiscarded,k=To,L=To,H,Y,re,De,Qe,xe,Ce,Je;if(i%4!=0||s%4!=0)throw new d.qw(`Invalid descriptorSize (${i}) / extraSize (${s})`);let je=l*p*4,st=e.byteLength;st!=je&&a.A.warning(`Expected ${je} bytes when decoding a set of keypoints, found ${st}`),i+s>0&&(e=new Uint8Array(e));for(let ue=0;ue<st&&(H=e[ue+1]<<8|e[ue],Y=e[ue+3]<<8|e[ue+2],re=e[ue+5]<<8|e[ue+4],De=e[ue+7]<<8|e[ue+6],!(H==65535&&Y==65535));ue+=h){if(H+Y+re+De==0){T&&w.push(null);continue}if(s>0&&(L=e.subarray(8+ue,8+ue+s),L.byteLength<s)){a.A.warning(`KeypointSink: expected ${s} extra bytes when decoding the ${ue/h}-th keypoint, found ${L.byteLength} instead`);continue}if(i>0&&(k=e.subarray(8+ue+s,8+ue+s+i),k.byteLength<i)){a.A.warning(`KeypointSink: expected ${i} descriptor bytes when decoding the ${ue/h}-th keypoint, found ${k.byteLength} instead`);continue}H/=S.FIX_RESOLUTION,Y/=S.FIX_RESOLUTION,Qe=e[ue+4]<255?-m+(m+P)*e[ue+4]/255:0,xe=(2*e[ue+5]-255)*v,Ce=a.A.decodeFloat16(De),Je=this._createKeypoint(H,Y,Qe,xe,Ce,k,L),w.push(Je)}return w}_createKeypoint(e,i,s,l,p,h,m){throw new d.aQ}_allocateExtra(e,i,s,l,p,h,m){a.A.assert(p===0),a.A.assert(h===l&&m>0&&m%4===0);let P=s.width,w=ke.encoderCapacity(l,p,P),T=ke.encoderLength(w,h,m);return e.programs.keypoints.allocateExtra.outputs(T,T,i)(s,l,p,P,h,m,T)}}class Zl extends Dr{constructor(e="keypoints"){super(e,0,[Ae().expects(O.Keypoints)])}_createKeypoint(e,i,s,l,p,h,m){let v=h.byteLength>0?new Br(h):null;return new ai(e,i,s,l,p,v)}}class $l extends Dr{constructor(e="keypoints"){super(e,2,[Ae().expects(O.Keypoints).satisfying(i=>i.extraSize==0),Ae("flow").expects(O.Vector2)])}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read(),{vectors:h}=this.input("flow").read(),m=s,P=4,v=this._allocateExtra(e,this._tex[0],i,s,l,m,P),w=v.width,T=e.programs.keypoints.transferToExtra.outputs(w,w,this._tex[1])(h,h.width,v,m,P,w);return this._download(e,T,m,P,w)}_createKeypoint(e,i,s,l,p,h,m){let P=h.byteLength,v=m.byteLength,w=P>0?new Br(h):null,T=a.A.decodeFloat16(m[1]<<8|m[0]),k=a.A.decodeFloat16(m[3]<<8|m[2]),L=new Ve(T,k);return new ul(e,i,s,l,p,w,L)}}class eA extends Dr{constructor(e="keypoints"){super(e,2,[Ae().expects(O.Keypoints).satisfying(i=>i.extraSize==0),Ae("matches").expects(O.KeypointMatches)])}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read(),{encodedMatches:h,matchesPerKeypoint:m}=this.input("matches").read(),P=s,v=m*4,w=this._allocateExtra(e,this._tex[0],i,s,l,P,v),T=w.width,k=e.programs.keypoints.transferToExtra.outputs(T,T,this._tex[1])(h,h.width,w,P,v,T);return this._download(e,k,P,v,T)}_createKeypoint(e,i,s,l,p,h,m){let P=h.byteLength,v=m.byteLength,w=P>0?new Br(h):null,T=v/4,k=new Array(T);for(let L=0;L<T;L++){let H=L*4,Y=m[H]|m[H+1]<<8|m[H+2]<<16|m[H+3]<<24,re=new pl(Y&S.MATCH_INDEX_MASK,Y>>>S.MATCH_INDEX_BITS);k[L]=re}return new hl(e,i,s,l,p,w,k)}}let tA=5,Bo=S.MAX_ENCODER_CAPACITY;class nA extends Ee{constructor(e=void 0){super(e,4,[Ae().expects(O.Keypoints),fe().expects(O.Keypoints)]),this._size=Bo}get size(){return this._size}set size(e){this._size=Math.max(0,Math.min(e|0,Bo))}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read(),h=e.programs.keypoints,m=this._size,P=this._tex,v=this._tex[3],w=ke.encoderCapacity(s,l,p),T=1<<tA,k=Math.ceil(w/T),L=T*k,H=Math.min(w,m),Y=ke.encoderLength(H,s,l);h.sortCreatePermutation.outputs(T,k,P[0]);let re=h.sortCreatePermutation(i,s,l,p),De=Math.ceil(Math.log2(L));h.sortMergePermutation.outputs(T,k,P[1],P[2]);for(let Qe=1;Qe<=De;Qe++){let xe=1<<Qe,Ce=Qe<<1;re=h.sortMergePermutation(re,xe,Ce)}h.sortApplyPermutation.outputs(Y,Y,v),h.sortApplyPermutation(re,H,i,s,l),this.output().swrite(v,s,l,Y)}}class iA extends Ee{constructor(e=void 0){super(e,5,[Ae().expects(O.Keypoints),fe().expects(O.Keypoints)]),this._imageSize=new rt(0,0),this._borderSize=new Ve(0,0)}get imageSize(){return this._imageSize}set imageSize(e){this._imageSize=e}get borderSize(){return this._borderSize}set borderSize(e){this._borderSize=e}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read(),h=e.programs.keypoints,m=this._imageSize,P=this._borderSize,v=m.width,w=m.height,T=P.x,k=P.x,L=P.y,H=P.y,Y=this._tex;if(v==0||w==0)throw new d.Er("BorderClipper: did you forget to set the image size?");let re=ke.encoderCapacity(s,l,p),De=Math.max(1,Math.ceil(Math.sqrt(re)));h.clipBorder.outputs(p,p,Y[0]),h.mixKeypointsInit.outputs(De,De,Y[1]),h.mixKeypointsSort.outputs(De,De,Y[2],Y[3]),h.mixKeypointsApply.outputs(p,p,Y[4]);let Qe=h.clipBorder(v,w,L,k,H,T,i,s,l,p),xe=h.mixKeypointsInit(Qe,s,l,p,re);for(let Ce=1;Ce<re;Ce*=2)xe=h.mixKeypointsSort(xe,Ce);Qe=h.mixKeypointsApply(xe,Qe,s,l,p),this.output().swrite(Qe,s,l,p)}}class rA extends Ee{constructor(e=void 0){super(e,2,[Ae().expects(O.Keypoints),fe().expects(O.Keypoints)]),this._pageIndex=0,this._initialized=!1,this._previousDescriptorSize=0,this._previousExtraSize=0,this._previousEncoderLength=0,this._frozen=!1}get frozen(){return this._frozen}set frozen(e){this._frozen=!!e}release(e){this._initialized=!1,super.release(e)}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read(),h=this._previousDescriptorSize,m=this._previousExtraSize,P=this._previousEncoderLength,v=this._tex,w=v[1-this._pageIndex],T=v[this._pageIndex];if((!this._frozen||!this._initialized)&&(this._previousDescriptorSize=s,this._previousExtraSize=l,this._previousEncoderLength=p,w.resize(p,p),i.copyTo(w),this._pageIndex=1-this._pageIndex),!this._initialized){this._initialized=!0,this.output().swrite(w,s,l,p);return}this.output().swrite(T,h,m,P)}}class oA extends Ee{constructor(e=void 0){super(e,5,[Ae("in0").expects(O.Keypoints),Ae("in1").expects(O.Keypoints),fe().expects(O.Keypoints)])}_run(e){let i=this.input("in0").read(),s=this.input("in1").read(),l=i.descriptorSize,p=i.extraSize,h=e.programs.keypoints,m=this._tex;if(!(i.descriptorSize===s.descriptorSize&&i.extraSize===i.extraSize))throw new d.Er("Can't merge two sets of keypoints that have different formats");let P=ke.encoderCapacity(i.descriptorSize,i.extraSize,i.encoderLength),v=ke.encoderCapacity(s.descriptorSize,s.extraSize,s.encoderLength),w=P+v,T=ke.encoderLength(w,l,p),k=Math.max(1,Math.ceil(Math.sqrt(w)));h.mixKeypointsPreInit.outputs(T,T,m[0]),h.mixKeypointsInit.outputs(k,k,m[1]),h.mixKeypointsSort.outputs(k,k,m[2],m[3]),h.mixKeypointsApply.outputs(T,T,m[4]);let L=h.mixKeypointsPreInit(i.encodedKeypoints,s.encodedKeypoints,i.encoderLength,s.encoderLength,P,v,l,p,T),H=h.mixKeypointsInit(L,l,p,T,w);for(let Y=1;Y<w;Y*=2)H=h.mixKeypointsSort(H,Y);L=h.mixKeypointsApply(H,L,l,p,T),this.output().swrite(L,l,p,T)}}class sA extends Ee{constructor(e=void 0){super(e,6,[Ae().expects(O.Keypoints),fe().expects(O.Keypoints)]),this._maxKeypoints=Number.NaN}get maxKeypoints(){return this._maxKeypoints}set maxKeypoints(e){Number.isNaN(e)?this._maxKeypoints=Number.NaN:this._maxKeypoints=Math.max(0,e|0)}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read(),h=ke.encoderCapacity(s,l,p),m=this._maxKeypoints,P=e.programs.keypoints.shuffle.definedConstant("PERMUTATION_MAXLEN"),v=Math.min(P,h),w=this._generatePermutation(v,P);i=e.programs.keypoints.shuffle.setUBO("Permutation",w).outputs(p,p,this._tex[0])(i,s,l,p),e.programs.keypoints.mixKeypointsInit.outputs(p,p,this._tex[1]),e.programs.keypoints.mixKeypointsSort.outputs(p,p,this._tex[2],this._tex[3]),e.programs.keypoints.mixKeypointsApply.outputs(p,p,this._tex[4]);let T=e.programs.keypoints.mixKeypointsInit(i,s,l,p,h);for(let k=1;k<h;k*=2)T=e.programs.keypoints.mixKeypointsSort(T,k);if(i=e.programs.keypoints.mixKeypointsApply(T,i,s,l,p),!Number.isNaN(m)&&m<h){let k=ke.encoderLength(m,s,l);i=e.programs.keypoints.clip.outputs(k,k,this._tex[5])(i,s,l,p,m),p=k}this.output().swrite(i,s,l,p)}_generatePermutation(e,i=e){let s=new Int32Array(i),l=s.subarray(0,e).fill(-1),p=a.A.shuffle(a.A.range(e));for(let h=0,m=0;h<e;h++)if(l[h]<0){do l[h]=p[m++];while(l[h]<h);l[l[h]]=h}return s}}let Nr=["in0","in1"];class aA extends Ee{constructor(e=void 0){super(e,0,[...Nr.map(i=>Ae(i).expects(O.Keypoints)),fe().expects(O.Keypoints)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=Nr.length)throw new d.qw(`Invalid port: ${e}`);this._port=e|0}_run(e){let i=this.input(Nr[this._port]).read();this.output().write(i)}}class cA extends Ee{constructor(e=void 0){super(e,1,[Ae().expects(O.Keypoints),fe().expects(O.Keypoints)]),this._transform=Qt.SpeedyMatrix.Create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(!(e.rows==3&&e.columns==3))throw new d.qw(`Not a 3x3 transformation matrix: ${e}`);this._transform=e}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read(),h=this._tex[0],m=this._transform.read();e.programs.keypoints.applyHomography.outputs(i.width,i.height,h)(m,i,s,l,p),this.output().swrite(h,s,l,p)}}let Do=Object.freeze({quadratic1d:"subpixelQuadratic1d",taylor2d:"subpixelTaylor2d","bicubic-upsample":"subpixelBicubic","bilinear-upsample":"subpixelBilinear"});class lA extends Ee{constructor(e=void 0){super(e,2,[Ae("image").expects(O.Image).satisfying(i=>i.format===de.f5.GREY),Ae("keypoints").expects(O.Keypoints),fe().expects(O.Keypoints),fe("displacements").expects(O.Vector2)]),this._method="quadratic1d",this._maxIterations=6,this._epsilon=.1}get method(){return this._method}set method(e){if(!Object.prototype.hasOwnProperty.call(Do,e))throw new d.qw(`Invalid method: "${e}"`);this._method=e}get maxIterations(){return this._maxIterations}set maxIterations(e){this._maxIterations=Math.max(0,+e)}get epsilon(){return this._epsilon}set epsilon(e){this._epsilon=Math.max(0,+e)}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input("keypoints").read(),{image:h,format:m}=this.input("image").read(),P=this._tex,v=Do[this._method],w=this._maxIterations,T=this._epsilon,k=ke.encoderCapacity(s,l,p),L=Math.max(1,Math.ceil(Math.sqrt(k))),H=e.programs.keypoints[v].outputs(L,L,P[0])(h,i,s,l,p,w,T),Y=e.programs.keypoints.transferFlow.outputs(p,p,P[1])(H,i,s,l,p);this.output().swrite(Y,s,l,p),this.output("displacements").swrite(H)}}let AA=20;class dA extends Mo{constructor(e=void 0){super(e,5,[Ae().expects(O.Image).satisfying(i=>i.format===de.f5.GREY),fe().expects(O.Keypoints)]),this._threshold=AA}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,Math.min(e|0,255))}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._tex,m=this._capacity,P=this._threshold,v=Math.log2(this.scaleFactor),w=this.levels;if(!(w==1||i.hasMipmaps()))throw new d.Er(`Expected a pyramid in ${this.fullName}`);if(m==0){let Y=this._encodeZeroKeypoints(e,h[4]),re=Y.width;this.output().swrite(Y,0,0,re);return}e.programs.keypoints.fast9_16.outputs(l,p,h[0],h[1]),e.programs.keypoints.nonmaxSpace.outputs(l,p,h[2]);let T=h[1].clear(),k=Math.max(1,Math.min(w,S.PYRAMID_MAX_LEVELS/v|0));for(let Y=v*(k-1);k-- >0;Y-=v)T=e.programs.keypoints.fast9_16(T,i,Y,P);T=e.programs.keypoints.nonmaxSpace(T),w>1&&(T=e.programs.keypoints.nonmaxScaleSimple.outputs(l,p,h[1])(T,i,v));let L=this._encodeKeypoints(e,T,h[3]),H=L.width;w>1&&(L=e.programs.keypoints.refineScaleFAST916.outputs(H,H,h[4])(i,v,L,0,0,H,P)),this.output().swrite(L,0,0,H)}}let pA=Object.freeze({1:"harris1",3:"harris3",5:"harris5",7:"harris7"});class uA extends Mo{constructor(e=void 0){super(e,6,[Ae().expects(O.Image).satisfying(i=>i.format===de.f5.GREY),fe().expects(O.Keypoints)]),this._windowSize=new rt(3,3),this._quality=.1}get quality(){return this._quality}set quality(e){this._quality=Math.max(0,Math.min(+e,1))}get windowSize(){return this._windowSize}set windowSize(e){let i=e.width;if(!(i==e.height&&(i==1||i==3||i==5||i==7)))throw new d.qw(`Invalid window: ${e}. Acceptable sizes: 1x1, 3x3, 5x5, 7x7`);this._windowSize=e}_run(e){let{image:i,format:s}=this.input().read(),l=i.width,p=i.height,h=this._capacity,m=this._quality,P=this._windowSize.width,v=this.levels,w=Math.log2(this.scaleFactor),T=v>1?this.scaleFactor:1,k=e.programs.keypoints[pA[P]],L=this._tex;if(!(v==1||i.hasMipmaps()))throw new d.Er(`Expected a pyramid in ${this.fullName}`);if(h==0){let xe=this._encodeZeroKeypoints(e,L[5]),Ce=xe.width;this.output().swrite(xe,0,0,Ce);return}k.outputs(l,p,L[0],L[1]),e.programs.utils.sobelDerivatives.outputs(l,p,L[2]),e.programs.keypoints.nonmaxSpace.outputs(l,p,L[3]);let H=L[1].clear(),Y=Math.max(1,Math.min(v,S.PYRAMID_MAX_LEVELS/w|0));for(let xe=w*(Y-1);Y-- >0;xe-=w){let Ce=a.A.gaussianKernel(T*(1+xe),P),Je=e.programs.utils.sobelDerivatives(i,xe);H=k(H,i,Je,xe,w,Ce),H=e.programs.keypoints.nonmaxSpace(H)}if(v>1){let xe=e.programs.keypoints.laplacian.outputs(l,p,L[0])(H,i,w,0);H=e.programs.keypoints.nonmaxScale.outputs(l,p,L[2])(H,i,xe,w)}e.programs.keypoints.harrisScoreFindMax.outputs(l,p,L[0],L[1]),Y=Math.ceil(Math.log2(Math.max(l,p)));let re=H;for(let xe=0;xe<Y;xe++)re=e.programs.keypoints.harrisScoreFindMax(re,xe);H=e.programs.keypoints.harrisScoreCutoff.outputs(l,p,re==L[0]?L[1]:L[0])(H,re,m);let De=this._encodeKeypoints(e,H,L[4]),Qe=De.width;v>1&&(De=e.programs.keypoints.refineScaleLoG.outputs(Qe,Qe,L[5])(i,w,De,0,0,Qe)),this.output().swrite(De,0,0,Qe)}}class hA extends Ee{constructor(e=void 0,i=0,s=void 0){super(e,i+1,s)}_allocateDescriptors(e,i,s,l,p,h){a.A.assert(i>=0&&s>=0),a.A.assert(l>=0&&l%4===0&&p===s);let m=h.width,v=ke.encoderCapacity(i,s,m),w=ke.encoderLength(v,l,p),T=this._tex[this._tex.length-1];return e.programs.keypoints.allocateDescriptors.outputs(w,w,T)(h,i,s,m,l,p,w)}}let No=32;class gA extends hA{constructor(e=void 0){super(e,3,[Ae("image").expects(O.Image).satisfying(i=>i.format===de.f5.GREY),Ae("keypoints").expects(O.Keypoints),fe().expects(O.Keypoints)])}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input("keypoints").read(),h=this.input("image").read().image,m=this._tex,P=this._tex[2],v=ke.encoderCapacity(s,l,p),w=Math.max(1,Math.ceil(Math.sqrt(v))),T=e.programs.keypoints.orbOrientation.outputs(w,w,m[0])(h,i,s,l,p),k=e.programs.keypoints.transferOrientation.outputs(p,p,m[1])(T,i,s,l,p),L=this._allocateDescriptors(e,s,l,No,l,k),H=L.width,Y=e.programs.keypoints.orbDescriptor.outputs(H,H,P)(h,L,l,H);this.output().swrite(Y,No,l,H)}}let fA=new rt(11,11),mA=Math.min(3,S.PYRAMID_MAX_LEVELS),IA=30,_A=1e-4,yA=.01,Rr={3:"lk3",5:"lk5",7:"lk7",9:"lk9",11:"lk11",13:"lk13",15:"lk15",17:"lk17",19:"lk19",21:"lk21"};class SA extends Ee{constructor(e=void 0){super(e,3,[Ae("previousImage").expects(O.Image).satisfying(i=>i.format===de.f5.GREY),Ae("nextImage").expects(O.Image).satisfying(i=>i.format===de.f5.GREY),Ae("previousKeypoints").expects(O.Keypoints),fe().expects(O.Keypoints),fe("flow").expects(O.Vector2)]),this._windowSize=fA,this._levels=mA,this._discardThreshold=_A,this._numberOfIterations=IA,this._epsilon=yA}get windowSize(){return this._windowSize}set windowSize(e){if(e.width!=e.height)throw new d.EM(`LK: window ${this._windowSize.toString()} is not square!`);if(!Object.prototype.hasOwnProperty.call(Rr,e.width)){let i=Object.keys(Rr).sort((s,l)=>s-l).map(s=>s+"x"+s).join(", ");throw new d.EM(`LK: window of size ${this._windowSize.toString()} is not supported! Supported sizes: ${i}`)}this._windowSize=e}get levels(){return this._levels}set levels(e){a.A.assert(e>=1&&e<=S.PYRAMID_MAX_LEVELS),this._levels=e|0}get discardThreshold(){return this._discardThreshold}set discardThreshold(e){a.A.assert(e>=0),this._discardThreshold=+e}get numberOfIterations(){return this._numberOfIterations}set numberOfIterations(e){a.A.assert(e>=1),this._numberOfIterations=e|0}get epsilon(){return this._epsilon}set epsilon(e){a.A.assert(e>=0),this._epsilon=+e}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input("previousKeypoints").read(),h=this.input("previousImage").read().image,m=this.input("nextImage").read().image,P=i,v=this._levels,T=this._windowSize.width,k=this._numberOfIterations,L=this._discardThreshold,H=this._epsilon,Y=e.programs.keypoints,re=this._tex;if(v==1||h.hasMipmaps()&&m.hasMipmaps()){if(h.width!==m.width||h.height!==m.height)throw new d.Er("LK: can't use input images of different size")}else throw new d.Er("LK: a pyramid is required if levels > 1");let De=Y[Rr[T]],Qe=ke.encoderCapacity(s,l,p),xe=Math.max(1,Math.ceil(Math.sqrt(Qe)));De.outputs(xe,xe,re[0],re[1]);let Ce=De.clear();for(let je=v-1;je>=0;je--)Ce=De(Ce,P,m,h,je,v,k,L,H,s,l,p);Y.transferFlow.outputs(p,p,re[2]);let Je=Y.transferFlow(Ce,P,s,l,p);this.output().swrite(Je,s,l,p),this.output("flow").swrite(Ce)}}class EA extends Nn{constructor(e=void 0){super(e,2,[fe().expects(O.LSHTables)]),this._keypoints=[],this._keypointsCopy=[],this._numberOfTables=Dn,this._hashSize=Ir,this._lsh=null}get keypoints(){return this._keypoints}set keypoints(e){if(!Array.isArray(e)||e.find(i=>!(i instanceof ai)))throw new d.qw("Static LSH tables: an invalid set of keypoints has been provided");this._keypoints!==e&&(this._keypoints=e,this._keypointsCopy=e.slice(0),this._lsh=null)}get numberOfTables(){return this._numberOfTables}set numberOfTables(e){if(!kt.includes(e))throw new d.qw(`Invalid number of tables: ${e}. Acceptable values: ${kt.join(", ")}`);e!==this._numberOfTables&&(this._numberOfTables=e|0,this._lsh=null)}get hashSize(){return this._hashSize}set hashSize(e){if(!ut.includes(e))throw new d.qw(`Invalid hash size: ${e}. Acceptable values: ${ut.join(", ")}`);e!==this._hashSize&&(this._hashSize=e|0,this._lsh=null)}_run(e){this._lsh==null&&(this._lsh=this._train()),this.output().swrite(this._lsh)}_train(){let e=this._keypointsCopy,i=this._numberOfTables,s=this._hashSize;if(e.find(m=>m.descriptor==null))throw new d.Er("Static LSH tables: can't train the model with no keypoint descriptors!");let l=e.map(m=>m.descriptor.data),p=this._tex[0],h=this._tex[1];return new Ba(p,h,l,i,s)}}let xA=1,CA="default",Ro={fastest:0,default:1,demanding:2},di=(C=>_r.reduce((e,i)=>(e[i]=C(i),e),{}))(C=>(e=>ut.reduce((i,s)=>(i[s]=e(s),i),{}))(e=>(i=>[0,1,2].reduce((s,l)=>(s[l]=i(l),s),{}))(i=>`lshKnn${C}h${e}lv${i}`)));class PA extends Ee{constructor(e=void 0){super(e,6,[Ae("keypoints").expects(O.Keypoints).satisfying(i=>i.descriptorSize>0),Ae("lsh").expects(O.LSHTables),fe().expects(O.KeypointMatches)]),this._k=xA,this._quality=CA}get k(){return this._k}set k(e){this._k=Math.max(1,e|0)}get quality(){return this._quality}set quality(e){if(!Object.prototype.hasOwnProperty.call(Ro,e))throw new d.qw(`Invalid quality level: "${e}"`);this._quality=e}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input("keypoints").read(),h=this.input("lsh").read().lsh,m=e.programs.keypoints,P=h.tables,v=h.descriptorDB,w=P.width,T=v.width,k=h.tableCount,L=h.hashSize,H=h.bucketCapacity,Y=h.bucketsPerTable,re=h.sequences,De=this._tex[0],Qe=this._tex[1],xe=this._tex[2],Ce=this._tex[3],Je=this._tex[4],je=this._tex[5],st=Ro[this._quality],ue=this._k;if(s!==h.descriptorSize)throw new d.qw(`Can't match different types of descriptors in ${this.fullName}`);a.A.assert(di[s]!=null),a.A.assert(di[s][L]!=null),a.A.assert(di[s][L][st]!=null);let at=ke.encoderCapacity(s,l,p),Wt=Math.max(1,Math.ceil(Math.sqrt(at*ue))),Et=je;m.lshKnnTransfer.outputs(Wt,Wt,Je,je);let Lt=Math.max(1,Math.ceil(Math.sqrt(at)));m.lshKnnInitCandidates.outputs(Lt,Lt,De),m.lshKnnInitFilters.outputs(Lt,Lt,Ce);let ui=m[di[s][L][st]];ui.outputs(Lt,Lt,Qe,xe),ui.setUBO("LSHSequences",re),Et.clear(),m.lshKnnInitFilters();for(let Rn=0;Rn<ue;Rn++){let Yt=m.lshKnnInitCandidates();for(let cn=0;cn<k;cn++)Yt=ui(Yt,Ce,Lt,P,v,cn,H,Y,w,T,i,s,l,p),e.gl.flush();Yt.copyTo(Ce),Et=m.lshKnnTransfer(Et,Yt,ue,Rn)}this.output().swrite(Et,ue)}}let ko={32:"bfMatcher32",64:"bfMatcher64"};class vA extends Ee{constructor(e=void 0){super(e,6,[Ae("keypoints").expects(O.Keypoints).satisfying(i=>i.descriptorSize>0),Ae("database").expects(O.Keypoints).satisfying(i=>i.descriptorSize>0),fe().expects(O.KeypointMatches)]),this._matchesPerKeypoint=1}get k(){return this._matchesPerKeypoint}set k(e){this._matchesPerKeypoint=Math.max(1,e|0)}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input("keypoints").read(),h=this.input("database").read(),m=this._tex[0],P=this._tex[1],v=this._tex[2],w=this._tex[3],T=this._tex[4],k=this._tex[5],L=this._matchesPerKeypoint,H=e.programs.keypoints;if(s!==h.descriptorSize)throw new d.qw(`Incompatible descriptors in ${this.fullName}`);if(!Object.prototype.hasOwnProperty.call(ko,s))throw new d.EM(`Unsupported descriptor size (${s}) in ${this.fullName}`);let Y=H[ko[s]],re=ke.encoderCapacity(s,l,p),De=ke.encoderCapacity(h.descriptorSize,h.extraSize,h.encoderLength),Qe=Y.definedConstant("NUMBER_OF_KEYPOINTS_PER_PASS"),xe=Math.ceil(De/Qe),Ce=Math.max(1,Math.ceil(Math.sqrt(re))),Je=Math.max(1,Math.ceil(Math.sqrt(re*L)));H.bfMatcherTransfer.outputs(Je,Je,T,k),H.bfMatcherInitCandidates.outputs(Ce,Ce,v),H.bfMatcherInitFilters.outputs(Ce,Ce,w),Y.outputs(Ce,Ce,m,P);let je=k.clear(),st=H.bfMatcherInitFilters();for(let ue=0;ue<L;ue++){let at=H.bfMatcherInitCandidates();for(let Wt=0;Wt<xe;Wt++)at=Y(at,st,Ce,h.encodedKeypoints,h.descriptorSize,h.extraSize,h.encoderLength,i,s,l,p,Wt),e.gl.flush();L>1&&at.copyTo(st),je=H.bfMatcherTransfer(je,at,L,ue)}this.output().swrite(je,L)}}class bA extends Ee{constructor(e=void 0){super(e,1,[Ae("in").expects(O.Keypoints),Ae("reference").expects(O.Keypoints),fe().expects(O.Keypoints)]),this._threshold=S.MAX_TEXTURE_LENGTH+1}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,+e)}_run(e){let i=this.input("in").read(),s=this.input("reference").read(),l=this._threshold;if(i.descriptorSize!=s.descriptorSize||i.extraSize!=s.extraSize)throw new d.Er("The distance filter requires two compatible shapes of keypoint streams");let p=this._tex[0],h=Math.max(i.encoderLength,s.encoderLength),m=i.descriptorSize,P=i.extraSize;e.programs.keypoints.distanceFilter.outputs(h,h,p)(i.encodedKeypoints,i.encoderLength,s.encodedKeypoints,s.encoderLength,m,P,h,l),this.output().swrite(p,m,P,h)}}let Qo={32:"hammingDistanceFilter32",64:"hammingDistanceFilter64"};class wA extends Ee{constructor(e=void 0){super(e,1,[Ae("in").expects(O.Keypoints).satisfying(i=>i.descriptorSize>0),Ae("reference").expects(O.Keypoints).satisfying(i=>i.descriptorSize>0),fe().expects(O.Keypoints)]),this._threshold=S.MAX_DESCRIPTOR_SIZE*8}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,e|0)}_run(e){let i=this.input("in").read(),s=this.input("reference").read(),l=this._threshold;if(i.descriptorSize!=s.descriptorSize||i.extraSize!=s.extraSize)throw new d.Er("The Hamming distance filter requires two compatible shapes of keypoint streams");if(!Object.prototype.hasOwnProperty.call(Qo,i.descriptorSize))throw new d.EM(`Hamming distance filter - invalid descriptor size: ${i.descriptorSize}`);let p=this._tex[0],h=Math.max(i.encoderLength,s.encoderLength),m=i.descriptorSize,P=i.extraSize,v=Qo[i.descriptorSize];e.programs.keypoints[v].outputs(h,h,p)(i.encodedKeypoints,i.encoderLength,s.encodedKeypoints,s.encoderLength,m,P,h,l),this.output().swrite(p,m,P,h)}}class Ko extends Ee{constructor(e=void 0){super(e,1,[Ae().expects(O.Keypoints)]),this._descriptorSize=0,this._extraSize=0,this._encoderLength=0,this._initialized=!1}get encodedKeypoints(){if(!this._initialized)throw new d.Er(`Portal error: ${this.fullName} holds no data`);return this._tex[0]}get descriptorSize(){if(!this._initialized)throw new d.Er(`Portal error: ${this.fullName} holds no data`);return this._descriptorSize}get extraSize(){if(!this._initialized)throw new d.Er(`Portal error: ${this.fullName} holds no data`);return this._extraSize}get encoderLength(){if(!this._initialized)throw new d.Er(`Portal error: ${this.fullName} holds no data`);return this._encoderLength}init(e){super.init(e);let i=ke.encoderLength(0,0,0);this._tex[0].resize(i,i).clearToColor(1,1,1,1),this._descriptorSize=this._extraSize=0,this._encoderLength=i,this._initialized=!0}release(e){this._initialized=!1,super.release(e)}_run(e){let{encodedKeypoints:i,descriptorSize:s,extraSize:l,encoderLength:p}=this.input().read(),h=this._tex[0];h.resize(i.width,i.height),i.copyTo(h),this._descriptorSize=s,this._extraSize=l,this._encoderLength=p}}class MA extends Nn{constructor(e=void 0){super(e,0,[fe().expects(O.Keypoints)]),this._source=null}get source(){return this._source}set source(e){if(e!==null&&!(e instanceof Ko))throw new d.qw(`Incompatible source for ${this.fullName}`);this._source=e}_run(e){if(this._source==null)throw new d.Er(`${this.fullName} has no source`);this.output().swrite(this._source.encodedKeypoints,this._source.descriptorSize,this._source.extraSize,this._source.encoderLength)}}class TA extends Se.Q{static FAST(e=void 0){return new dA(e)}static Harris(e=void 0){return new uA(e)}}class BA extends Se.Q{static ORB(e=void 0){return new gA(e)}}class DA extends Se.Q{static LK(e=void 0){return new SA(e)}}class NA extends Se.Q{static StaticLSHTables(e=void 0){return new EA(e)}static LSHKNN(e=void 0){return new PA(e)}static BFKNN(e=void 0){return new vA(e)}}class RA extends Se.Q{static Source(e=void 0){return new MA(e)}static Sink(e=void 0){return new Ko(e)}}class kA extends Se.Q{static get Detector(){return TA}static get Descriptor(){return BA}static get Tracker(){return DA}static get Matcher(){return NA}static get Portal(){return RA}static Source(e=void 0){return new Ai(e)}static Sink(e=void 0){return new Zl(e)}static SinkOfTrackedKeypoints(e=void 0){return new $l(e)}static SinkOfMatchedKeypoints(e=void 0){return new eA(e)}static Clipper(e=void 0){return new nA(e)}static BorderClipper(e=void 0){return new iA(e)}static Buffer(e=void 0){return new rA(e)}static Mixer(e=void 0){return new oA(e)}static Shuffler(e=void 0){return new sA(e)}static Multiplexer(e=void 0){return new aA(e)}static Transformer(e=void 0){return new cA(e)}static SubpixelRefiner(e=void 0){return new lA(e)}static DistanceFilter(e=void 0){return new bA(e)}static HammingDistanceFilter(e=void 0){return new wA(e)}}let Lo=C=>C>1?1<<Math.ceil(Math.log2(C)):1;class kr extends Cr{constructor(e="vec2"){super(e,2,[Ae().expects(O.Vector2)]),this._vectors=[],this._textureReader=new x,this._page=0,this._turbo=!1}get turbo(){return this._turbo}set turbo(e){this._turbo=!!e}init(e){super.init(e),this._textureReader.init(e)}release(e){this._textureReader.release(e),super.release(e)}export(){return c.i.resolve(this._vectors)}_run(e){let{vectors:i}=this.input().read(),s=this._turbo,l=i.width,p=Lo(l),h=Lo(Math.ceil(l*l/p)),m=this._tex[this._page];return e.programs.utils.copy2DVectors.outputs(p,h,m)(i),this._page=1-this._page,this._textureReader.readPixelsAsync(m,0,0,m.width,m.height,s).then(P=>{this._vectors=kr._decode(P,p,h)})}static _decode(e,i,s){let p=[],h=0,m=0,P=0,v=0,w=i*s*4,T=Math.min(e.length,w);for(let k=0;k<T&&(m=e[k+1]<<8|e[k],h=e[k+3]<<8|e[k+2],!(m==65535&&h==65535));k+=4)m==65280&&h==65280||(P=a.A.decodeFloat16(m),v=a.A.decodeFloat16(h),p.push(new Ve(P,v)));return p}}class QA extends Function{constructor(){return super("...args","return this._create(...args)"),this.bind(this)}_create(e,i){return new Ve(e,i)}Sink(e=void 0){return new kr(e)}}let KA=500,pi=null;class Qr{constructor(){if(this._fps=60,this._frames=0,this._updateInterval=KA,this._lastUpdate=performance.now(),this._boundUpdate=this._update.bind(this),pi!==null)throw new d.Er("Can't have multiple instances of FPSCounter");this._boundUpdate()}static get instance(){return pi===null&&(pi=new Qr),pi}get fps(){return this._fps}_update(){let e=performance.now(),i=e-this._lastUpdate;i>=this._updateInterval&&(this._fps=Math.round(this._frames/(i*.001)),this._frames=0,this._lastUpdate=e),this._frames++,requestAnimationFrame(this._boundUpdate)}}let LA=new Yc,OA=new QA;class Kr{static get version(){return"0.9.1"}static isSupported(){return typeof WebAssembly<"u"&&typeof WebGL2RenderingContext<"u"&&r.c.instance.gl!=null}static get Settings(){return A.w}static get Vector2(){return OA}static Point2(e,i){return new si(e,i)}static Size(e,i){return new rt(e,i)}static get Matrix(){return LA}static get Promise(){return c.i}static Pipeline(){return new qt}static get Image(){return Pl}static get Filter(){return Ol}static get Transform(){return Xl}static get Keypoint(){return kA}static load(e,i={}){return sn.load(e,i)}static camera(e=640,i=360){let s=typeof e=="object"?e:{audio:!1,video:{width:e|0,height:i|0}};return a.A.requestCameraStream(s).then(l=>sn.load(l))}static get Platform(){return Wc}static get fps(){return Qr.instance.fps}}Object.freeze(Kr),a.A.log(`Speedy Vision version ${Kr.version}. GPU-accelerated Computer Vision for JavaScript by Alexandre Martins. https://github.com/alemart/speedy-vision`),S.LITTLE_ENDIAN||a.A.warning("Running on a big-endian machine")})(),o=o.default,o})())});var ct,Z,Pe,ht,Ot,mi,Ii,xt,gt,kn,_i,Ke=le(()=>{"use strict";ct=class extends Error{constructor(n="",o=null){super(n);this.cause=o}toString(){let n=this.cause?`
-> `+this.cause.toString():"";return this.message!=""?this.name+": "+this.message+n:this.name+n}},Z=class extends ct{get name(){return"IllegalArgumentError"}},Pe=class extends ct{get name(){return"IllegalOperationError"}},ht=class extends ct{get name(){return"NotSupportedError"}},Ot=class extends ct{get name(){return"AccessDeniedError"}},mi=class extends ct{get name(){return"TimeoutError"}},Ii=class extends ct{get name(){return"AssertionError"}},xt=class extends ct{get name(){return"NumericalError"}},gt=class extends ct{get name(){return"TrackingError"}},kn=class extends ct{get name(){return"DetectionError"}},_i=class extends ct{get name(){return"TrainingError"}}});function qo(_,t){let n=qA(_),o=0,r=0;if(Number.isNaN(n))throw new Z("Invalid resolution: "+_);if(t<=0)throw new Z("Invalid aspect ratio: "+t);return t>=1?(r=n,o=Math.floor(r*t),o+=o%2):(o=n,r=Math.floor(o/t),r+=r%2),Ho.default.Size(o,r)}function qA(_){if(Go.hasOwnProperty(_))return Go[_];if(_.endsWith("p")){let t=_[0];if(t>="1"&&t<="9")return parseInt(_)}return Number.NaN}var Ho,Go,Wo=le(()=>{"use strict";Ho=Ne(be(),1);Ke();Go={xs:120,"xs+":144,sm:240,"sm+":288,md:320,"md+":360,lg:480,"lg+":600,xl:720,"xl+":900,xxl:1080}});var Qn,X,Fe=le(()=>{"use strict";Qn=Ne(be(),1);Ke();Wo();X=class _{static log(t,...n){console.log("[encantar-js]",t,...n)}static warning(t,...n){console.warn("[encantar-js]",t,...n)}static error(t,...n){console.error("[encantar-js]",t,...n)}static assert(t,n=""){if(!t)throw new Ii(n)}static range(t){if((t|=0)<0)throw new Z;return Array.from({length:t},(n,o)=>o)}static shuffle(t){for(let n=t.length-1;n>=1;n--){let o=Math.floor(Math.random()*(n+1)),r=t[n];t[n]=t[o],t[o]=r}return t}static wait(t){return new Qn.default.Promise(n=>{setTimeout(n,t)})}static runInSequence(t){return t.reduce((n,o)=>n.then(()=>o),Qn.default.Promise.resolve())}static resolution(t,n){return qo(t,n)}static platformString(){return(t=>typeof t.userAgentData=="object"?t.userAgentData.platform:t.platform)(navigator)}static isIOS(){return/(iOS|iPhone|iPad|iPod)/i.test(navigator.platform)?!0:/Mac/i.test(navigator.platform)&&navigator.maxTouchPoints!==void 0?navigator.maxTouchPoints>2:!1}static isWebKit(){return!!(/Apple/.test(navigator.vendor)||/AppleWebKit\/.* Version\//.test(navigator.userAgent)||/(CriOS\/|FxiOS\/|EdgiOS\/)/.test(navigator.userAgent))}static deviceInfo(){return"Device info: "+JSON.stringify({isIOS:_.isIOS(),isWebKit:_.isWebKit(),renderer:Qn.default.Platform.renderer,vendor:Qn.default.Platform.vendor,screen:[screen.width,screen.height].join("x"),platform:[navigator.platform,navigator.vendor].join("; "),userAgent:navigator.userAgent,userAgentData:navigator.userAgentData||null},null,2)}}});var Jt,jt,Kn=le(()=>{"use strict";Jt=class extends Event{constructor(t){super(t)}get type(){return super.type}},jt=class{constructor(){this._delegate=new EventTarget}addEventListener(t,n){this._delegate.addEventListener(t,n)}removeEventListener(t,n){this._delegate.removeEventListener(t,n)}dispatchEvent(t){return this._delegate.dispatchEvent(t)}}});var Ln,Yo=le(()=>{"use strict";Ln=class{constructor(){this._timeOfLastUpdate=this._now(),this._partialCycleCount=0,this._cyclesPerSecond=0}update(){let t=this._now();++this._partialCycleCount,t>=this._timeOfLastUpdate+1e3*.5&&(this._cyclesPerSecond=this._partialCycleCount/.5,this._partialCycleCount=0,this._timeOfLastUpdate=t)}reset(){this._timeOfLastUpdate=this._now(),this._partialCycleCount=0,this._cyclesPerSecond=0}get cyclesPerSecond(){return this._cyclesPerSecond}_now(){return performance.now()}}});var Vo,Jo,jo,yi,Ct,Pt,vt,lt,Ze,$e,At,dt,bt,Si,Zo,WA,$o,es,ts,ns,is,_n,yn,Sn,En,rs,zt,wt,YA,Ei,os,ss,as,cs,ls,As,ds,Ft=le(()=>{"use strict";Vo=.0234375,Jo=8,jo=15,yi=!0,Ct=.3,Pt=.5,vt=0,lt="low",Ze=9,$e=2,At=5,dt=1,bt="bilinear-upsample",Si=4,Zo=.6,WA=1024*.0125*.5|0,$o=WA/(1024/2),es=.8,ts=1,ns=8,is=4,_n=200,yn=2048,Sn=.005,En=!1,rs=.15,zt=rs*1.2,wt=1-2*rs,YA=1024*.0125|0,Ei=YA/(1024/2),os=15,ss=.7,as=20,cs=.3,ls=1,As=6,ds=1.33});var xi,Or,ps=le(()=>{"use strict";Ft();xi=class{constructor(){this._visible=!1,this._imageTrackerGizmos=new Or}get visible(){return this._visible}set visible(t){this._visible=t}_render(t,n){if(this._visible){for(let o=0;o<n.length;o++)if(n[o].type=="image-tracker"){let r=n[o]._output;this._imageTrackerGizmos.render(t,r)}}}},Or=class{render(t,n){let r=t._backgroundCanvas.getContext("2d",{alpha:!1});if(!r)return;let a=t._realSize,A=n.keypointsNIS,c=n.polylineNDC,u=n.camera;A!==void 0&&this._splitAndRenderKeypointsNIS(r,A,a),c!==void 0&&this._renderPolylineNDC(r,c,a),u!==void 0&&this._renderAxes(r,u,a)}_splitAndRenderKeypointsNIS(t,n,o,r=1){if(n.length==0)return;if(!Object.prototype.hasOwnProperty.call(n[0],"_matches")){this._renderKeypointsNIS(t,n,o,"#f00",r);return}let a=[],A=[];for(let c=0;c<n.length;c++){let u=n[c];this._isGoodMatch(u)?a.push(u):A.push(u)}this._renderKeypointsNIS(t,A,o,"#f00",r),this._renderKeypointsNIS(t,a,o,"#0f0",r)}_isGoodMatch(t){let o=t.matches.length;return o>1?t.matches[0].index>=0&&t.matches[1].index>=0&&t.matches[0].distance<=.7*t.matches[1].distance:o==1?t.matches[0].index>=0:!1}_renderKeypointsNIS(t,n,o,r="red",a=1){let A=o.width/1024,c=o.height/1024;t.beginPath();for(let u=n.length-1;u>=0;u--){let g=n[u],f=g.x*A+.5|0,b=g.y*c+.5|0,d=a*g.scale+.5|0;t.rect(f-d,b-d,2*d,2*d)}t.strokeStyle=r,t.lineWidth=1,t.stroke()}_renderPolylineNDC(t,n,o,r="#0f0",a=2){let A=n.length,c=o.width,u=o.height;if(A!=0){t.beginPath(),t.moveTo((n[A-1].x*.5+.5)*c,(n[A-1].y*-.5+.5)*u);for(let g=0;g<A;g++)t.lineTo((n[g].x*.5+.5)*c,(n[g].y*-.5+.5)*u);t.strokeStyle=r,t.lineWidth=a,t.stroke()}}_renderAxes(t,n,o,r=4){let u=["#f00","#0f0","#00f"],g=1,f=o.width,b=o.height,d=1/(n.imageSize.width/2),y=-1/(n.imageSize.height/2),I=n.matrix.read(),x=g,S=[I[9],I[10],I[11]],M=[x*I[0]+I[9],x*I[1]+I[10],x*I[2]+I[11]],N=[x*I[3]+I[9],x*I[4]+I[10],x*I[5]+I[11]],E=[x*I[6]+I[9],x*I[7]+I[10],x*I[8]+I[11]],R=[M,N,E],B=S[0]/S[2],Q=S[1]/S[2];for(let U=0;U<3;U++){let F=R[U],D=F[0]/F[2],z=F[1]/F[2];t.beginPath(),t.moveTo((B*d*.5+.5)*f,(Q*y*.5+.5)*b),t.lineTo((D*d*.5+.5)*f,(z*y*.5+.5)*b),t.strokeStyle=u[U],t.lineWidth=r,t.stroke()}}}});var Ci,us=le(()=>{"use strict";Ci=class{constructor(t,n){this._session=t,this._results=n}get session(){return this._session}get results(){return this._results[Symbol.iterator]()}}});var Pi,hs=le(()=>{"use strict";Pi=class{constructor(){this._scale=1;this._time=0;this._unscaledTime=0;this._delta=0;this._firstUpdate=0;this._lastUpdate=Number.POSITIVE_INFINITY}_update(t){if(t<this._lastUpdate){this._firstUpdate=this._lastUpdate=t;return}this._delta=(t-this._lastUpdate)*this._scale,this._time+=this._delta,this._unscaledTime=t-this._firstUpdate,this._lastUpdate=t}get elapsed(){return this._time*.001}get delta(){return this._delta*.001}get scale(){return this._scale}set scale(t){this._scale=Math.max(0,+t)}get unscaled(){return this._unscaledTime*.001}}});function ms(_,...t){zr.unshift(_),gs.unshift(t),window.postMessage(fs,"*")}var zr,gs,fs,Is=le(()=>{"use strict";zr=[],gs=[],fs="asap"+Math.random().toString(36).substr(1);window.addEventListener("message",_=>{if(_.source!==window||_.data!==fs||(_.stopPropagation(),zr.length==0))return;let t=zr.pop(),n=gs.pop();t.apply(void 0,n)},!0)});var ot,Fr,ln,Zt,An,Ur=le(()=>{"use strict";ot=Ne(be(),1);On();Fe();Kn();Ke();Cn();Yo();ps();us();hs();Is();Fr=class extends Jt{},ln={mode:"immersive",trackers:[],sources:[],viewport:null,stats:!1,gizmos:!1},Zt=class Zt extends jt{constructor(t,n,o,r,a){if(super(),this._mode=n,this._trackers=[],this._sources=t,this._updateStats=new Ln,this._renderStats=new Ln,this._active=!0,this._frameReady=!0,this._rafQueue=[],this._time=new Pi,this._gizmos=new xi,this._gizmos.visible=a,n!="immersive"&&n!="inline")throw new Z(`Invalid session mode "${n}"`);this._primarySource=this._findPrimarySource(t),this._viewport=o,this._primarySource!==null?this._viewport._init(()=>this._primarySource._internalMedia.size,n,r):this._viewport._init(()=>X.resolution("sm",window.innerWidth/window.innerHeight),n,r),Zt._count++,X.log(`The ${this._mode} session is now active!`)}static isSupported(){if(/(Mac|iOS|iPhone|iPad|iPod)/i.test(X.platformString())){let t=/(iPhone|iPad|iPod).* (CPU[\s\w]* OS|CPU iPhone|iOS) ([\d\._]+)/.exec(navigator.userAgent),n=/(AppleWebKit)\/.* (Version)\/([\d\.]+)/.exec(navigator.userAgent),o=n||t;if(o!==null){let r=o[3]||"0.0",[a,A]=r.split(/[\._]/).map(c=>parseInt(c)|0);if(a<15||a==15&&A<2)return X.error(`${o===n?"Safari":"iOS"} version ${r} is not supported! User agent: ${navigator.userAgent}`),!1}else X.warning(`Unrecognized user agent: ${navigator.userAgent}`)}return ot.default.isSupported()}static instantiate(t=ln){let{mode:n=ln.mode,sources:o=ln.sources,trackers:r=ln.trackers,viewport:a=ln.viewport,stats:A=ln.stats,gizmos:c=ln.gizmos}=t;return X.log(`Starting a new ${n} session...`),ot.default.Promise.resolve().then(()=>{if(!Zt.isSupported())throw new ht("You need a browser/device compatible with WebGL2 and WebAssembly in order to experience Augmented Reality with encantar.js");if(n!=="inline"&&Zt.count>0)throw new Pe("Can't start multiple sessions, except in inline mode");if(!/^\d+\.\d+(\.\d+)*$/.test(pt.version)&&!["localhost","127.0.0.1","[::1]","","encantar.dev","alemart.github.io"].includes(location.hostname)&&!(location.hostname.startsWith("192.168.")||location.hostname.startsWith("10.")||/^172\.(1[6-9]|2[0-9]|3[01])\./.test(location.hostname))){let g="This is a development build (unstable). Do not use it in production. Get a stable release at encantar.dev";if(X.warning(g),!confirm(g+`

Are you sure you want to continue?`))throw new Ot("Aborted")}return ot.default.Matrix.ready()}).then(()=>{for(let u=o.length-1;u>=0;u--)if(o.indexOf(o[u])<u)throw new Z("Found repeated sources of data");return ot.default.Promise.all(o.map(u=>u._init()))}).then(()=>{if(!a)throw new Z("Can't create a session without a viewport");return new Zt(o,n,a,A,c)}).then(u=>{r.length==0&&X.warning("No trackers have been attached to the session!");for(let g=r.length-1;g>=0;g--)if(r.indexOf(r[g])<g)throw new Z("Found repeated trackers");return ot.default.Promise.all(r.map(g=>u._attachTracker(g))).then(()=>u)}).then(u=>(u._startMainLoop(),u)).catch(u=>{throw X.error(`Can't start session: ${u.message}`),u})}static get count(){return this._count}end(){return this._active?(X.log("Shutting down the session..."),this._active=!1,X.wait(100).then(()=>ot.default.Promise.all(this._trackers.map(t=>t._release()))).then(()=>ot.default.Promise.all(this._sources.map(t=>t._release()))).then(()=>{this._sources.length=0,this._trackers.length=0,this._updateStats.reset(),this._renderStats.reset(),this._viewport._release(),Zt._count--;let t=new Fr("end");this.dispatchEvent(t),X.log("Session ended.")})):ot.default.Promise.resolve()}requestAnimationFrame(t){let n=Symbol("raf-handle");return this._active&&this._rafQueue.push([n,t]),n}cancelAnimationFrame(t){for(let n=this._rafQueue.length-1;n>=0;n--)if(this._rafQueue[n][0]===t){this._rafQueue.splice(n,1);break}}get mode(){return this._mode}get ended(){return!this._active}get time(){return this._time}get gizmos(){return this._gizmos}get viewport(){return this._viewport}get trackers(){return this._trackers[Symbol.iterator]()}get sources(){return this._sources[Symbol.iterator]()}_startMainLoop(){this._setupUpdateLoop(),this._setupRenderLoop(),X.log("The main loop has been started!")}_findPrimarySource(t){for(let n=0;n<t.length;n++)if(t[n]._type=="video")return t[n];for(let n=0;n<t.length;n++)if(t[n]._type=="canvas")return t[n];return X.warning("No primary source of data was found!"),null}_attachTracker(t){return this._trackers.indexOf(t)>=0?ot.default.Promise.reject(new Z("Duplicate tracker attached to the session")):this._active?(this._trackers.push(t),t._init(this)):ot.default.Promise.reject(new Pe("Inactive session"))}_renderBackground(){let n=this._viewport._backgroundCanvas.getContext("2d",{alpha:!1});if(n){if(n.imageSmoothingEnabled=!1,this._primarySource!==null){let o=this._primarySource._internalMedia;this._renderMedia(n,o,!0)}for(let o=0;o<this._trackers.length;o++){let r=this._trackers[o]._output.image;r!==void 0&&this._renderMedia(n,r,!1)}this._gizmos._render(this._viewport,this._trackers)}}_renderMedia(t,n,o){let r=t.canvas,a=o?r.width:n.width,A=o?r.height:n.height;if(n.type!="data"){let c=n.source;t.drawImage(c,0,0,a,A)}else{let c=n.source;t.putImageData(c,0,0,0,0,a,A)}}_setupUpdateLoop(){let t=()=>{if(this._active)We.powerPreference=="high-performance"?ms(o):window.requestAnimationFrame(o);else return},n=()=>{this._update().then(t).turbocharge()};function o(){We.powerPreference=="low-power"?window.requestAnimationFrame(n):n()}window.requestAnimationFrame(n)}_update(){return this._active?ot.default.Promise.all(this._trackers.map(t=>t._update().turbocharge())).then(()=>{this._updateStats.update(),this._frameReady=!0}).catch(t=>{X.error("Tracking error: "+t.toString(),t);let n=t.cause;if(t.name=="GLError")throw alert(t.message),alert(X.deviceInfo()),t;if(typeof n=="object"&&n.name=="GLError")throw alert(t.message),alert(n.message),alert(X.deviceInfo()),t}):(this._updateStats.reset(),ot.default.Promise.resolve())}_setupRenderLoop(){let t=!1,n=!1,o=r=>{let a=We.powerPreference=="low-power",A=We.powerPreference=="high-performance";this._time._update(r),(!a||!(t=!t))&&this._render(r),this._active&&window.requestAnimationFrame(o)};window.requestAnimationFrame(o)}_render(t,n=!1){if(this._active)if(this._frameReady){let o=this._trackers.map(c=>c._output.exports||{tracker:c,trackables:[]}),r=new Ci(this,o),a=this._rafQueue.slice(0);this._rafQueue.length=0,n||this._renderBackground();for(let c=0;c<a.length;c++)a[c][1].call(void 0,t,r);this._renderStats.update(),this._frameReady=!1,this._viewport.hud._statsPanel.update(t,this._sources,this._trackers,this._viewport,this._updateStats.cyclesPerSecond,this._renderStats.cyclesPerSecond)}else this._renderStats.update();else this._renderStats.reset()}};Zt._count=0;An=Zt});var Xr,We,Cn=le(()=>{"use strict";Xr=Ne(be(),1);Ur();Ke();Fe();We=class{static get powerPreference(){return this._powerPreference}static set powerPreference(t){if(An.count>0)throw new Pe("Can't change the powerPreference while there are active sessions going on");if(!(t=="low-power"||t=="default"||t=="high-performance"))throw new Z(`Invalid powerPreference: "${t}"`);t=="high-performance"?Xr.default.Settings.gpuPollingMode="asap":Xr.default.Settings.gpuPollingMode="raf",this._powerPreference=t,X.log(`Changed the powerPreference to "${this._powerPreference}"`)}};We._powerPreference="default"});var vi,_s=le(()=>{"use strict";vi=class{constructor(t,n){this._referenceImage=Object.assign({},t),this._media=n,this._referenceImage.name===void 0&&(this._referenceImage.name=this._generateUniqueName()),this._aspectRatio=n.width/n.height}get name(){return this._referenceImage.name}set name(t){this._referenceImage.name=t}get image(){return this._referenceImage.image}get media(){return this._media}get aspectRatio(){return this._aspectRatio}_generateUniqueName(){return"target-"+Math.random().toString(16).substr(2)}}});var bi,VA,wi,ys=le(()=>{"use strict";bi=Ne(be(),1);_s();Fe();Ke();VA=100,wi=class{constructor(){this._capacity=VA,this._entries=new Map,this._locked=!1}get count(){return this._entries.size}get capacity(){return this._capacity}set capacity(t){let n=Math.max(0,t|0);if(this.count>n)throw new Z(`Can't set the capacity of the database to ${n}: it currently stores ${this.count} entries`);this._capacity=n}[Symbol.iterator](){return this._entries.values()}add(t){return this._preloadMany(t).then(n=>{n.forEach(o=>{this._addOne(o)})})}_addOne(t){let n=t.name;if(this._locked)throw new Pe(`Can't add reference image "${n}" to the database: it's locked`);if(this.count>=this.capacity)throw new Pe(`Can't add reference image "${n}" to the database: the capacity of ${this.capacity} images has been exceeded.`);if(!(t.image instanceof HTMLImageElement)&&!(t.image instanceof ImageBitmap)&&!(t.image instanceof ImageData))throw new Z(`Can't add reference image "${n}" to the database: invalid image`);if(this._entries.has(n))throw new Z(`Can't add reference image "${n}" to the database: found duplicated name`);X.log(`Adding reference image "${n}" to the database...`),this._entries.set(n,t)}_lock(){this._locked=!0}_find(t){return this._entries.get(t)||null}_preloadOne(t){return t.name!==void 0?X.log(`Loading reference image "${t.name}"...`):X.log("Loading reference image..."),t.image?bi.default.load(t.image).then(n=>new vi(t,n)):bi.default.Promise.reject(new Z("The reference image was not provided!"))}_preloadMany(t){let n=t.length;X.log(`Loading ${n} reference image${n!=1?"s":""}...`);let o=t.map(r=>this._preloadOne(r));return bi.default.Promise.all(o)}}});var Ss,tt,dn=le(()=>{"use strict";Ss=Ne(be(),1);Ke();tt=class{constructor(t,n){this._name=t,this._imageTracker=n,this._pipeline=this._createPipeline(),this._pipelineReleased=!1}get name(){return this._name}get screenSize(){let t=this._pipeline.node("screen");if(!t)throw new Pe;return t.size}init(){}release(){return this._pipelineReleased||(this._pipeline.release(),this._pipelineReleased=!0),null}update(t,n){let o=this._pipeline.node("source"),r=this._pipeline.node("screen");if(!o||!r)throw new Pe;return o.media=t,r.size=n,this._beforeUpdate().then(()=>this._gpuUpdate()).then(a=>this._afterUpdate(a))}onEnterState(t){}onLeaveState(){}_beforeUpdate(){return Ss.default.Promise.resolve()}_gpuUpdate(){return this._pipeline.run()}}});var we,Mi,Es=le(()=>{"use strict";we=Ne(be(),1);dn();Ft();Fe();Mi=class extends tt{constructor(t){super("initial",t)}_beforeUpdate(){return this._pipeline.node("source").media.size.area()<this.screenSize.area()&&X.warning("The resolution of the tracker is larger than the resolution of the video. This is inefficient."),we.default.Promise.resolve()}_afterUpdate(t){return we.default.Promise.resolve({nextState:"training",trackerOutput:{}})}onLeaveState(){this._pipeline.release(),this._pipelineReleased=!0}_createPipeline(){let t=we.default.Pipeline(),n=we.default.Image.Source("source"),o=we.default.Transform.Resize("screen"),r=we.default.Filter.Greyscale(),a=we.default.Transform.PerspectiveWarp(),A=we.default.Filter.Nightvision(),c=we.default.Image.Multiplexer(),u=we.default.Keypoint.Detector.Harris(),g=we.default.Keypoint.Descriptor.ORB(),f=we.default.Filter.GaussianBlur(),b=we.default.Keypoint.Clipper(),d=we.default.Keypoint.BorderClipper(),y=we.default.Filter.GaussianBlur(),I=we.default.Keypoint.SubpixelRefiner(),x=we.default.Keypoint.Matcher.BFKNN(),S=we.default.Keypoint.Transformer(),M=we.default.Keypoint.Portal.Sink(),N=we.default.Keypoint.Portal.Source(),E=we.default.Keypoint.Multiplexer(),R=we.default.Keypoint.Buffer(),B=we.default.Keypoint.Multiplexer(),Q=we.default.Keypoint.SinkOfMatchedKeypoints();return n.media=null,o.size=we.default.Size(0,0),a.transform=we.default.Matrix.Eye(3),A.quality=lt,I.method=bt,d.imageSize=we.default.Size(100,100),d.borderSize=we.default.Vector2(0,0),x.k=1,S.transform=we.default.Matrix.Eye(3),N.source=M,E.port=0,B.port=0,R.frozen=!1,Q.turbo=!1,n.output().connectTo(o.input()),o.output().connectTo(r.input()),r.output().connectTo(a.input()),a.output().connectTo(c.input("in0")),a.output().connectTo(A.input()),A.output().connectTo(c.input("in1")),c.output().connectTo(f.input()),c.output().connectTo(u.input()),u.output().connectTo(d.input()),d.output().connectTo(b.input()),a.output().connectTo(y.input()),y.output().connectTo(I.input("image")),b.output().connectTo(I.input("keypoints")),f.output().connectTo(g.input("image")),I.output().connectTo(g.input("keypoints")),g.output().connectTo(E.input("in0")),B.output().connectTo(E.input("in1")),E.output().connectTo(x.input("database")),g.output().connectTo(x.input("keypoints")),N.output().connectTo(B.input("in0")),R.output().connectTo(B.input("in1")),N.output().connectTo(R.input()),g.output().connectTo(M.input()),g.output().connectTo(S.input()),S.output().connectTo(Q.input()),x.output().connectTo(Q.input("matches")),t.init(n,o,r,a,A,c,f,u,I,b,d,y,g,N,E,x,R,B,S,Q,M),t}}});function id(_,t,n){if(_.rows!=2||t.rows!=2||_.columns!=t.columns)throw new Z("Bad input");if(n.rows!=3||n.columns!=3)throw new Z("Bad intrinsics");let o=_.columns;if(o<4)throw new Z("solvePlanarPnP requires at least 4 points");o>Ut&&(o=Ut);let r=n.read(),a=r[0],A=r[4],c=r[6],u=r[7];pn[0]=1/a,pn[4]=1/A,pn[6]=-c/a,pn[7]=-u/A,pn[8]=1;let g=Qs(a),f=_.read(),b=t.read();for(let K=0,J=0;K<o;K++,J+=2){let ye=xs[K],ie=Cs[K];ye[0]=f[J],ye[1]=f[J+1],ye[2]=1,ie[0]=b[J],ie[1]=b[J+1],ie[2]=1}for(let K=0;K<o;K++)un(Mt[K],pn,xs[K]),Hn(Mt[K],Mt[K],g);for(let K=0;K<o;K++)un(ft[K],pn,Cs[K]),Wr(ft[K],ft[K]);mt[0]=mt[1]=mt[2]=0;for(let K=0;K<o;K++){let J=Mt[K];mt[0]+=J[0],mt[1]+=J[1],mt[2]+=J[2]}mt[0]/=o,mt[1]/=o,mt[2]/=o;for(let K=0;K<o;K++)tn(Ps[K],Mt[K],mt);if(ZA){let K=ad(Mt,ft,o);if(Number.isNaN(K[0]))return Qi;let J=Ki(K,ft[0]);for(let ye=0;ye<o;ye++)$t[ye]=J/Ki(K,ft[ye])}else{$t[0]=1;for(let K=3;K<o;K+=3){let ye=K-2,ie=K-1,Ie=ks(Mt,ft,o,0,ye,ie,K);if(Number.isNaN(Ie[0]))return Qi;$t[ye]=Ie[0],$t[ie]=Ie[1],$t[K]=Ie[2],K+3>=o&&(K-=2)}}It[0]=It[1]=It[2]=0;for(let K=0;K<o;K++){let J=ft[K],ye=$t[K];It[0]+=ye*J[0],It[1]+=ye*J[1],It[2]+=ye*J[2]}It[0]/=o,It[1]/=o,It[2]/=o;for(let K=0;K<o;K++)Hn(Ti,ft[K],$t[K]),tn(Ti,Ti,It),Wr(vs[K],Ti);let d=0,y=0,I=0,x=0,S=0,M=0;for(let K=0;K<o;K++){let J=Ps[K],ye=vs[K];d+=ye[0]*J[0],y+=ye[1]*J[1],I+=ye[0]*J[1],x+=ye[1]*J[0],S+=ye[2]*J[0],M+=ye[2]*J[1]}let N=d*d,E=y*y,R=I*I,B=x*x,Q=S*S,U=M*M,F=N*(E+U)+R*(B+Q)+B*U+E*Q-2*(d*I*(x*y+S*M)+x*y*S*M),D=Math.sqrt(N+R+B+E+Q+U+2*Math.sqrt(F));if(Tt[0]=d-y-D,Tt[1]=I+x,Tt[2]=S,Tt[3]=I+x,Tt[4]=-d+y-D,Tt[5]=M,Tt[6]=S,Tt[7]=M,Tt[8]=-(d+y+D),Bi[0]=-M,Bi[1]=S,Bi[2]=I-x,un(zn,Vr($A,Tt),Bi),Number.isNaN(zn[0]))return Qi;let z=zn[0],q=zn[1],j=zn[2],V=1,te=Math.sqrt(z*z+q*q+j*j+V*V);Fn[0]=z/te,Fn[1]=q/te,Fn[2]=j/te,Fn[3]=V/te;let ge=sd(Mt,o,0),Be=$t[ge],Oe=Ki(ft[ge],ft[0]),qe=Ks(Mt[ge],Mt[0])/(Be*(Be-2*Oe)+1),ce=Math.sqrt(qe);pd(Gr,Fn),Hn(bs,It,ce),tn(ws,bs,un(ed,Gr,mt));for(let K=0;K<9;K++)Hr[K]=Gr[K];for(let K=0;K<3;K++)Hr[9+K]=ws[K];return et.default.Matrix(3,4,Hr)}function rd(_,t,n,o={}){let r=Object.assign({},Ds,o),a=r.numberOfHypotheses,A=r.reprojectionError,c=r.acceptablePercentageOfInliers,u=r.mask,g=_.columns;if(g<4)throw new Z("solvePlanarPnP requires at least 4 points");let f=_t(n.read()),b=Yr(0),d=new Array(g);d.fill(0);let y=_.read(),I=t.read(),x=X.range(g),S=new Array(2*4),M=new Array(2*4),N=et.default.Matrix.Zeros(2,4),E=et.default.Matrix.Zeros(2,4),R=Number.POSITIVE_INFINITY,B=Qi;for(let Q=0;Q<a;Q++){X.shuffle(x),cd(N,E,S,M,y,I,x);let U=id(N,E,n);b.set(U.read());let F=Rs(f,b),D=od(F,y,I,A,d),z=0;for(let V=0;V<g;V++)z+=d[V];let q=U,j=D;if(!(j>R)&&(R=j,B=q,z/g>=c))break}return u?.setToSync(et.default.Matrix(1,g,d)),B}function Ns(_,t,n,o={}){let r=_.columns,a=Object.assign({},nd,o),A=Math.max(0,Math.min(a.refinementQuality,1)),c=a.reprojectionError,u=a.mask;if(r<4)return et.default.Promise.reject(new Z("find6DofHomography() requires at least 4 points"));if(_.columns!=t.columns||_.rows!=2||t.rows!=2)return et.default.Promise.reject(new Z("Bad input"));if(n.columns!=3||n.rows!=3)return et.default.Promise.reject(new Z("Bad intrinsics"));let g=rd(_,t,n,o),f=_t(n.read()),b=Yr(g.read()),d=Rs(f,b),y=Array.from(d),I=et.default.Matrix(3,3,y);if(A==0||Number.isNaN(y[0]))return et.default.Promise.resolve(I);let x=_,S=t,M=et.default.Matrix.Zeros(2,r);return et.default.Matrix.applyPerspectiveTransform(M,x,I).then(N=>et.default.Matrix.findHomography(et.default.Matrix.Zeros(3),N,S,{method:"pransac",numberOfHypotheses:Math.ceil(512*A),bundleSize:Math.ceil(128*A),reprojectionError:c,mask:u})).then(N=>N.setTo(N.times(I)))}function Rs(_,t){let n=_[0],o=_[4],r=_[6],a=_[7],A=Qs(n);en[0]=A/n,en[5]=A/o,en[10]=A,en[12]=-r*A/n,en[13]=-a*A/o,en[14]=A,en[15]=1,un(Dt,t,en),Nt[0]=Dt[0],Nt[1]=Dt[1],Nt[2]=Dt[2],Nt[3]=Dt[3],Nt[4]=Dt[4],Nt[5]=Dt[5],Nt[6]=Dt[9],Nt[7]=Dt[10],Nt[8]=Dt[11],un(ki,_,Nt);let c=1/ki[8];for(let u=0;u<9;u++)ki[u]*=c;return ki}function od(_,t,n,o=3,r=[]){let[a,A,c,u,g,f,b,d,y]=_,[I,x,S,M,N,E,R,B,Q]=Vr(td,_),U=t.length/2,F=o*o,D=0;if(r.length=U,r.fill(0),Number.isNaN(a*I))return Number.POSITIVE_INFINITY;for(let z=0,q=0;z<U;z++,q+=2){let j=t[q+0],V=t[q+1],te=1,ge=n[q+0],Be=n[q+1],Oe=1,Xe=a*j+u*V+b*te,qe=A*j+g*V+d*te,ce=c*j+f*V+y*te,K=Xe/ce,J=qe/ce,ye=ge/Oe,ie=Be/Oe,Ie=K-ye,Ye=J-ie,se=Ie*Ie+Ye*Ye,W=I*ge+M*Be+R*Oe,ae=x*ge+N*Be+B*Oe,ne=S*ge+E*Be+Q*Oe,$=W/ne,ee=ae/ne,_e=j/te,ve=V/te,pe=$-_e,Se=ee-ve,Ge=pe*pe+Se*Se;D+=se+Ge,r[z]=+(se<F&&Ge<F)}return D/U}function sd(_,t,n=0){let o=_[n];if(t>_.length)throw new Z;let r=0,a=0;for(let A=0;A<t;A++){let c=Ks(o,_[A]);c>r&&(r=c,a=A)}return a}function ad(_,t,n){if(_.length<4||t.length<4||_.length!=t.length||n>_.length)throw new Z;let o=0,r=Math.floor((n-1)/3),a=Math.floor((n-1)*2/3),A=n-1,c=ks(_,t,n,o,r,a,A);if(Number.isNaN(c[0]))return Le(Number.NaN);let u=t[o],g=t[r],f=t[a];return Hn(Ni,g,c[0]),tn(Ni,Ni,u),Hn(Ri,f,c[1]),tn(Ri,Ri,u),Wr(qr,dd(qr,Ni,Ri)),qr}function ks(_,t,n,o,r,a,A){if(_.length<4||t.length<4||_.length!=t.length||n>_.length)throw new Z;if(Math.min(o,r,a,A)<0||Math.max(o,r,a,A)>=n)throw new Z;let c=_[o],u=_[r],g=_[a],f=_[A],b=t[o],d=t[r],y=t[a],I=t[A];tn(Un,u,c),tn(Xn,g,c),tn(Gn,f,c);let x=Un[0]*Xn[1]-Un[1]*Xn[0];if(Math.abs(x)<Bs)return Le(Number.NaN);let S=(Xn[1]*Gn[0]-Xn[0]*Gn[1])/x,M=(Un[0]*Gn[1]-Un[1]*Gn[0])/x,N=S+M-1;return Di[0]=N*b[0],Di[1]=N*b[1],Di[2]=N*b[2],Bt[0]=S*d[0],Bt[1]=S*d[1],Bt[2]=S*d[2],Bt[3]=M*y[0],Bt[4]=M*y[1],Bt[5]=M*y[2],Bt[6]=-I[0],Bt[7]=-I[1],Bt[8]=-I[2],Vr(Ms,Bt),un(Ts,Ms,Di),Ts}function Qs(_,t=jA,n=JA){let r=_/20;return t/n*r}function cd(_,t,n,o,r,a,A){X.assert(A.length>=4&&n.length==4*2&&o.length==4*2&&_.rows==2&&_.columns==4&&t.rows==2&&t.columns==4);for(let u=0;u<4;u++){let g=A[u];for(let f=0;f<2;f++)n[u*2+f]=r[g*2+f],o[u*2+f]=a[g*2+f]}_.data.set(n),t.data.set(o)}function Pn(_,t=_,n=0){if(typeof _=="object")return Pn(_._rows,_._cols,_);let o=typeof n=="object";if(o&&n.length!=_*t)throw new Z;let r=o?new Float64Array(n):new Float64Array(_*t);return r._rows=_,r._cols=t,typeof n=="number"&&r.fill(n),r}function _t(_){return Pn(3,3,_)}function ld(_){return Pn(4,4,_)}function Yr(_){return Pn(3,4,_)}function Le(_){return Pn(3,1,_)}function Ad(_){return Pn(4,1,_)}function tn(_,t,n){let o=t._rows,r=t._cols,a=n._rows,A=n._cols,c=_._rows,u=_._cols;if(o!=a||r!=A||o!=c||r!=u)throw new Z;for(let g=0;g<_.length;g++)_[g]=t[g]-n[g];return _}function un(_,t,n){let o=t._rows,r=t._cols,a=n._rows,A=n._cols,c=_._rows,u=_._cols;if(c!=o||u!=A||r!=a)throw new Z;_.fill(0);for(let g=0;g<u;g++)for(let f=0;f<o;f++)for(let b=0;b<r;b++)_[g*c+f]+=t[b*o+f]*n[g*a+b];return _}function Hn(_,t,n){if(t._rows!=_._rows||t._cols!=_._cols)throw new Z;for(let o=0;o<_.length;o++)_[o]=t[o]*n;return _}function Vr(_,t){if(t._rows!=_._rows||t._cols!=_._cols)throw new Z;let n=t[4]*t[8]-t[7]*t[5],o=t[3]*t[8]-t[6]*t[5],r=t[3]*t[7]-t[6]*t[4],a=t[1]*t[8]-t[7]*t[2],A=t[0]*t[8]-t[6]*t[2],c=t[0]*t[7]-t[6]*t[1],u=t[1]*t[5]-t[4]*t[2],g=t[0]*t[5]-t[3]*t[2],f=t[0]*t[4]-t[3]*t[1],b=t[0]*n-t[1]*o+t[2]*r;if(Math.abs(b)<Bs)return _.fill(Number.NaN);let d=1/b;return _[0]=n*d,_[1]=-a*d,_[2]=u*d,_[3]=-o*d,_[4]=A*d,_[5]=-g*d,_[6]=r*d,_[7]=-c*d,_[8]=f*d,_}function Wr(_,t){let n=Ki(t,t),o=Math.sqrt(n);return _[0]=t[0]/o,_[1]=t[1]/o,_[2]=t[2]/o,_}function Ks(_,t){let n=_[0]-t[0],o=_[1]-t[1],r=_[2]-t[2];return n*n+o*o+r*r}function Ki(_,t){return _[0]*t[0]+_[1]*t[1]+_[2]*t[2]}function dd(_,t,n){return _[0]=t[1]*n[2]-t[2]*n[1],_[1]=t[2]*n[0]-t[0]*n[2],_[2]=t[0]*n[1]-t[1]*n[0],_}function pd(_,t){let n=t[0],o=t[1],r=t[2],a=t[3],A=2*n*n,c=2*o*o,u=2*r*r,g=2*n*o,f=2*n*r,b=2*o*r,d=2*a*n,y=2*a*o,I=2*a*r;return _[0]=1-(c+u),_[1]=g+I,_[2]=f-y,_[3]=g-I,_[4]=1-(A+u),_[5]=b+d,_[6]=f+y,_[7]=b-d,_[8]=1-(A+c),_}var et,JA,jA,ZA,Bs,Ut,Qi,pn,xs,Cs,Mt,ft,Ps,vs,$t,mt,It,Ti,Tt,$A,Bi,zn,Gr,Fn,ed,bs,ws,Hr,Un,Xn,Gn,Di,Bt,Ms,Ts,Ni,Ri,qr,ki,td,Dt,Nt,en,Ds,nd,Ls=le(()=>{"use strict";et=Ne(be(),1);Fe();Ke();JA=5*.001,jA=20*.01,ZA=!1,Bs=1e-8,Ut=1024,Qi=et.default.Matrix(3,4,new Array(12).fill(Number.NaN)),pn=_t(0),xs=Array.from({length:Ut},()=>Le(0)),Cs=Array.from({length:Ut},()=>Le(0)),Mt=Array.from({length:Ut},()=>Le(0)),ft=Array.from({length:Ut},()=>Le(0)),Ps=Array.from({length:Ut},()=>Le(0)),vs=Array.from({length:Ut},()=>Le(0)),$t=new Array(Ut).fill(0),mt=Le(0),It=Le(0),Ti=Le(0),Tt=_t(0),$A=_t(0),Bi=Le(0),zn=Le(0),Gr=_t(0),Fn=Ad(0),ed=Le(0),bs=Le(0),ws=Le(0),Hr=new Array(12).fill(0),Un=Le(0),Xn=Le(0),Gn=Le(0),Di=Le(0),Bt=_t(0),Ms=_t(0),Ts=Le(0),Ni=Le(0),Ri=Le(0),qr=Le(0),ki=_t(0),td=_t(0),Dt=Yr(0),Nt=_t(0),en=ld(0),Ds={numberOfHypotheses:100,reprojectionError:3,acceptablePercentageOfInliers:Number.POSITIVE_INFINITY,mask:null},nd=Object.assign({},Ds,{refinementQuality:1})});var ze,oe,vn=le(()=>{"use strict";ze=Ne(be(),1);Fe();Ke();Ft();Ls();oe=class{static rasterToNIS(t){let n=1024/t.width,o=1024/t.height;return ze.default.Matrix(3,3,[n,0,0,0,o,0,0,0,1])}static rasterToNDC(t){let n=t.width,o=t.height;return ze.default.Matrix(3,3,[2/n,0,0,0,-2/o,0,-1,1,1])}static NDCToRaster(t){let n=t.width,o=t.height;return ze.default.Matrix(3,3,[n/2,0,0,0,-o/2,0,n/2,o/2,1])}static scaleNDC(t,n=t){return ze.default.Matrix(3,3,[t,0,0,0,n,0,0,0,1])}static bestFitScaleNDC(t,n=1){return t>=1?this.scaleNDC(n,n/t):this.scaleNDC(n*t,n)}static inverseBestFitScaleNDC(t,n=1){return t>=1?this.scaleNDC(1/n,t/n):this.scaleNDC(1/(n*t),1/n)}static bestFitAspectRatioNDC(t,n){let o=t.width/t.height;return n.aspectRatio/o}static compilePairsOfKeypointsNDC(t){let n=t.length;if(n==0)throw new Z;let o=2/1024,r=new Array(2*2*n);for(let a=0,A=0,c=2*n;a<n;a++,A+=2,c+=2){let u=t[a][0],g=t[a][1];r[A]=u.x*o-1,r[A+1]=1-u.y*o,r[c]=g.x*o-1,r[c+1]=1-g.y*o}return ze.default.Matrix(2,2*n,r)}static interpolateHomographies(t,n,o,r=0,a=0,A=0){let c=new Array(4),u=new Array(8),g=[-1,1,1,1,1,-1,-1,-1],f=t.read(),b=n.read();for(let E=0,R=0;E<4;E++,R+=2){let B=g[R],Q=g[R+1],U=f[0]*B+f[3]*Q+f[6],F=f[1]*B+f[4]*Q+f[7],D=f[2]*B+f[5]*Q+f[8],z=b[0]*B+b[3]*Q+b[6],q=b[1]*B+b[4]*Q+b[7],j=b[2]*B+b[5]*Q+b[8],V=z/j-U/D,te=q/j-F/D;c[E]=V*V+te*te}let d=0,y=0,I=0,x=1,S=Math.max(c[0],c[1],c[2],c[3]),M=Math.min(c[0],c[1],c[2],c[3]);if(S<1e-5)return ze.default.Promise.resolve(ze.default.Matrix(n));for(let E=0,R=0;E<4;E++,R+=2){let B=g[R],Q=g[R+1],U=f[0]*B+f[3]*Q+f[6],F=f[1]*B+f[4]*Q+f[7],D=f[2]*B+f[5]*Q+f[8],z=b[0]*B+b[3]*Q+b[6],q=b[1]*B+b[4]*Q+b[7],j=b[2]*B+b[5]*Q+b[8],V=U/D,te=F/D,ge=z/j,Be=q/j;if(c[E]==M){d=ge-V,y=Be-te;let J=V*ge+te*Be,ye=V*Be-te*ge,ie=V*V+te*te,Ie=ge*ge+Be*Be,Ye=Math.sqrt(ie*Ie);I=ye/Ye,x=J/Ye}let Oe=o*Math.pow(2,-r),Xe=1-Math.sqrt(c[E]/S),ce=(o-Oe)*Xe+Oe,K=1-ce;u[R]=V*K+ge*ce,u[R+1]=te*K+Be*ce}let N=1-A;for(let E=0;E<8;E+=2){let R=u[E],B=u[E+1];u[E]=R*N+(R*x-B*I)*A,u[E+1]=B*N+(R*I+B*x)*A}for(let E=0;E<8;E+=2)u[E]+=d*a,u[E+1]+=y*a;return ze.default.Matrix.perspective(ze.default.Matrix.Zeros(3),ze.default.Matrix(2,4,g),ze.default.Matrix(2,4,u))}static find6DoFHomographyNDC(t,n,o){let r=n.columns/2;if(r<4)return ze.default.Promise.reject(new Z("Too few data points to compute a perspective warp"));let a=n.block(0,1,0,r-1),A=n.block(0,1,r,2*r-1),c=o.mask||ze.default.Matrix.Zeros(1,r);return Ns(a,A,t,Object.assign({mask:c},o)).then(u=>{let g=u.at(0,0);if(Number.isNaN(g))throw new xt("Can't compute a perspective warp: bad keypoints");let f=0,b=c.read();for(let y=0;y<r;y++)f+=b[y];let d=f/r;return[u,d]})}static findPerspectiveWarpNDC(t,n){let o=t.columns/2;if(o<4)return ze.default.Promise.reject(new Z("Too few data points to compute a perspective warp"));let r=t.block(0,1,0,o-1),a=t.block(0,1,o,2*o-1),A=n.mask||ze.default.Matrix.Zeros(1,o);return ze.default.Matrix.findHomography(ze.default.Matrix.Zeros(3),r,a,Object.assign({mask:A},n)).then(c=>{let u=c.at(0,0);if(Number.isNaN(u))throw new xt("Can't compute a perspective warp: bad keypoints");let g=0,f=A.read();for(let d=0;d<o;d++)g+=f[d];let b=g/o;return[c,b]})}static findAffineWarpNDC(t,n){let o=t.columns/2;if(o<3)return ze.default.Promise.reject(new Z("Too few data points to compute an affine warp"));let r=ze.default.Matrix.Eye(3),a=t.block(0,1,0,o-1),A=t.block(0,1,o,2*o-1),c=n.mask||ze.default.Matrix.Zeros(1,o);return ze.default.Matrix.findAffineTransform(r.block(0,1,0,2),a,A,Object.assign({mask:c},n)).then(u=>{let g=r.at(0,0);if(Number.isNaN(g))throw new xt("Can't compute an affine warp: bad keypoints");let f=0,b=c.read();for(let y=0;y<o;y++)f+=b[y];let d=f/o;return[r,d]})}static findPolylineNDC(t){let n=t.read(),o=[-1,1,-1,-1,1,-1,1,1],r=new Array(4);for(let a=0,A=0;a<4;a++,A+=2){let c=o[A],u=o[A+1],g=n[0]*c+n[3]*u+n[6],f=n[1]*c+n[4]*u+n[7],b=n[2]*c+n[5]*u+n[8];r[a]=ze.default.Point2(g/b,f/b)}return r}static refineMatchingPairs(t){let n=t.length,o=new Array(n);for(let c=0;c<n;c++)o[c]=t[c][1];let r=this._distributeKeypoints(o),a=r.length,A=new Array(a);for(let c=0;c<a;c++)A[c]=t[r[c]];return A}static _distributeKeypoints(t){let n=os,o=n*n,r=t.length,a=new Array(2*r);for(let g=0,f=0;g<r;g++,f+=2)a[f]=t[g].x,a[f+1]=t[g].y;this._normalizePoints(a);let A=new Array(o).fill(-1);for(let g=0,f=0;g<r;g++,f+=2){let b=Math.floor(a[f]*n),y=Math.floor(a[f+1]*n)*n+b;A[y]<0&&(A[y]=g)}let c=0,u=new Array(o);for(let g=0;g<o;g++)A[g]>=0&&(u[c++]=A[g]);return u.length=c,u}static _normalizePoints(t){X.assert(t.length%2==0);let n=t.length/2;if(n==0)return t;let o=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,a=Number.POSITIVE_INFINITY,A=Number.NEGATIVE_INFINITY;for(let g=0,f=0;g<n;g++,f+=2){let b=t[f],d=t[f+1];o=b<o?b:o,a=d<a?d:a,r=b>r?b:r,A=d>A?d:A}let c=r-o+1,u=A-a+1;for(let g=0,f=0;g<n;g++,f+=2)t[f]=(t[f]-o)/c,t[f+1]=(t[f+1]-a)/u;return t}}});var Re,Li,Os=le(()=>{"use strict";Re=Ne(be(),1);vn();dn();Fe();Ke();Ft();Li=class extends tt{constructor(n){super("training",n);this._currentImageIndex=0;this._trainingMap={keypoints:[],referenceImageIndex:[],referenceImages:[]}}onEnterState(n){let o=this._imageTracker.database;if(o.count==0)throw new _i("Can't train the Image Tracker: the Reference Image Database is empty");this._currentImageIndex=0,this._trainingMap.keypoints.length=0,this._trainingMap.referenceImageIndex.length=0,this._trainingMap.referenceImages.length=0,X.log(`Image Tracker: training using ${o.count} reference image${o.count!=1?"s":""}`),o._lock();for(let r of o)this._trainingMap.referenceImages.push(r)}onLeaveState(){this._pipeline.release(),this._pipelineReleased=!0}_beforeUpdate(){let n=this._pipeline.node("source"),o=this._pipeline.node("screen"),r=this._pipeline.node("keypointScaler"),a=this._trainingMap.referenceImages[this._currentImageIndex];n.media=a.media;let A=this._imageTracker.resolution,c=.8,u=a.aspectRatio;return o.size=X.resolution(A,u),o.size.width=Math.round(o.size.width*c),o.size.height=Math.round(o.size.height*c),r.transform=oe.rasterToNIS(o.size),X.log(`Image Tracker: training using reference image "${a.name}" at ${o.size.width}x${o.size.height}...`),Re.default.Promise.resolve()}_afterUpdate(n){let o=this._trainingMap.referenceImages[this._currentImageIndex],r=n.keypoints,a=n.image;X.log(`Image Tracker: found ${r.length} keypoints in reference image "${o.name}"`);let A={keypointsNIS:a!==void 0?r:void 0,image:a};for(let c=0;c<r.length;c++)this._trainingMap.keypoints.push(r[c]),this._trainingMap.referenceImageIndex.push(this._currentImageIndex);return++this._currentImageIndex,this._currentImageIndex<this._trainingMap.referenceImages.length?Re.default.Promise.resolve({nextState:"training",trackerOutput:A}):Re.default.Promise.resolve({nextState:"scanning",trackerOutput:A,nextStateSettings:{database:this._trainingMap.keypoints}})}_createPipeline(){let n=Re.default.Pipeline(),o=Re.default.Image.Source("source"),r=Re.default.Transform.Resize("screen"),a=Re.default.Filter.Greyscale(),A=Re.default.Filter.GaussianBlur(),c=Re.default.Filter.Nightvision(),u=Re.default.Image.Multiplexer("nightvisionMux"),g=Re.default.Image.Pyramid(),f=Re.default.Keypoint.Detector.FAST("fast"),b=Re.default.Keypoint.Descriptor.ORB(),d=Re.default.Keypoint.SubpixelRefiner(),y=Re.default.Image.Pyramid(),I=Re.default.Filter.GaussianBlur(),x=Re.default.Keypoint.Clipper(),S=Re.default.Keypoint.Transformer("keypointScaler"),M=Re.default.Keypoint.Sink("keypoints");return o.media=null,r.size=Re.default.Size(0,0),A.kernelSize=Re.default.Size(Ze,Ze),A.sigma=Re.default.Vector2($e,$e),c.gain=Ct,c.offset=Pt,c.decay=vt,c.quality=lt,u.port=yi?1:0,f.levels=4,f.scaleFactor=1.19,f.threshold=60,f.capacity=8192,d.method=bt,I.kernelSize=Re.default.Size(At,At),I.sigma=Re.default.Vector2(dt,dt),x.size=1024,S.transform=Re.default.Matrix.Eye(3),M.turbo=!1,o.output().connectTo(r.input()),r.output().connectTo(a.input()),a.output().connectTo(u.input("in0")),a.output().connectTo(c.input()),c.output().connectTo(u.input("in1")),u.output().connectTo(g.input()),g.output().connectTo(f.input()),f.output().connectTo(x.input()),a.output().connectTo(I.input()),I.output().connectTo(y.input()),x.output().connectTo(d.input("keypoints")),y.output().connectTo(d.input("image")),a.output().connectTo(A.input()),A.output().connectTo(b.input("image")),d.output().connectTo(b.input("keypoints")),b.output().connectTo(S.input()),S.output().connectTo(M.input()),n.init(o,r,a,c,u,g,f,A,b,x,I,y,d,S,M),n}referenceImageOfKeypoint(n){let o=this.referenceImageIndexOfKeypoint(n);return o<0?null:this._trainingMap.referenceImages[o]}referenceImageIndexOfKeypoint(n){let o=this._trainingMap.referenceImageIndex.length;if(n<0||n>=o)return-1;let r=this._trainingMap.referenceImageIndex[n];return r<0||r>=this._trainingMap.referenceImages.length?-1:r}referenceKeypoint(n){return n<0||n>=this._trainingMap.keypoints.length?null:this._trainingMap.keypoints[n]}}});var Me,$r,Id,Oi,Fs=le(()=>{"use strict";Me=Ne(be(),1);vn();dn();Fe();Ke();Ft();$r=0,Id=1,Oi=class extends tt{constructor(t){super("scanning",t),this._counter=0,this._bestScore=0,this._bestHomography=Me.default.Matrix.Eye(3)}onEnterState(t){let n=this._pipeline.node("imagePortalMux"),o=this._pipeline.node("lshTables"),r=t.database;this._counter=0,this._bestScore=0,n.port=$r,r!==void 0&&(o.keypoints=r)}_beforeUpdate(){let t=this._pipeline.node("keypointScaler"),n=this.screenSize;return t.transform=oe.rasterToNIS(n),Me.default.Promise.resolve()}_afterUpdate(t){let n=this._pipeline.node("imagePortalMux"),o=t.keypoints,r=t.image,a={keypointsNIS:o,polylineNDC:[],image:r};n.port=Id;let A=this._selectGoodMatches(o);if(A.length<20)return this._counter=0,this._bestScore=0,Me.default.Promise.resolve({nextState:"scanning",trackerOutput:a});let c=this._findMatchingPairs(A),u=oe.compilePairsOfKeypointsNDC(c);return this._findHomographyNDC(u).then(([g,f])=>{f>=this._bestScore&&this._counter<29&&(this._bestScore=f,this._bestHomography=g,n.port=$r);let b=oe.findPolylineNDC(g);if(a.polylineNDC.push(...b),++this._counter<30)return{nextState:"scanning",trackerOutput:a};let d=this._pipeline.node("imagePortalSink"),y=this._imageTracker._referenceImageOfKeypoint(A[0].matches[0].index);if(!y)throw new kn("Can't track an unknown reference image");return{nextState:"pre-tracking-a",nextStateSettings:{homography:this._bestHomography,snapshot:d,referenceImage:y},trackerOutput:a}}).catch(g=>(X.warning(`Error when scanning: ${g.toString()}`),{nextState:"scanning",trackerOutput:a}))}_selectGoodMatches(t){let n=Object.create(null);for(let r=t.length-1;r>=0;r--){let a=t[r];if(a.matches[0].index>=0&&a.matches[1].index>=0){let A=a.matches[0].distance,c=a.matches[1].distance;if(A<=.7*c){let u=this._imageTracker._referenceImageIndexOfKeypoint(a.matches[0].index);u>=0&&(Object.prototype.hasOwnProperty.call(n,u)||(n[u]=[]),n[u].push(a))}}}let o=[];for(let r in n)n[r].length>o.length&&(o=n[r]);return o}_findHomographyNDC(t){return oe.findPerspectiveWarpNDC(t,{method:"pransac",reprojectionError:Vo,numberOfHypotheses:512*2,bundleSize:128})}_findMatchingPairs(t){let n=new Array(t.length);for(let o=t.length-1;o>=0;o--){let r=t[o],a=this._imageTracker._referenceKeypoint(r.matches[0].index);if(a==null)throw new kn(`Invalid keypoint match index: ${r.matches[0].index} from ${r.toString()}`);n[o]=[a,r]}return n}_createPipeline(){let t=Me.default.Pipeline(),n=Me.default.Image.Source("source"),o=Me.default.Transform.Resize("screen"),r=Me.default.Filter.Greyscale(),a=Me.default.Filter.GaussianBlur(),A=Me.default.Filter.Nightvision(),c=Me.default.Image.Multiplexer("nightvisionMux"),u=Me.default.Image.Pyramid(),g=Me.default.Keypoint.Detector.FAST(),f=Me.default.Keypoint.Descriptor.ORB(),b=Me.default.Keypoint.Clipper(),d=Me.default.Keypoint.Matcher.StaticLSHTables("lshTables"),y=Me.default.Keypoint.Matcher.LSHKNN(),I=Me.default.Keypoint.Transformer("keypointScaler"),x=Me.default.Keypoint.SinkOfMatchedKeypoints("keypoints"),S=Me.default.Image.Portal.Sink("imagePortalSink"),M=Me.default.Image.Portal.Source("imagePortalSource"),N=Me.default.Image.Multiplexer("imagePortalMux"),E=Me.default.Image.Buffer(),R=Me.default.Transform.Resize();return n.media=null,o.size=Me.default.Size(0,0),a.kernelSize=Me.default.Size(Ze,Ze),a.sigma=Me.default.Vector2($e,$e),A.gain=Ct,A.offset=Pt,A.decay=vt,A.quality=lt,c.port=yi?1:0,g.levels=4,g.scaleFactor=1.19,g.threshold=60,g.capacity=2048,b.size=512,d.keypoints=[],d.numberOfTables=Jo,d.hashSize=jo,y.k=2,y.quality="default",M.source=S,N.port=$r,R.size=Me.default.Size(0,0),R.scale=Me.default.Vector2(1,1),I.transform=Me.default.Matrix.Eye(3),x.turbo=!0,n.output().connectTo(o.input()),o.output().connectTo(r.input()),r.output().connectTo(a.input()),r.output().connectTo(c.input("in0")),r.output().connectTo(A.input()),A.output().connectTo(c.input("in1")),c.output().connectTo(u.input()),u.output().connectTo(g.input()),g.output().connectTo(b.input()),a.output().connectTo(f.input("image")),b.output().connectTo(f.input("keypoints")),f.output().connectTo(y.input("keypoints")),d.output().connectTo(y.input("lsh")),b.output().connectTo(I.input()),I.output().connectTo(x.input()),y.output().connectTo(x.input("matches")),n.output().connectTo(E.input()),E.output().connectTo(N.input("in0")),M.output().connectTo(R.input()),R.output().connectTo(N.input("in1")),N.output().connectTo(S.input()),t.init(n,o,r,a,A,c,u,g,f,b,d,y,I,x,S,M,N,E,R),t}}});var Te,zi,Us=le(()=>{"use strict";Te=Ne(be(),1);vn();dn();Fe();Ft();zi=class extends tt{constructor(t){super("pre-tracking-a",t),this._homography=Te.default.Matrix.Eye(3),this._referenceImage=null,this._snapshot=null}onEnterState(t){let n=t.homography,o=t.referenceImage,r=t.snapshot;this._homography=n,this._referenceImage=o,this._snapshot=r}_beforeUpdate(){let t=this.screenSize,n=this._pipeline.node("source"),o=this._pipeline.node("imageRectifier"),r=this._pipeline.node("keypointScaler"),a=this._pipeline.node("borderClipper");n.media=this._referenceImage.media,a.imageSize=t,a.borderSize=Te.default.Vector2(t.width*zt,t.height*zt),r.transform=oe.rasterToNIS(t);let A=wt,c=oe.bestFitAspectRatioNDC(t,this._referenceImage),u=oe.bestFitScaleNDC(c,A),g=oe.NDCToRaster(t),f=oe.rasterToNDC(t);return o.transform.setTo(g.times(u).times(f)).then(()=>{})}_afterUpdate(t){let n=this._referenceImage,o=this._pipeline.node("keypointPortalSink"),r=t.keypoints,a=t.image,A={keypointsNIS:a!==void 0?r:void 0,image:a};return r.length<Si?(X.warning(`Can't pre-track "${n.name}" in ${this.name}!`),Te.default.Promise.resolve({nextState:"scanning",trackerOutput:A})):Te.default.Promise.resolve({nextState:"pre-tracking-b",trackerOutput:A,nextStateSettings:{referenceKeypointPortalSink:o,referenceImage:this._referenceImage,snapshot:this._snapshot,homography:this._homography}})}_createPipeline(){let t=Te.default.Pipeline(),n=Te.default.Image.Source("source"),o=Te.default.Transform.Resize("screen"),r=Te.default.Filter.Greyscale(),a=Te.default.Transform.PerspectiveWarp("imageRectifier"),A=Te.default.Filter.Nightvision(),c=Te.default.Image.Multiplexer(),u=Te.default.Keypoint.Detector.Harris(),g=Te.default.Keypoint.Descriptor.ORB(),f=Te.default.Filter.GaussianBlur(),b=Te.default.Keypoint.Clipper(),d=Te.default.Keypoint.BorderClipper("borderClipper"),y=Te.default.Filter.GaussianBlur(),I=Te.default.Keypoint.SubpixelRefiner(),x=Te.default.Keypoint.Transformer("keypointScaler"),S=Te.default.Keypoint.Portal.Sink("keypointPortalSink"),M=Te.default.Keypoint.Sink("keypoints");return n.media=null,a.transform=Te.default.Matrix.Eye(3),o.size=Te.default.Size(0,0),A.gain=Ct,A.offset=Pt,A.decay=vt,A.quality=lt,c.port=En?1:0,f.kernelSize=Te.default.Size(Ze,Ze),f.sigma=Te.default.Vector2($e,$e),y.kernelSize=Te.default.Size(At,At),y.sigma=Te.default.Vector2(dt,dt),u.quality=Sn,u.capacity=yn,I.method=bt,b.size=_n,d.imageSize=o.size,d.borderSize=Te.default.Vector2(0,0),x.transform=Te.default.Matrix.Eye(3),M.turbo=!1,n.output().connectTo(o.input()),o.output().connectTo(r.input()),r.output().connectTo(a.input()),a.output().connectTo(c.input("in0")),a.output().connectTo(A.input()),A.output().connectTo(c.input("in1")),c.output().connectTo(u.input()),u.output().connectTo(d.input()),d.output().connectTo(b.input()),a.output().connectTo(y.input()),y.output().connectTo(I.input("image")),b.output().connectTo(I.input("keypoints")),c.output().connectTo(f.input()),f.output().connectTo(g.input("image")),I.output().connectTo(g.input("keypoints")),g.output().connectTo(x.input()),x.output().connectTo(M.input()),x.output().connectTo(S.input()),t.init(n,o,r,a,A,c,u,d,b,y,I,f,g,x,M,S),t}}});var me,Xs,_d,Fi,Gs=le(()=>{"use strict";me=Ne(be(),1);vn();dn();Fe();Ke();Ft();Xs=0,_d=1,Fi=class extends tt{constructor(t){super("pre-tracking-b",t),this._homography=me.default.Matrix.Eye(3),this._referenceImage=null,this._snapshot=null,this._referenceKeypointPortalSink=null,this._iterations=0}onEnterState(t){let n=t.homography,o=t.referenceImage,r=t.snapshot,a=t.referenceKeypointPortalSink,A=this._pipeline.node("sourceMux"),c=this._pipeline.node("sourceBuffer");this._homography=n,this._referenceImage=o,this._snapshot=r,this._referenceKeypointPortalSink=a,this._iterations=0,A.port=Xs,c.frozen=!1}_beforeUpdate(){let t=this.screenSize,n=this._pipeline.node("imageRectifier"),o=this._pipeline.node("keypointScaler"),r=this._pipeline.node("borderClipper"),a=this._pipeline.node("imagePortalSource"),A=this._pipeline.node("referenceKeypointPortalSource");a.source=this._snapshot,A.source=this._referenceKeypointPortalSink,r.imageSize=t,r.borderSize=me.default.Vector2(t.width*zt,t.height*zt),o.transform=oe.rasterToNIS(t);let c=wt,u=oe.bestFitAspectRatioNDC(t,this._referenceImage),g=oe.bestFitScaleNDC(u,c),f=this._homography.inverse(),b=oe.NDCToRaster(t),d=oe.rasterToNDC(t);return n.transform.setTo(b.times(g.times(f)).times(d)).then(()=>{})}_afterUpdate(t){let n=this._referenceImage,o=t.referenceKeypoints,r=t.keypoints,a=t.image,A=this._pipeline.node("keypointPortalSink"),c=this._pipeline.node("sourceMux"),u=this._pipeline.node("sourceBuffer"),g={keypointsNIS:a!==void 0?r:void 0,image:a};return me.default.Promise.resolve().then(()=>{let f=this._findMatchingPairs(o,r);if(f.length<Si)throw new gt("Not enough data points");let b=oe.compilePairsOfKeypointsNDC(f);return this._findMotionNDC(b)}).then(f=>(c.port=_d,u.frozen=!0,oe.interpolateHomographies(this._homography,me.default.Matrix(f.times(this._homography)),es,ts))).then(f=>this._homography.setTo(f)).then(f=>({nextState:++this._iterations<ns?"pre-tracking-b":"tracking",trackerOutput:g,nextStateSettings:{templateKeypoints:r,templateKeypointPortalSink:A,referenceImage:this._referenceImage,homography:this._homography,initialScreenSize:this.screenSize}})).catch(f=>(X.warning(`Can't pre-track "${n.name}" in ${this.name}! ${f.toString()}`),{nextState:"scanning",trackerOutput:g}))}_findMotionNDC(t){return oe.findPerspectiveWarpNDC(t,{method:"pransac",reprojectionError:$o,numberOfHypotheses:512,bundleSize:128,mask:void 0}).then(([n,o])=>{let r=wt,a=oe.bestFitAspectRatioNDC(this.screenSize,this._referenceImage),A=oe.bestFitScaleNDC(a,r),u=oe.inverseBestFitScaleNDC(a,r).times(n).times(A),g=this._homography,f=g.inverse();return g.times(u).times(f)})}_findMatchingPairs(t,n){let o=[];for(let r=0;r<n.length;r++){let a=n[r];if(a.matches[0].index>=0&&a.matches[1].index>=0){let A=a.matches[0].distance,c=a.matches[1].distance;if(A<=Zo*c){let u=t[a.matches[0].index];o.push([u,a])}}}return o}_createPipeline(){let t=me.default.Pipeline(),n=me.default.Image.Source("source"),o=me.default.Image.Portal.Source("imagePortalSource"),r=me.default.Image.Multiplexer("sourceMux"),a=me.default.Image.Buffer("sourceBuffer"),A=me.default.Keypoint.Portal.Source("referenceKeypointPortalSource"),c=me.default.Transform.Resize("screen"),u=me.default.Filter.Greyscale(),g=me.default.Transform.PerspectiveWarp("imageRectifier"),f=me.default.Filter.Nightvision(),b=me.default.Image.Multiplexer(),d=me.default.Keypoint.Detector.Harris(),y=me.default.Keypoint.Descriptor.ORB(),I=me.default.Filter.GaussianBlur(),x=me.default.Keypoint.Clipper(),S=me.default.Keypoint.BorderClipper("borderClipper"),M=me.default.Filter.GaussianBlur(),N=me.default.Keypoint.SubpixelRefiner(),E=me.default.Keypoint.Matcher.BFKNN(),R=me.default.Keypoint.Transformer("keypointScaler"),B=me.default.Keypoint.SinkOfMatchedKeypoints("keypoints"),Q=me.default.Keypoint.Portal.Sink("keypointPortalSink"),U=me.default.Keypoint.Sink("referenceKeypoints");return n.media=null,o.source=null,r.port=Xs,a.frozen=!1,A.source=null,g.transform=me.default.Matrix.Eye(3),c.size=me.default.Size(0,0),f.gain=Ct,f.offset=Pt,f.decay=vt,f.quality=lt,b.port=En?1:0,I.kernelSize=me.default.Size(Ze,Ze),I.sigma=me.default.Vector2($e,$e),M.kernelSize=me.default.Size(At,At),M.sigma=me.default.Vector2(dt,dt),d.quality=Sn,d.capacity=yn,N.method=bt,x.size=_n,S.imageSize=c.size,S.borderSize=me.default.Vector2(0,0),E.k=2,R.transform=me.default.Matrix.Eye(3),B.turbo=!1,o.output().connectTo(r.input("in0")),n.output().connectTo(a.input()),a.output().connectTo(r.input("in1")),r.output().connectTo(c.input()),c.output().connectTo(u.input()),u.output().connectTo(g.input()),g.output().connectTo(b.input("in0")),g.output().connectTo(f.input()),f.output().connectTo(b.input("in1")),b.output().connectTo(d.input()),d.output().connectTo(S.input()),S.output().connectTo(x.input()),g.output().connectTo(M.input()),M.output().connectTo(N.input("image")),x.output().connectTo(N.input("keypoints")),b.output().connectTo(I.input()),I.output().connectTo(y.input("image")),N.output().connectTo(y.input("keypoints")),y.output().connectTo(E.input("keypoints")),A.output().connectTo(E.input("database")),y.output().connectTo(R.input()),R.output().connectTo(Q.input()),R.output().connectTo(B.input()),E.output().connectTo(B.input("matches")),A.output().connectTo(U.input()),t.init(n,o,a,r,c,A,u,g,f,b,d,S,x,M,N,I,y,E,R,B,Q,U),t}}});var qn,Hs=le(()=>{"use strict";Kn();qn=class extends Jt{constructor(t,n){super(t),this._referenceImage=n}get referenceImage(){return this._referenceImage}}});var eo,Ui,Rt,to=le(()=>{"use strict";eo=Ne(be(),1);Ke();Ui=1e-6,Rt=class _{constructor(t=0,n=0,o=0,r=1){this._x=+t,this._y=+n,this._z=+o,this._w=+r}static Identity(){return new _(0,0,0,1)}static FromAxisAngle(t,n){if(t.dot(t)<Ui*Ui)return _.Identity();let o=Math.sin(n/2),r=Math.cos(n/2),a=t.normalized(),A=a.x*o,c=a.y*o,u=a.z*o,g=r;return new _(A,c,u,g)}get x(){return this._x}get y(){return this._y}get z(){return this._z}get w(){return this._w}length(){let t=this._x,n=this._y,o=this._z,r=this._w;return Math.sqrt(t*t+n*n+o*o+r*r)}equals(t){return this._w===t._w&&this._x===t._x&&this._y===t._y&&this._z===t._z}toString(){let t=this._x.toFixed(4),n=this._y.toFixed(4),o=this._z.toFixed(4),r=this._w.toFixed(4);return`Quaternion(${t},${n},${o},${r})`}_normalize(){let t=this.length();return t<Ui?this:(this._x/=t,this._y/=t,this._z/=t,this._w/=t,this)}_conjugate(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this}_set(t,n,o,r){return this._x=+t,this._y=+n,this._z=+o,this._w=+r,this}_copyFrom(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._w=t._w,this}_toRotationMatrix(){let t=this.length();if(t<Ui)return eo.default.Matrix.Eye(3);let n=this._x/t,o=this._y/t,r=this._z/t,a=this._w/t,A=2*n*n,c=2*o*o,u=2*r*r,g=2*n*o,f=2*n*r,b=2*o*r,d=2*a*n,y=2*a*o,I=2*a*r;return eo.default.Matrix(3,3,[1-(c+u),g+I,f-y,g-I,1-(A+u),b+d,f+y,b-d,1-(A+c)])}_fromRotationMatrix(t){if(t.rows!=3||t.columns!=3)throw new Z;let n=t.read(),o=n[0],r=n[1],a=n[2],A=n[3],c=n[4],u=n[5],g=n[6],f=n[7],b=n[8],d=1+o+c+b,y=+(u>=f)-+(u<f),I=+(g>=a)-+(g<a),x=+(r>=A)-+(r<A),S=.5*Math.sqrt(Math.max(0,d)),M=.5*Math.sqrt(Math.max(0,d-2*(c+b))),N=.5*Math.sqrt(Math.max(0,d-2*(o+b))),E=.5*Math.sqrt(Math.max(0,d-2*(o+c))),R=Math.sqrt(M*M+N*N+E*E+S*S);return this._x=M*y/R,this._y=N*I/R,this._z=E*x/R,this._w=S/R,this}_clone(){return new _(this._x,this._y,this._z,this._w)}}});var yd,qs,Ue,Wn=le(()=>{"use strict";yd=1e-6,qs=null,Ue=class _{constructor(t=0,n=0,o=0){this._x=+t,this._y=+n,this._z=+o}static Zero(){return new _(0,0,0)}static get ZERO(){return qs||(qs=Object.freeze(_.Zero()))}get x(){return this._x}get y(){return this._y}get z(){return this._z}length(){let t=this._x,n=this._y,o=this._z;return Math.sqrt(t*t+n*n+o*o)}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z}distanceTo(t){let n=this._x-t._x,o=this._y-t._y,r=this._z-t._z;return Math.sqrt(n*n+o*o+r*r)}directionTo(t){return t._clone()._subtract(this)._normalize()}cross(t){let n=this._y*t._z-this._z*t._y,o=this._z*t._x-this._x*t._z,r=this._x*t._y-this._y*t._x;return new _(n,o,r)}normalized(){return this._clone()._normalize()}plus(t){return this._clone()._add(t)}minus(t){return this._clone()._subtract(t)}times(t){return this._clone()._scale(t)}equals(t){return this._x===t._x&&this._y===t._y&&this._z===t._z}toString(){let t=this._x.toFixed(5),n=this._y.toFixed(5),o=this._z.toFixed(5);return`Vector3(${t},${n},${o})`}_set(t,n,o){return this._x=+t,this._y=+n,this._z=+o,this}_copyFrom(t){return this._x=t._x,this._y=t._y,this._z=t._z,this}_normalize(){let t=this.length();return t<yd?this:(this._x/=t,this._y/=t,this._z/=t,this)}_add(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this}_subtract(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this}_scale(t){return this._x*=t,this._y*=t,this._z*=t,this}_applyRotationQuaternion(t){let n=t.x,o=t.y,r=t.z,a=t.w,A=this._x,c=this._y,u=this._z,g=n*n,f=o*o,b=r*r,d=2*n*o,y=2*n*r,I=2*o*r,x=2*a*n,S=2*a*o,M=2*a*r;return this._x=(1-2*(f+b))*A+(d-M)*c+(y+S)*u,this._y=(d+M)*A+(1-2*(g+b))*c+(I-x)*u,this._z=(y-S)*A+(I+x)*c+(1-2*(g+f))*u,this}_clone(){return new _(this._x,this._y,this._z)}}});var Ys,Xi,Gi,Ws,Sd,Ed,Hi,Vs=le(()=>{"use strict";Ys=Ne(be(),1);Cn();to();Wn();Ke();Xi=5,Gi=12,Ws=Ue.Zero(),Sd=Rt.Identity(),Ed=new Rt(0,0,0,0),Hi=class{constructor(){this._smoothRotation=Rt.Identity(),this._smoothTranslation=Ue.Zero(),this._rotationSample=Array.from({length:Gi},()=>Rt.Identity()),this._translationSample=Array.from({length:Xi},()=>Ue.Zero()),this._isEmpty=!0}reset(){this._rotationSample.forEach(t=>t._copyFrom(Sd)),this._translationSample.forEach(t=>t._copyFrom(Ws)),this._isEmpty=!0}feed(t){let n=t.read();if(t.rows!=3||t.columns!=4)throw new Z;if(Number.isNaN(n[0]*n[9]))return!1;let o=this._rotationSample[Gi-1];for(let a=Gi-1;a>0;a--)this._rotationSample[a]=this._rotationSample[a-1];this._rotationSample[0]=o._fromRotationMatrix(t.block(0,2,0,2));let r=this._translationSample[Xi-1];for(let a=Xi-1;a>0;a--)this._translationSample[a]=this._translationSample[a-1];return this._translationSample[0]=r._set(n[9],n[10],n[11]),this._isEmpty&&(this._rotationSample.forEach((a,A)=>A>0&&a._copyFrom(this._rotationSample[0])),this._translationSample.forEach((a,A)=>A>0&&a._copyFrom(this._translationSample[0])),this._isEmpty=!1),!0}output(){let t=We.powerPreference=="low-power"?1.5:1,n=Math.ceil(Xi/t),o=Math.ceil(Gi/t),r=this._smoothTranslation._copyFrom(Ws),a=this._smoothRotation._copyFrom(Ed);for(let c=0,u=2/(n*n+n);c<n;c++){let g=this._translationSample[c],f=(n-c)*u;r._set(r.x+g.x*f,r.y+g.y*f,r.z+g.z*f)}for(let c=0;c<o;c++){let u=this._rotationSample[c],g=1/o;u.w<0&&u._set(-u.x,-u.y,-u.z,-u.w),a._set(a.x+u.x*g,a.y+u.y*g,a.z+u.z*g,a.w+u.w*g)}let A=a._toRotationMatrix().read();return A.push(r.x,r.y,r.z),Ys.default.Matrix(3,4,A)}}});var He,xd,Zs,Cd,Pd,Yn,qi,Js,js,vd,bd,wd,Md,Vn,$s=le(()=>{"use strict";He=Ne(be(),1);Fe();Vs();Ke();xd=60,Zs=2,Cd=.017453292519943295,Pd=1e-6,Yn=0,qi=4,Js=6,js=7,vd=30,bd=15,wd=Zs*.01,Md=5,Vn=class{constructor(){this._imageSize=He.default.Size(0,0),this._matrix=He.default.Matrix.Eye(3,4),this._intrinsics=[1,0,0,0,1,0,0,0,1],this._extrinsics=[1,0,0,0,1,0,0,0,1,0,0,0],this._filter=new Hi,this._flipZ=He.default.Matrix(4,4,[1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1])}init(t,n=Zs){X.log("Initializing the camera model..."),X.assert(t>0&&n>1e-5),t>=1?(this._imageSize.width=t*n,this._imageSize.height=n):(this._imageSize.width=n,this._imageSize.height=n/t),this.reset()}release(){return this.reset(),null}update(t){X.assert(t.rows==3&&t.columns==3);let n=this._convertToImageSpace(t),o=n.read(),r=o[0],a=o[3],A=o[6],c=o[1],u=o[4],g=o[7],f=o[2],b=o[5],d=o[8],y=A*(c*b-u*f)-g*(r*b-a*f)+d*(r*u-a*c);if(Math.abs(y)<Pd||Number.isNaN(y))return He.default.Promise.reject(new xt("Can't update the camera model using an invalid homography matrix"));let I=this._estimatePose(n);this._filter.feed(I)&&(this._extrinsics=this._filter.output().read());let x=this._flipZ,S=He.default.Matrix(3,3,this._intrinsics),M=He.default.Matrix(3,4,this._extrinsics);return this._matrix.setToSync(S.times(M).times(x)),He.default.Promise.resolve(this._matrix)}reset(){this._resetIntrinsics(),this._resetExtrinsics()}get matrix(){return this._matrix}get imageSize(){return this._imageSize}get aspectRatio(){return this._imageSize.width/this._imageSize.height}get focalLength(){return this._intrinsics[Yn]}get fovx(){let t=this._imageSize.width/2;return 2*Math.atan(t/this._intrinsics[Yn])}get fovy(){let t=this._imageSize.height/2;return 2*Math.atan(t/this._intrinsics[qi])}intrinsicsMatrix(){return He.default.Matrix(3,3,this._intrinsics)}computeViewMatrix(){let t=this._extrinsics;return He.default.Matrix(4,4,[t[0],t[1],-t[2],0,t[3],t[4],-t[5],0,-t[6],-t[7],+t[8],0,t[9],t[10],-t[11],1])}computeProjectionMatrix(t,n){let o=this._intrinsics[Yn],r=this._intrinsics[qi],a=this._imageSize.width/2,A=this._imageSize.height/2,c=t*(a/o),u=t*(A/r),g=-u,f=-c;return He.default.Matrix(4,4,[2*t/(c-f),0,0,0,0,2*t/(u-g),0,0,(c+f)/(c-f),(u+g)/(u-g),-(n+t)/(n-t),-1,0,0,-2*n*t/(n-t),0])}_resetExtrinsics(){this._extrinsics.fill(0),this._extrinsics[0]=this._extrinsics[4]=this._extrinsics[8]=1,this._filter.reset()}_resetIntrinsics(){let t=Math.max(this._imageSize.width,this._imageSize.height),n=0,o=0,r=t/2/Math.tan(Cd*xd/2),a=r;this._intrinsics[Yn]=r,this._intrinsics[qi]=a,this._intrinsics[Js]=n,this._intrinsics[js]=o}_convertToImageSpace(t){let n=this._imageSize.width/2,o=this._imageSize.height/2,r=He.default.Matrix(3,3,[n,0,0,0,o,0,0,0,1]);return He.default.Matrix(r.times(t))}_normalizeHomography(t){let n=this._intrinsics[Js],o=this._intrinsics[js],r=this._intrinsics[Yn],a=this._intrinsics[qi],A=n/r,c=o/a,u=t.read(),g=u[0]/r-A*u[2],f=u[3]/r-A*u[5],b=u[6]/r-A*u[8],d=u[1]/a-c*u[2],y=u[4]/a-c*u[5],I=u[7]/a-c*u[8],x=u[2],S=u[5],M=u[8];return He.default.Matrix(3,3,[g,d,x,f,y,S,b,I,M])}_estimatePartialPose(t){let n=t.read(),o=n[0],r=n[3],a=n[6],A=n[1],c=n[4],u=n[7],g=n[2],f=n[5],b=n[8],d=o*o+A*A+g*g,y=r*r+c*c+f*f,I=Math.sqrt(d),x=Math.sqrt(y),S=Math.max(I,x),N=(b>=0?1:-1)/S;if(Number.isNaN(N))return He.default.Matrix(3,3,new Array(9).fill(Number.NaN));let E=new Array(6);E[0]=N*o,E[1]=N*A,E[2]=N*g,E[3]=N*r,E[4]=N*c,E[5]=N*f,E=this._refineRotation(E),N=E[0]*o+E[1]*A+E[2]*g,N+=E[3]*r+E[4]*c+E[5]*f,N/=d+y;let R=new Array(3);return R[0]=N*a,R[1]=N*u,R[2]=N*b,He.default.Matrix(3,3,E.concat(R))}_refineRotation(t){let[n,o,r,a,A,c]=t,u=n*n+o*o+r*r,g=a*a+A*A+c*c,f=n*a+o*A+r*c,b=(u-g)*(u-g)+4*f*f,d=Math.sqrt(b),y=(u+g+d)/2,I=(u+g-d)/2,x=g-y-f*(1+f)/(u-y),S=Math.sqrt(x*x/(1+x*x)),M=S/x,N=g-I-f*(1+f)/(u-I),E=Math.sqrt(N*N/(1+N*N)),R=E/N,B=Math.sqrt(y),Q=Math.sqrt(I),U=S*S/B+E*E/Q,F=S*M/B+E*R/Q,D=M*M/B+R*R/Q;return[U*n+F*a,U*o+F*A,U*r+F*c,F*n+D*a,F*o+D*A,F*r+D*c]}_refineTranslation(t,n,o){let r=t.read(),a=r[0],A=r[3],c=r[6],u=r[1],g=r[4],f=r[7],b=r[2],d=r[5],y=r[8],I=n[0],x=n[3],S=n[1],M=n[4],N=n[2],E=n[5],R=Md,B=new Array(R*R),Q=new Array(R*R),U=this._imageSize.width/2,F=this._imageSize.height/2;for(let ce=0,K=0;K<R;K++)for(let J=0;J<R;J++,ce++)B[ce]=K/(R-1)*2-1,Q[ce]=J/(R-1)*2-1,B[ce]*=U,Q[ce]*=F;let D=B.length,z=new Array(D),q=new Array(D),j=new Array(D);for(let ce=0;ce<D;ce++)z[ce]=B[ce]*a+Q[ce]*A+c,q[ce]=B[ce]*u+Q[ce]*g+f,j[ce]=B[ce]*b+Q[ce]*d+y;let V=3*D,te=new Array(V*3),ge=new Array(V);for(let ce=0,K=0;K<D;ce+=3,K++)te[ce]=te[ce+V+1]=te[ce+V+V+2]=0,te[ce+V]=-(te[ce+1]=j[K]),te[ce+2]=-(te[ce+V+V]=q[K]),te[ce+V+V+1]=-(te[ce+V+2]=z[K]),ge[ce]=j[K]*(B[K]*S+Q[K]*M)-q[K]*(B[K]*N+Q[K]*E),ge[ce+1]=-j[K]*(B[K]*I+Q[K]*x)+z[K]*(B[K]*N+Q[K]*E),ge[ce+2]=q[K]*(B[K]*I+Q[K]*x)-z[K]*(B[K]*S+Q[K]*M);let Be=new Array(3*D),Oe=new Array(3),Xe=new Array(3*D),qe=new Array(3);qe[0]=o[0],qe[1]=o[1],qe[2]=o[2];for(let ce=0;ce<bd;ce++){for(let ie=0;ie<V;ie++){Be[ie]=0;for(let Ie=0;Ie<3;Ie++)Be[ie]+=te[Ie*V+ie]*qe[Ie];Be[ie]-=ge[ie]}for(let ie=0;ie<3;ie++){Oe[ie]=0;for(let Ie=0;Ie<V;Ie++)Oe[ie]+=te[ie*V+Ie]*Be[Ie]}for(let ie=0;ie<V;ie++){Xe[ie]=0;for(let Ie=0;Ie<3;Ie++)Xe[ie]+=te[Ie*V+ie]*Oe[Ie]}let K=0;for(let ie=0;ie<3;ie++)K+=Oe[ie]*Oe[ie];if(K<wd)break;let J=0;for(let ie=0;ie<V;ie++)J+=Xe[ie]*Xe[ie];let ye=K/J;if(Number.isNaN(ye))break;for(let ie=0;ie<3;ie++)qe[ie]-=ye*Oe[ie]}return qe}_computeFullRotation(t){let n=t[0],o=t[3],r=t[1],a=t[4],A=t[2],c=t[5],u=r*c-A*a,g=A*o-n*c,f=n*a-r*o;return n*(a*f-g*c)-r*(o*f-u*c)+A*(o*g-u*a)<0&&(u=-u,g=-g,f=-f),[n,r,A,o,a,c,u,g,f]}_estimatePose(t){let n=this._normalizeHomography(t),o=He.default.Matrix.Eye(3),r=He.default.Matrix(n);for(let f=0;f<vd;f++){let b=this._estimatePartialPose(r);o.setToSync(b.times(o)),r.setToSync(r.times(b.inverse()))}let a=o.read(),A=a.slice(0,6),c=a.slice(6,9),u=this._refineTranslation(n,A,c),g=this._computeFullRotation(A);return He.default.Matrix(3,4,g.concat(u))}}});var nn,Wi=le(()=>{"use strict";nn=class{constructor(t){this._transform=t}get transform(){return this._transform}}});var no,bn,rn,Yi=le(()=>{"use strict";no=Ne(be(),1);Ke();Wn();to();bn=1e-6,rn=class _{constructor(t){if(t.rows!=4||t.columns!=4)throw new Z("A Transform expects a 4x4 transformation matrix");this._matrix=t,this._inverse=null,this._position=Ue.Zero(),this._orientation=Rt.Identity(),this._scale=new Ue(1,1,1),this._isDecomposed=!1,this._isPositionComputed=!1,this._right=Ue.ZERO,this._up=Ue.ZERO,this._forward=Ue.ZERO}get matrix(){return this._matrix}get inverse(){return this._inverse===null&&(this._inverse=new _(this._inverseMatrix())),this._inverse}get position(){return this._isPositionComputed||this._computePosition(),this._position}get orientation(){return this._isDecomposed||this._decompose(),this._orientation}get scale(){return this._isDecomposed||this._decompose(),this._scale}get right(){return this._right===Ue.ZERO&&(this._right=this._scaleAndRotate(new Ue(1,0,0))._normalize()),this._right}get up(){return this._up===Ue.ZERO&&(this._up=this._scaleAndRotate(new Ue(0,1,0))._normalize()),this._up}get forward(){return this._forward===Ue.ZERO&&(this._forward=this._scaleAndRotate(new Ue(0,0,-1))._normalize()),this._forward}_scaleAndRotate(t){let n=this._matrix.read(),o=Math.abs(n[15])<bn?Number.NaN:1/n[15],r=t.x,a=t.y,A=t.z,c=n[0]*r+n[4]*a+n[8]*A,u=n[1]*r+n[5]*a+n[9]*A,g=n[2]*r+n[6]*a+n[10]*A;return t._set(c*o,u*o,g*o)}_decompose(){let t=this._matrix.read(),n=Math.abs(t[15])<bn?Number.NaN:1/t[15],o=t[12]*n,r=t[13]*n,a=t[14]*n,A=t[0]*n,c=t[1]*n,u=t[2]*n,g=t[4]*n,f=t[5]*n,b=t[6]*n,d=t[8]*n,y=t[9]*n,I=t[10]*n,x=d*(c*b-f*u)+I*(A*f-g*c)-y*(A*b-g*u),S=+(x>=0)-+(x<0),M=Math.sqrt(A*A+g*g+d*d),N=Math.sqrt(c*c+f*f+y*y),E=Math.sqrt(u*u+b*b+I*I)*S;if(M<bn||N<bn||E*S<bn){this._position._set(o,r,a),this._scale._set(M,N,E),this._orientation._copyFrom(Rt.Identity()),this._isDecomposed=!0,this._isPositionComputed=!0;return}let R=1/M,B=1/N,Q=1/E,U=A*R,F=c*R,D=u*R,z=g*B,q=f*B,j=b*B,V=d*Q,te=y*Q,ge=I*Q;this._position._set(o,r,a),this._scale._set(M,N,E),this._orientation._fromRotationMatrix(no.default.Matrix(3,3,[U,F,D,z,q,j,V,te,ge])),this._isDecomposed=!0,this._isPositionComputed=!0}_computePosition(){let t=this._matrix.read(),n=Math.abs(t[15])<bn?Number.NaN:1/t[15];this._position._set(t[12]*n,t[13]*n,t[14]*n),this._isPositionComputed=!0}_inverseMatrix(){return no.default.Matrix(this._matrix.inverse())}}});var ea,Vi,ta=le(()=>{"use strict";ea=Ne(be(),1);Wi();Yi();Vi=class extends nn{constructor(t){let n=t.computeViewMatrix(),o=ea.default.Matrix(n.inverse()),r=new rn(o);super(r),this._viewMatrix=n}get viewMatrix(){return this._viewMatrix}}});var na,ia,Td,Ji,ra=le(()=>{"use strict";na=Ne(be(),1);Ke();ia=.1,Td=1e4*ia,Ji=class{constructor(t,n=ia,o=Td){if(this._near=+n,this._far=+o,this._near>=this._far)throw new Z(`View expects near < far (found near = ${this._near} and far = ${this._far})`);if(this._near<=0)throw new Z(`View expects a positive near (found ${this._near})`);this._camera=t,this._projectionMatrix=t.computeProjectionMatrix(this._near,this._far),this._inverseProjection=null}get projectionMatrix(){return this._projectionMatrix}get _projectionMatrixInverse(){return this._inverseProjection===null&&(this._inverseProjection=na.default.Matrix(this._projectionMatrix.inverse())),this._inverseProjection}get aspect(){return this._camera.aspectRatio}get fovx(){return this._camera.fovx}get fovy(){return this._camera.fovy}get near(){return this._near}get far(){return this._far}}});var Jn,oa=le(()=>{"use strict";Jn=class{constructor(t,n){this._origin=t,this._direction=n}get origin(){return this._origin}get direction(){return this._direction}}});var ji,Zi,sa=le(()=>{"use strict";ji=Ne(be(),1);Wi();ta();ra();Yi();Wn();oa();Zi=class{constructor(t){this._pose=new Vi(t),this._views=[new Ji(t)]}get pose(){return this._pose}get view(){return this._views[0]}convertToViewerSpace(t){let n=t.transform.matrix,o=this._pose.viewMatrix,r=ji.default.Matrix(o.times(n)),a=new rn(r);return new nn(a)}raycast(t){let n=this.view._projectionMatrixInverse,o=this._pose.transform.matrix,r=ji.default.Matrix(4,1,[t.x,t.y,0,1]),a=n.times(r),A=o.times(a),c=ji.default.Matrix(A).read(),u=this._pose.transform.position,g=new Ue(c[0]/c[3],c[1]/c[3],c[2]/c[3])._subtract(u)._normalize();return new Jn(u,g)}forwardRay(){let t=this._pose.transform.position,n=this._pose.transform.forward;return new Jn(t,n)}}});var he,aa,Bd,$i,ca=le(()=>{"use strict";he=Ne(be(),1);vn();Hs();dn();Fe();$s();sa();Wi();Yi();Ke();Ft();Cn();aa=!0,Bd=he.default.Matrix.Eye(3),$i=class extends tt{constructor(t){super("tracking",t),this._referenceImage=null,this._warpHomography=he.default.Matrix.Eye(3),this._poseHomography=he.default.Matrix.Eye(3),this._prevHomography=he.default.Matrix.Eye(3),this._templateKeypoints=[],this._initialScreenSize=he.default.Size(1,1),this._lastOutput={},this._lastPipelineOutput={keypoints:[]},this._skipCounter=0,this._counter=0,this._lostCounter=0,this._camera=new Vn,this._fixedCamera=new Vn}onEnterState(t){let n=t.homography,o=t.referenceImage,r=t.templateKeypoints,a=t.templateKeypointPortalSink,A=t.initialScreenSize,c=this._pipeline.node("keypointPortalSource");if(!o)throw new Pe("Can't track a null reference image");this._referenceImage=o,this._warpHomography.setToSync(n),this._poseHomography.setToSync(n),this._prevHomography.setToSync(n),this._templateKeypoints=r,this._initialScreenSize=he.default.Size(A.width,A.height),this._lastOutput={},this._lastPipelineOutput={keypoints:[]},this._skipCounter=0,this._counter=0,this._lostCounter=0,c.source=a;let u=A.width/A.height;this._camera.init(u),this._fixedCamera.init(u);let g=new qn("targetfound",o);this._imageTracker.dispatchEvent(g),X.log(`Tracking image "${o.name}"...`)}onLeaveState(){X.log(`No longer tracking image "${this._referenceImage.name}"!`),this._fixedCamera.release(),this._camera.release();let t=new qn("targetlost",this._referenceImage);this._imageTracker.dispatchEvent(t)}_beforeUpdate(){let t=this._pipeline.node("imageRectifier"),n=this._pipeline.node("borderClipper"),o=this._pipeline.node("keypointScaler"),r=this.screenSize;n.imageSize=r,n.borderSize=he.default.Vector2(r.width*zt,r.height*zt),o.transform=oe.rasterToNIS(r);let a=wt,A=oe.bestFitAspectRatioNDC(r,this._referenceImage),c=oe.bestFitScaleNDC(A,a),u=this._warpHomography.inverse(),g=oe.NDCToRaster(r),f=oe.rasterToNDC(r);return t.transform.setTo(g.times(c.times(u)).times(f)).then(()=>{})}_gpuUpdate(){if(!aa||We.powerPreference=="low-power")return super._gpuUpdate();if((this._skipCounter=1-this._skipCounter)==0){let n=this._lastPipelineOutput.keypoints;return this._lastPipelineOutput.keypoints=n,he.default.Promise.resolve(this._lastPipelineOutput)}return super._gpuUpdate().then(t=>(this._lastPipelineOutput=t,t))}_afterUpdate(t){let n=t.keypoints,o=t.image,r=this._referenceImage,a=this.screenSize;return he.default.Promise.resolve().then(()=>{if(!a.equals(this._initialScreenSize))throw new gt("Detected a change in screen size");let A=this._findMatchingPairs(this._templateKeypoints,n),c=oe.refineMatchingPairs(A);if(c.length<is)throw new gt("Not enough data points to continue the tracking");let u=oe.compilePairsOfKeypointsNDC(c);return this._find6DoFPerspectiveMotionNDC(u)}).then(A=>{let u=We.powerPreference=="low-power"?2:1;return oe.interpolateHomographies(Bd,he.default.Matrix(A),cs*u,ls)}).then(A=>(this._prevHomography.setToSync(this._warpHomography),this._warpHomography.setToSync(A.times(this._warpHomography)),oe.interpolateHomographies(this._prevHomography,this._warpHomography,As,ds))).then(A=>{if(this._poseHomography.setToSync(A),Number.isNaN(this._poseHomography.at(0,0)))throw new xt("Bad homography");let c=oe.bestFitScaleNDC(1/r.aspectRatio),u=he.default.Matrix(this._poseHomography.times(c));return this._camera.update(u)}).then(()=>{let A=this._camera.computeViewMatrix(),c=new rn(A),u=new nn(c),g=new Zi(this._fixedCamera),f={pose:u,referenceImage:r,tracker:this._imageTracker},d={exports:{tracker:this._imageTracker,trackables:[f],viewer:g},keypoints:n,image:o,polylineNDC:oe.findPolylineNDC(this._poseHomography),camera:this._camera};return this._lastOutput=d,this._lostCounter=0,{nextState:"tracking",trackerOutput:d}}).catch(A=>A instanceof gt&&++this._lostCounter<=as?{nextState:"tracking",trackerOutput:this._lastOutput}:(X.warning(`The target has been lost! ${A.toString()}`),{nextState:"scanning",trackerOutput:{}}))}_findAffineMotionNDC(t){return oe.findAffineWarpNDC(t,{method:"pransac",reprojectionError:Ei,numberOfHypotheses:512*2,bundleSize:128,mask:void 0}).then(([n,o])=>{let r=wt,a=oe.bestFitAspectRatioNDC(this.screenSize,this._referenceImage),A=oe.bestFitScaleNDC(a,r),u=oe.inverseBestFitScaleNDC(a,r).times(n).times(A),g=this._warpHomography,f=g.inverse();return g.times(u).times(f)}).catch(n=>{throw new gt("Can't find an affine motion",n)})}_findPerspectiveMotionNDC(t){return oe.findPerspectiveWarpNDC(t,{method:"pransac",reprojectionError:Ei,numberOfHypotheses:512*2,bundleSize:128,mask:void 0}).then(([n,o])=>{let r=wt,a=oe.bestFitAspectRatioNDC(this.screenSize,this._referenceImage),A=oe.bestFitScaleNDC(a,r),u=oe.inverseBestFitScaleNDC(a,r).times(n).times(A),g=this._poseHomography,f=g.inverse();return g.times(u).times(f)}).catch(n=>{throw new gt("Can't find a perspective motion",n)})}_find6DoFPerspectiveMotionNDC(t){let n=this._camera.intrinsicsMatrix();return oe.find6DoFHomographyNDC(n,t,{reprojectionError:Ei,numberOfHypotheses:100}).then(([o,r])=>{let a=wt,A=oe.bestFitAspectRatioNDC(this.screenSize,this._referenceImage),c=oe.bestFitScaleNDC(A,a),g=oe.inverseBestFitScaleNDC(A,a).times(o).times(c),f=this._warpHomography,b=f.inverse();return f.times(g).times(b)}).catch(o=>{throw new gt("Can't find a perspective motion",o)})}_findMatchingPairs(t,n){let o=[];for(let r=0;r<n.length;r++){let a=n[r];if(a.matches[0].index>=0&&a.matches[1].index>=0){let A=a.matches[0].distance,c=a.matches[1].distance;if(A<=ss*c){let u=t[a.matches[0].index];o.push([u,a])}}}return o}_createPipeline(){let t=he.default.Pipeline(),n=he.default.Image.Source("source"),o=he.default.Transform.Resize("screen"),r=he.default.Filter.Greyscale(),a=he.default.Transform.PerspectiveWarp("imageRectifier"),A=he.default.Filter.Nightvision(),c=he.default.Image.Multiplexer(),u=he.default.Filter.GaussianBlur(),g=he.default.Keypoint.Detector.Harris(),f=he.default.Keypoint.Descriptor.ORB(),b=he.default.Keypoint.Matcher.BFKNN(),d=he.default.Keypoint.SubpixelRefiner(),y=he.default.Filter.GaussianBlur(),I=he.default.Keypoint.BorderClipper("borderClipper"),x=he.default.Keypoint.Clipper(),S=he.default.Keypoint.Transformer("keypointScaler"),M=he.default.Keypoint.Portal.Source("keypointPortalSource"),N=he.default.Keypoint.SinkOfMatchedKeypoints("keypoints");return n.media=null,o.size=he.default.Size(0,0),a.transform=he.default.Matrix.Eye(3),A.gain=Ct,A.offset=Pt,A.decay=vt,A.quality=lt,c.port=En?1:0,u.kernelSize=he.default.Size(Ze,Ze),u.sigma=he.default.Vector2($e,$e),y.kernelSize=he.default.Size(At,At),y.sigma=he.default.Vector2(dt,dt),g.quality=Sn,g.capacity=yn,d.method=bt,x.size=_n,I.imageSize=o.size,I.borderSize=he.default.Vector2(0,0),S.transform=he.default.Matrix.Eye(3),b.k=2,M.source=null,N.turbo=aa,n.output().connectTo(o.input()),o.output().connectTo(r.input()),r.output().connectTo(a.input()),a.output().connectTo(c.input("in0")),a.output().connectTo(A.input()),A.output().connectTo(c.input("in1")),c.output().connectTo(g.input()),g.output().connectTo(I.input()),I.output().connectTo(x.input()),a.output().connectTo(y.input()),y.output().connectTo(d.input("image")),x.output().connectTo(d.input("keypoints")),a.output().connectTo(u.input()),u.output().connectTo(f.input("image")),d.output().connectTo(f.input("keypoints")),M.output().connectTo(b.input("database")),f.output().connectTo(b.input("keypoints")),f.output().connectTo(S.input()),S.output().connectTo(N.input()),b.output().connectTo(N.input("matches")),t.init(n,o,r,a,A,c,u,g,d,I,x,y,f,b,M,S,N),t}}});var er,Dd,tr,la=le(()=>{"use strict";er=Ne(be(),1);Ke();ys();Es();Os();Fs();Us();Gs();ca();Fe();Kn();Dd={resolution:"sm"},tr=class extends jt{constructor(t){super(),this._state={initial:new Mi(this),training:new Li(this),scanning:new Oi(this),"pre-tracking-a":new zi(this),"pre-tracking-b":new Fi(this),tracking:new $i(this)},this._session=null,this._source=null,this._activeStateName="initial",this._lastOutput={},this._database=new wi,t=Object.assign({},Dd,t),this._resolution=t.resolution}get type(){return"image-tracker"}get state(){return this._activeStateName}get database(){return this._database}get resolution(){return this._resolution}set resolution(t){}get screenSize(){return this._state[this._activeStateName].screenSize}get _output(){return this._lastOutput}get _stats(){let t=this.screenSize;return`${t.width}x${t.height} ${this.state}`}_init(t){this._session=t;for(let n of t.sources)if(n._type=="video"){this._source=n;break}else n._type=="canvas"&&(this._source=n);if(this._source===null)throw new Pe("The image tracker requires a suitable source of data");for(let n of Object.values(this._state))n.init();return er.default.Promise.resolve()}_release(){for(let t of Object.values(this._state))t.release();return this._session=null,er.default.Promise.resolve()}_update(){if(this._session==null)return er.default.Promise.reject(new Pe("Uninitialized tracker"));let t=this._source._internalMedia,n=this._computeScreenSize(),o=this._state[this._activeStateName];return o.update(t,n).then(({trackerOutput:r,nextState:a,nextStateSettings:A})=>{this._lastOutput=r,this._activeStateName!=a&&(o.onLeaveState(),this._activeStateName=a,this._state[a].onEnterState(A||{}))})}_referenceImageOfKeypoint(t){return this._state.training.referenceImageOfKeypoint(t)}_referenceImageIndexOfKeypoint(t){return this._state.training.referenceImageIndexOfKeypoint(t)}_referenceKeypoint(t){return this._state.training.referenceKeypoint(t)}_computeScreenSize(){let t=this._source._internalMedia,n=t.width/t.height;return X.resolution(this._resolution,n)}}});var Nd,Aa,nt,nr=le(()=>{"use strict";Nd=1e-6,Aa=null,nt=class _{constructor(t=0,n=0){this._x=+t,this._y=+n}static Zero(){return new _(0,0)}static get ZERO(){return Aa||(Aa=Object.freeze(_.Zero()))}get x(){return this._x}get y(){return this._y}length(){let t=this._x,n=this._y;return Math.sqrt(t*t+n*n)}dot(t){return this._x*t._x+this._y*t._y}distanceTo(t){let n=this._x-t._x,o=this._y-t._y;return Math.sqrt(n*n+o*o)}directionTo(t){return t._clone()._subtract(this)._normalize()}normalized(){return this._clone()._normalize()}plus(t){return this._clone()._add(t)}minus(t){return this._clone()._subtract(t)}times(t){return this._clone()._scale(t)}equals(t){return this._x===t._x&&this._y===t._y}toString(){let t=this._x.toFixed(5),n=this._y.toFixed(5);return`Vector2(${t},${n})`}_set(t,n){return this._x=+t,this._y=+n,this}_copyFrom(t){return this._x=t._x,this._y=t._y,this}_normalize(){let t=this.length();return t<Nd?this:(this._x/=t,this._y/=t,this)}_add(t){return this._x+=t._x,this._y+=t._y,this}_subtract(t){return this._x-=t._x,this._y-=t._y,this}_scale(t){return this._x*=t,this._y*=t,this}_clone(){return new _(this._x,this._y)}}});var hn,da,Rd,ir,pa=le(()=>{"use strict";hn=Ne(be(),1);nr();Fe();Ke();da={pointerdown:"began",pointerup:"ended",pointermove:"moved",pointercancel:"canceled",pointerleave:"ended",pointerenter:"began"},Rd={space:"normalized"},ir=class{constructor(t){let n=this._buildSettings(t);this._source=null,this._viewport=null,this._space=n.space,this._activePointers=new Map,this._newPointers=new Map,this._idMap=new Map,this._nextId=1,this._previousOutput=this._generateOutput(),this._previousUpdateTime=Number.POSITIVE_INFINITY,this._wantToReset=!1,this._resetInTheNextUpdate=this._resetInTheNextUpdate.bind(this)}_buildSettings(t){let n=Object.assign({},Rd,t);if(n.space!="normalized"&&n.space!="adjusted")throw new Z(`Invalid pointer space: "${n.space}"`);return n}get type(){return"pointer-tracker"}_init(t){X.log("Initializing PointerTracker..."),this._viewport=t.viewport;for(let n of t.sources)if(n._type=="pointer-source"){this._source=n;break}return this._source===null?hn.default.Promise.reject(new Pe("A PointerTracker expects a PointerSource")):(this._source._setViewport(this._viewport),document.addEventListener("visibilitychange",this._resetInTheNextUpdate),hn.default.Promise.resolve())}_release(){return this._source=null,this._viewport=null,this._activePointers.clear(),this._newPointers.clear(),this._idMap.clear(),document.removeEventListener("visibilitychange",this._resetInTheNextUpdate),hn.default.Promise.resolve()}_update(){let t=this._viewport.canvas,n=t.getBoundingClientRect(),o=this._updateTime(),r=o>1e-5?1/o:60,a=this._findInactiveTrackables();for(let c=a.length-1;c>=0;c--)this._activePointers.delete(a[c].id);this._updateAllTrackables({phase:"stationary",velocity:nt.ZERO,deltaPosition:nt.ZERO}),this._wantToReset&&(this._reset(),this._wantToReset=!1);let A;for(;(A=this._source._consume())!==null;){if(A.target!==t)return hn.default.Promise.reject(new Pe("Invalid PointerEvent target "+A.target));if(!da.hasOwnProperty(A.type))return hn.default.Promise.reject(new Pe("Invalid PointerEvent type "+A.type));let c=this._normalizeId(A.pointerId,A.pointerType),u=this._activePointers.get(c),g=this._newPointers.get(c),f=da[A.type];if(A.type=="pointerdown"||A.type=="pointerenter"&&A.buttons>0){if(u)continue;if(A.button!=0&&A.pointerType=="mouse")continue}else if(!u&&!g)continue;if(u){if(f=="began"&&g&&(g.phase=="ended"||g.phase=="canceled")){this._newPointers.delete(c);continue}}else if(f=="ended"||f=="canceled"){this._newPointers.delete(c);continue}if(u?.phase=="canceled")continue;switch(A.type){case"pointermove":if(A.buttons==0||g?.phase=="began")continue;break;case"pointerenter":if(A.buttons==0||u?.phase=="began"||g?.phase=="began")continue;break;case"pointercancel":this._reset(),this._newPointers.clear();continue}let b=A.pageX-(n.left+window.scrollX),d=A.pageY-(n.top+window.scrollY),y=2*b/n.width-1,I=-(2*d/n.height-1),x=new nt(y,I);if(this._space=="adjusted"){let F=this._viewport.aspectRatio;F>=1?x._set(y,I/F):x._set(y*F,I)}let S=u?x._clone()._subtract(u.position):nt.ZERO,M=u?u.initialPosition:Object.freeze(x._clone()),N=S._clone()._scale(r),E=u?u.duration+o:0,R=u?u.movementLength+S.length():0,B=u?u.movementDuration+(R>u.movementLength?o:0):0,Q=A.isPrimary,U=A.pointerType;this._newPointers.set(c,{id:c,phase:f,position:x,deltaPosition:S,initialPosition:M,velocity:N,duration:E,movementDuration:B,movementLength:R,isPrimary:Q,kind:U,tracker:this})}return this._newPointers.forEach((c,u)=>this._activePointers.set(u,c)),this._newPointers.clear(),this._advanceAllStationaryTrackables(o),this._activePointers.size==0&&this._idMap.size>0&&this._idMap.clear(),this._previousOutput=this._generateOutput(),hn.default.Promise.resolve()}get _output(){return this._previousOutput}get _stats(){let t=this._activePointers.size,n=t!=1?"s":"";return t+" pointer"+n}get space(){return this._space}_generateOutput(){let t=[];return this._activePointers.forEach(n=>t.push(n)),{exports:{tracker:this,trackables:this._sortTrackables(t)}}}_updateAllTrackables(t){this._activePointers.forEach((n,o)=>{this._activePointers.set(o,Object.assign({},n,t))})}_advanceAllStationaryTrackables(t){this._activePointers.forEach((n,o)=>{n.phase=="stationary"&&(n.duration+=t)})}_normalizeId(t,n){return n=="mouse"?0:(this._idMap.has(t)||this._idMap.set(t,this._nextId++),this._idMap.get(t))}_reset(){for(this._updateAllTrackables({phase:"canceled",velocity:nt.ZERO,deltaPosition:nt.ZERO});this._source._consume()!==null;);}_resetInTheNextUpdate(){this._wantToReset=!0}_sortTrackables(t){if(t.length<=1||t[0].isPrimary)return t;for(let n=1;n<t.length;n++)if(t[n].isPrimary){let o=t[n];t[n]=t[0],t[0]=o;break}return t}_findInactiveTrackables(){let t=[];return this._activePointers.forEach(n=>{(n.phase=="ended"||n.phase=="canceled")&&t.push(n)}),t}_updateTime(){let t=performance.now()*.001;this._previousUpdateTime>t&&(this._previousUpdateTime=t);let n=this._previousUpdateTime;return this._previousUpdateTime=t,t-n}}});var rr,ua=le(()=>{"use strict";la();pa();rr=class{static Image(t={}){return new tr(t)}static ImageTracker(){return this.Image()}static Pointer(t={}){return new ir(t)}}});var gn,kd,ha,wn,io=le(()=>{"use strict";gn=Ne(be(),1);Fe();Ke();kd="Tap on the screen to start",ha=!1,wn=class{constructor(t){X.assert(t instanceof HTMLVideoElement,"Expected a video element"),this._video=t,this._media=null}get video(){return this._video}get _type(){return"video"}get _internalMedia(){if(this._media==null)throw new Pe("The media of the source of data isn't loaded");return this._media}get _stats(){let t=this._media;return t!=null?`${t.width}x${t.height} video`:"uninitialized video"}_init(){return X.log(`Initializing ${this._type} source...`),this._prepareVideo(this._video).then(t=>(X.log("The video is prepared"),gn.default.load(t).then(n=>{X.log(`Source of data is a ${n.width}x${n.height} ${this._type}`),this._media=n})))}_release(){return this._media&&this._media.release(),this._media=null,gn.default.Promise.resolve()}_prepareVideo(t){return t.setAttribute("playsinline",""),this._handleAutoPlay(t).finally(()=>(X.isWebKit()&&t.hidden&&(t.hidden=!1,t.style.setProperty("opacity","0"),t.style.setProperty("position","fixed"),t.style.setProperty("left","0"),t.style.setProperty("top","0")),t))}_handleAutoPlay(t){return t.autoplay?(t.muted||(X.warning("Videos marked with autoplay should be muted",t),t.muted=!0),this._waitUntilPlayable(t).then(n=>{let o=n.play();return o===void 0?n:new gn.default.Promise((r,a)=>{o.then(()=>r(n),A=>{if(X.error("Can't autoplay video!",A,n),A.name=="NotAllowedError")X.warning("Tip: allow manual playback"),X.isIOS()&&X.warning("Is low power mode on?"),(n.hidden||!n.controls||n.parentNode===null)&&(document.body.addEventListener("pointerdown",()=>n.play()),ha||(alert(kd),ha=!0));else if(A.name=="NotSupportedError"){a(new ht("Unsupported video format",A));return}r(n)})})})):gn.default.Promise.resolve(t)}_waitUntilPlayable(t){return t.readyState>=3?gn.default.Promise.resolve(t):new gn.default.Promise((r,a)=>{let A=0,c=setInterval(()=>{t.readyState>=3?(clearInterval(c),r(t)):(A+=500)>=15e3&&(clearInterval(c),a(new mi("The video took too long to load")))},500)})}}});var ro,or,ga=le(()=>{"use strict";ro=Ne(be(),1);Fe();Ke();or=class{constructor(t){X.assert(t instanceof HTMLCanvasElement,"Expected a canvas element"),this._canvas=t,this._media=null}get _type(){return"canvas"}get _internalMedia(){if(this._media==null)throw new Pe("The media of the source of data isn't loaded");return this._media}get _stats(){let t=this._media;return t!=null?`${t.width}x${t.height} canvas`:"uninitialized canvas"}_init(){return ro.default.load(this._canvas).then(t=>{X.log(`Source of data is a ${t.width}x${t.height} ${this._type}`),this._media=t})}_release(){return this._media&&this._media.release(),this._media=null,ro.default.Promise.resolve()}}});var fa,Qd,sr,ma=le(()=>{"use strict";fa=Ne(be(),1);Fe();Ke();io();Qd={resolution:"md",aspectRatio:16/9,constraints:{facingMode:"environment"}},sr=class extends wn{constructor(t){let n=document.createElement("video");super(n),this._options=Object.assign({},Qd,t)}get resolution(){return this._options.resolution}_init(){if(X.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new ht("Unsupported browser: no navigator.mediaDevices.getUserMedia()");let t=this._options,n=X.resolution(t.resolution,t.aspectRatio),o={audio:!1,video:{width:n.width,height:n.height,aspectRatio:t.aspectRatio,...t.constraints}};return new fa.default.Promise((r,a)=>{navigator.mediaDevices.getUserMedia(o).then(A=>{let c=this.video;c.onloadedmetadata=()=>{let u=c.play(),g="Access to the webcam has been granted.";if(u===void 0){X.log(g),r(c);return}u.then(()=>{X.log(g),r(c)}).catch(f=>{a(new Pe("Webcam error!",f))})},c.setAttribute("muted",""),c.muted=!0,c.setAttribute("playsinline",""),c.playsInline=!0,c.setAttribute("autoplay",""),c.autoplay=!0,c.srcObject=A}).catch(A=>{a(new Ot("Please give access to the webcam and reload the page.",A))})}).then(r=>super._init())}_release(){let t=this.video;return t.srcObject.getTracks().forEach(r=>r.stop()),t.onloadedmetadata=null,t.srcObject=null,super._release()}}});var oo,ar,Ia=le(()=>{"use strict";oo=Ne(be(),1);Fe();ar=class{constructor(){this._queue=[],this._viewport=null,this._onPointerEvent=this._onPointerEvent.bind(this),this._cancelEvent=this._cancelEvent.bind(this)}get _type(){return"pointer-source"}_consume(){return this._queue.shift()||null}get _stats(){return"pointer input"}_init(){return X.log("Initializing PointerSource..."),oo.default.Promise.resolve()}_release(){return this._setViewport(null),oo.default.Promise.resolve()}_setViewport(t){if(this._viewport!==null&&(this._viewport.hud.container.style.removeProperty("pointer-events"),this._viewport._subContainer.style.removeProperty("pointer-events"),this._viewport.container.style.removeProperty("pointer-events"),this._viewport.canvas.style.removeProperty("pointer-events"),this._removeEventListeners(this._viewport.canvas)),(this._viewport=t)!==null){this._addEventListeners(this._viewport.canvas),this._viewport.canvas.style.pointerEvents="auto",this._viewport.container.style.pointerEvents="none",this._viewport._subContainer.style.pointerEvents="none",this._viewport.hud.container.style.pointerEvents="none";for(let n of this._viewport.hud.container.children)n.style.getPropertyValue("pointer-events")==""&&(n.style.pointerEvents="auto")}}_onPointerEvent(t){this._queue.push(t),t.preventDefault()}_cancelEvent(t){t.cancelable&&t.preventDefault()}_addEventListeners(t){t.addEventListener("pointerdown",this._onPointerEvent),t.addEventListener("pointerup",this._onPointerEvent),t.addEventListener("pointermove",this._onPointerEvent),t.addEventListener("pointercancel",this._onPointerEvent),t.addEventListener("pointerleave",this._onPointerEvent),t.addEventListener("pointerenter",this._onPointerEvent),t.addEventListener("touchstart",this._cancelEvent,{passive:!1})}_removeEventListeners(t){t.removeEventListener("touchstart",this._cancelEvent),t.removeEventListener("pointerenter",this._onPointerEvent),t.removeEventListener("pointerleave",this._onPointerEvent),t.removeEventListener("pointercancel",this._onPointerEvent),t.removeEventListener("pointermove",this._onPointerEvent),t.removeEventListener("pointerup",this._onPointerEvent),t.removeEventListener("pointerdown",this._onPointerEvent)}}});var cr,_a=le(()=>{"use strict";io();ga();ma();Ia();cr=class{static Video(t){return new wn(t)}static Canvas(t){return new or(t)}static Camera(t={}){return new sr(t)}static Pointer(){return new ar}}});var Kd,Ld,Od,lr,ya=le(()=>{"use strict";Cn();On();Kd=500,Ld=Object.freeze({default:"","low-power":"&#x1F50B","high-performance":"&#x26A1"}),Od="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAVUlEQVRIS2NkGGDAOMD2M4w6YDQE8IbAfyBgBAJSEipIDy712MzCaTiyQdRwBC4zsDoAmy8ocQQ+vRgOIDUI8UUPMVFIUvySkhaIVTvqgNEQGPAQAABSNiARgz5LggAAAABJRU5ErkJggg==",lr=class{constructor(){this._container=this._createContainer(),this._lastUpdate=0}init(t,n){t.appendChild(this._container),this._container.hidden=!n}release(){this._container.remove()}update(t,n,o,r,a,A){t>=this._lastUpdate+Kd&&(this._lastUpdate=t,this._update(n,o,r,A,a))}_update(t,n,o,r,a){let A=this._label("_ar_fps");A!==null&&(A.style.color=this._color(r),A.innerText=String(r));let c=this._label("_ar_gpu");c!==null&&(c.style.color=this._color(a),c.innerText=String(a));let u=this._label("_ar_power");u!==null&&(u.innerHTML=Ld[We.powerPreference]);let g=this._label("_ar_in");if(g!==null){let d=t.map(y=>y._stats).join(", ");g.innerText=d}let f=this._label("_ar_out");if(f!==null){let d=n.map(y=>y._stats).join(", ");f.innerText=d}let b=this._label("_ar_view");if(b!==null){let d=o.virtualSize;b.innerText=`${d.width}x${d.height} rendering`}}_label(t){return this._container.getElementsByClassName(t).item(0)}_color(t){let n="#0f0",o="#ff0",r="#f33",a=t>=50?n:t>=30?o:r,A=t>=30?n:r;return We.powerPreference!="low-power"?a:A}_createContainer(){let t=document.createElement("div");return t.style.position="absolute",t.style.left=t.style.top="0px",t.style.padding="0px",t.appendChild(this._createTitle()),t.appendChild(this._createContent()),t}_createTitle(){let t=document.createElement("div"),n=document.createElement("button");return t.style.display="flex",t.style.backgroundColor="#7e56c2",t.style.color="white",t.style.fontFamily="monospace",t.style.fontSize="14px",t.style.fontWeight="bold",t.style.paddingRight="4px",t.innerText="encantar.js "+pt.version,n.style.width="18px",n.style.height="18px",n.style.marginRight="4px",n.style.backgroundColor="#7e56c2",n.style.backgroundImage="url("+Od+")",n.style.backgroundRepeat="no-repeat",n.style.backgroundPosition="0 0",n.style.borderWidth="2px",n.style.borderColor="#b588fb #46346a #46346a #b588fb",t.insertBefore(n,t.firstChild),n.addEventListener("click",()=>{let o=t.parentNode,r=o&&o.querySelector("._ar_details");r&&(r.hidden=!r.hidden,n.style.backgroundPosition=r.hidden?"0 0 ":"-16px 0")}),t}_createContent(){let t=document.createElement("div"),n=document.createElement("div");t.style.backgroundColor="rgba(0,0,0,0.5)",t.style.color="white",t.style.fontFamily="monospace",t.style.fontSize="14px",t.style.padding="2px",t.style.whiteSpace="pre-line",n.classList.add("_ar_details"),n.hidden=!0;let o=(r,a)=>r.insertAdjacentHTML("beforeend",a);return o(t,'FPS: <span class="_ar_fps"></span> | '),o(t,'GPU: <span class="_ar_gpu"></span> '),o(t,'<span class="_ar_power"></span>'),o(n,'IN: <span class="_ar_in"></span><br>'),o(n,'OUT: <span class="_ar_out"></span><br>'),o(n,'VIEW: <span class="_ar_view"></span>'),t.appendChild(n),t}}});var Sa,zd,Ea,xa,Ar,Ca=le(()=>{"use strict";Sa="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAbUlEQVRYR+2WOQ4AIAgE5f+PVhobDZANBZAsraAwXMoqFil+f9GBj8BW8dIiKt45at/XgShStHgvmfdekwAdIIEyAmh1Z/U5ikmABPoRsLZWtt+5DUlgHgGr6qM1Pf9XnO131L7fJEQjyOqXEzjP1YAhNmUTrgAAAABJRU5ErkJggg==",zd="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAZElEQVRYR+2WwRIAEAhE9f8fTQ5OhtkLxbzOyc5rJSvBYcH3FwTIBKpHb5d57Nqm5o0aCIBAPgLDxSunq69APT8RCBdwezTLHjglDAEQgEC+QZR2EqqbjprHRgSB9wjwHX9LoAHP1YAhXF4Z/QAAAABJRU5ErkJggg==",Ea=64,xa=24,Ar=class{constructor(t){this._viewport=t,this._button=this._createButton(),this._boundEventHandler=this._handleFullscreenEvent.bind(this)}init(t,n){t.appendChild(this._button),this._button.hidden=!n,this._viewport.addEventListener("fullscreenchange",this._boundEventHandler)}release(){this._viewport.removeEventListener("fullscreenchange",this._boundEventHandler),this._button.remove()}_createButton(){let t=document.createElement("button");t.style.position="absolute",t.style.bottom=xa+"px",t.style.right=xa+"px",t.style.width=Ea+"px",t.style.height=Ea+"px",t.style.opacity="0.5",t.style.cursor="pointer",t.style.outline="none",t.style["-webkit-tap-highlight-color"]="transparent",t.draggable=!1,t.style.backgroundColor="transparent",t.style.backgroundImage="url("+Sa+")",t.style.backgroundSize="cover",t.style.imageRendering="pixelated",t.style.borderColor="white",t.style.borderStyle="solid",t.style.borderWidth="2px",t.style.borderRadius="8px";let n=()=>{t.style.backgroundColor="#ffd500",t.style.borderColor="#ffd500",t.style.opacity="1.0"},o=()=>{t.style.backgroundColor="transparent",t.style.borderColor="white",t.style.opacity="0.5"};return t.addEventListener("pointerdown",n),t.addEventListener("pointerup",o),t.addEventListener("pointerleave",o),t.addEventListener("click",()=>{this._viewport.fullscreen?this._viewport.exitFullscreen():this._viewport.requestFullscreen().catch(r=>{alert("Can't enable the fullscreen mode. "+r.toString())})}),t}_handleFullscreenEvent(t){let n=this._viewport.fullscreen?zd:Sa;this._button.style.backgroundImage="url("+n+")"}}});var Fd,Ud,dr,Pa=le(()=>{"use strict";Fd="https://encantar.dev/supporter",Ud="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22298.803%22%20height%3D%2266.241%22%20viewBox%3D%220%200%2079.057%2017.526%22%3E%3Cg%20aria-label%3D%22encantar.js%22%20style%3D%22font-weight%3A400%3Bfont-size%3A10.58333302px%3Bline-height%3A1.25%3Bfont-family%3Asans-serif%3Bletter-spacing%3A0%3Bword-spacing%3A0%3Bstroke%3A%23000%3Bstroke-width%3A.39686999%3Bstroke-linecap%3Abutt%3Bstroke-linejoin%3Around%3Bstroke-miterlimit%3A4%3Bstroke-dasharray%3Anone%3Bstroke-dashoffset%3A0%3Bstroke-opacity%3A.50196078%22%20stroke%3D%22none%22%3E%3Cpath%20d%3D%22M8.488%208.848q0%20.952-.19%201.312H3.872q-.063.995-.063%201.355%200%203.323%201.503%203.323%201.143%200%202.01-1.905h.784q-.635%202.942-3.154%202.942-3.366%200-3.366-5.82%200-1.885.847-3.197Q3.45%205.355%205.25%205.355q1.545%200%202.392.974.847.952.847%202.519zm-1.905-.424q0-2.265-1.27-2.265-.55%200-.995.868-.381.741-.381%201.355v.53h2.625q.02-.255.02-.488zm11.98%205.567q0%20.72-.508%201.207-.508.465-1.228.465-2.053%200-2.053-1.905V9.715q0-.952-.36-1.82-.465-1.1-1.27-1.1-.296%200-.55.275-.254.254-.254.571-.127%205.398-.127%205.525%200%201.63%201.334%201.481v.995H8.678v-1.08q.148-.084.53-.084.402-.021.55-.17.254-.19.254-.804%200-.275-.064-.804-.042-.55-.042-.826%200-.973.17-2.73l.126-1.334q0-.508-.36-.783t-.867-.254l.02-.106q0-.423-.126-.677%201.206-.317%203.662-.931-.064.72-.064.825%200%20.233.042.402.741-.93%201.503-.93.91%200%201.948%201.311.973%201.25.973%202.202v4.318q0%201.037.36%201.354.402-.232.402-.677%200-.085-.02-.275-.022-.19-.022-.296v-.17h.91zm7.218-6.286q0%20.613-.381%201.08-.36.444-.953.444-.508%200-.867-.381-.36-.381-.36-.89%200-.38.317-.677.318-.296.699-.296.127%200%20.254.106.127.084.233.084v-.042q.02-.868-1.46-.868-1.313%200-1.8%201.355-.296.825-.296%202.455%200%202.011.148%202.942.338%202.032%201.397%202.032.656%200%201.206-.508.085-.084.868-1.016.445.212.783.55-.91%201.08-1.206%201.334-.762.656-1.609.656-2.074%200-3.027-2.095-.698-1.545-.698-3.916%200-1.672.868-3.111%201.016-1.694%202.56-1.694%201.25%200%202.202.593%201.122.698%201.122%201.863zm8.191%207.62q0%20.317-.063.529-.127%200-.402.063-.254.064-.402.064-.53%200-1.016-.36-.487-.36-.678-.868-1.08%201.122-2.497%201.122-1.292%200-2.075-.72t-.783-1.99q0-1.587.974-2.54.995-.952%202.624-.952.36%200%20.762.042.085-.444.085-.952%200-2.582-1.778-2.582-.74%200-1.122.846.381-.148.678-.148.846%200%20.846%201.334%200%20.38-.487.762-.465.36-.846.36-1.313%200-1.313-1.779%200-1.29%201.292-1.862.952-.445%202.434-.445%201.587%200%202.138%201.757.317%201.016.317%203.09%200%20.424-.021%201.292-.021.867-.021%201.312%200%202.244.72%202.244.232%200%20.55-.19.084.274.084.57zm-3.513-1.842q-.064-1.122-.064-.952%200-.635.043-1.651-.36-.106-.847-.106-.699%200-1.08.656-.338.53-.338%201.291%200%20.826.402%201.44.466.677%201.27.677.444%200%20.487-.508.084-.783.127-.847z%22%20style%3D%22font-style%3Anormal%3Bfont-variant%3Anormal%3Bfont-weight%3A400%3Bfont-stretch%3Anormal%3Bfont-size%3A21.16666603px%3Bfont-family%3ADuality%3B-inkscape-font-specification%3ADuality%3Bfill%3A%23ff95ff%3Bfill-opacity%3A1%3Bstroke%3A%23ffffea%3Bstroke-width%3A0%3Bstroke-linecap%3Abutt%3Bstroke-linejoin%3Around%3Bstroke-miterlimit%3A4%3Bstroke-dasharray%3Anone%3Bstroke-dashoffset%3A0%3Bstroke-opacity%3A.9754902%3Bpaint-order%3Astroke%20fill%20markers%22%20transform%3D%22translate(-1.587%20-1.587)%22%2F%3E%3Cpath%20d%3D%22M43.794%2013.991q0%20.72-.508%201.207-.508.465-1.228.465-2.053%200-2.053-1.905V9.715q0-.952-.36-1.82-.466-1.1-1.27-1.1-.296%200-.55.275-.254.254-.254.571-.127%205.398-.127%205.525%200%201.63%201.333%201.481v.995H33.91v-1.08q.148-.084.53-.084.401-.021.55-.17.253-.19.253-.804%200-.275-.063-.804-.042-.55-.042-.826%200-.973.169-2.73l.127-1.334q0-.508-.36-.783t-.868-.254l.021-.106q0-.423-.127-.677%201.207-.317%203.662-.931-.063.72-.063.825%200%20.233.042.402.741-.93%201.503-.93.91%200%201.947%201.311.974%201.25.974%202.202v4.318q0%201.037.36%201.354.402-.232.402-.677%200-.085-.021-.275t-.021-.296v-.17h.91zm5.101.402q0%20.53-.508.953t-1.058.423q-1.63%200-2.011-1.1-.17-.466-.17-2.456%200-1.376-.063-3.535l-.042-1.714q-.297-.17-.678-.17-.084%200-.275.043-.17.021-.275.021.106-.423.106-.974%201.418.021%202.201-1.058.699-.953.656-2.413h.72v3.175q.402.042%201.206.19V6.88h-1.439v7.112q0%20.106.296.36h.445v-1.228h.889z%22%20style%3D%22font-style%3Anormal%3Bfont-variant%3Anormal%3Bfont-weight%3A400%3Bfont-stretch%3Anormal%3Bfont-size%3A21.16666603px%3Bfont-family%3ADuality%3B-inkscape-font-specification%3ADuality%3Bfill%3A%23ff95ff%3Bfill-opacity%3A1%3Bstroke%3A%23ffffea%3Bstroke-width%3A0%3Bstroke-linecap%3Abutt%3Bstroke-linejoin%3Around%3Bstroke-miterlimit%3A4%3Bstroke-dasharray%3Anone%3Bstroke-dashoffset%3A0%3Bstroke-opacity%3A.9754902%3Bpaint-order%3Astroke%20fill%20markers%22%20transform%3D%22translate(-1.587%20-1.587)%22%2F%3E%3Cpath%20d%3D%22M56.917%2015.325q0%20.317-.063.529-.127%200-.403.063-.254.064-.402.064-.529%200-1.016-.36t-.677-.868q-1.08%201.122-2.498%201.122-1.29%200-2.074-.72T49%2013.165q0-1.587.973-2.54.995-.952%202.625-.952.36%200%20.762.042.085-.444.085-.952%200-2.582-1.778-2.582-.741%200-1.122.846.38-.148.677-.148.847%200%20.847%201.334%200%20.38-.487.762-.466.36-.847.36-1.312%200-1.312-1.779%200-1.29%201.291-1.862.953-.445%202.434-.445%201.588%200%202.138%201.757.318%201.016.318%203.09%200%20.424-.021%201.292-.022.867-.022%201.312%200%202.244.72%202.244.233%200%20.55-.19.085.274.085.57zm-3.514-1.842q-.063-1.122-.063-.952%200-.635.042-1.651-.36-.106-.846-.106-.699%200-1.08.656-.339.53-.339%201.291%200%20.826.403%201.44.465.677%201.27.677.444%200%20.486-.508.085-.783.127-.847z%22%20style%3D%22fill%3A%23ffea2a%3Bfill-opacity%3A1%3Bstroke%3A%23ffffea%3Bstroke-width%3A0%3Bstroke-linecap%3Abutt%3Bstroke-linejoin%3Around%3Bstroke-miterlimit%3A4%3Bstroke-dasharray%3Anone%3Bstroke-dashoffset%3A0%3Bstroke-opacity%3A.9754902%3Bpaint-order%3Astroke%20fill%20markers%22%20transform%3D%22translate(-1.587%20-1.587)%22%2F%3E%3Cpath%20d%3D%22M64.347%207.493q0%20.571-.36%201.206-.424.741-.932.741-.677%200-1.206-.465-.53-.466-.53-1.143%200-.953%201.08-.953.106%200%20.254.064.148.063.212.063v-.042q.021-.593-.72-.593-1.757%200-1.757%203.98%200%20.36.043%201.058t.042%201.037v.36q-.021.254-.021.36%200%201.63%201.333%201.481v.995h-4.868v-1.08l.699-.148q.402-.063.592-.36.127-.211.127-.38l.106-5.864q0-.486-.36-.762-.36-.296-.868-.275l.022-.106q0-.423-.127-.677%201.121-.317%203.344-.931%200%20.021-.064.846-.042.572-.042%201.186l.572-.826q.402-.55.592-.72.36-.296.826-.296.973%200%201.481.635.53.635.53%201.609z%22%20style%3D%22fill%3A%23ffea2a%3Bfill-opacity%3A1%3Bstroke%3A%23ffffea%3Bstroke-width%3A0%3Bstroke-linecap%3Abutt%3Bstroke-linejoin%3Around%3Bstroke-miterlimit%3A4%3Bstroke-dasharray%3Anone%3Bstroke-dashoffset%3A0%3Bstroke-opacity%3A.9754902%3Bpaint-order%3Astroke%20fill%20markers%22%20transform%3D%22translate(-1.587%20-1.587)%22%2F%3E%3Cpath%20d%3D%22M67.564%2015.113q0%20.593-.487%201.058t-1.1.466-1.059-.55q-.423-.53-.423-1.186%200-.55.508-.952.444-.36%201.037-.36.656%200%201.08.444.444.424.444%201.08z%22%20style%3D%22font-style%3Anormal%3Bfont-variant%3Anormal%3Bfont-weight%3A400%3Bfont-stretch%3Anormal%3Bfont-size%3A21.16666603px%3Bfont-family%3ADuality%3B-inkscape-font-specification%3ADuality%3Bfill%3A%23ff95ff%3Bfill-opacity%3A1%3Bstroke%3A%23ffffea%3Bstroke-width%3A0%3Bstroke-linecap%3Abutt%3Bstroke-linejoin%3Around%3Bstroke-miterlimit%3A4%3Bstroke-dasharray%3Anone%3Bstroke-dashoffset%3A0%3Bstroke-opacity%3A.9754902%3Bpaint-order%3Astroke%20fill%20markers%22%20transform%3D%22translate(-1.587%20-1.587)%22%2F%3E%3Cpath%20d%3D%22M73.088%203.111q0%20.593-.486%201.059-.487.465-1.08.465-.635%200-1.08-.571-.402-.508-.402-1.164%200-.572.466-.932.487-.38%201.058-.38.657%200%201.08.444.444.423.444%201.08zm-.105%2013.103q0%201.08-1.016%201.99-.995.91-2.075.91-1.058%200-1.884-.572-.931-.614-.931-1.63%200-.635.275-1.1.318-.572.91-.572.508%200%20.953.275.529.318.529.783%200%20.847-.423%201.101-.254.17-1.228.254.17.148.53.339.38.211.55.211.635%200%201.079-.762.402-.656.402-1.354V7.345q0-.36-.423-.593-.423-.254-.783-.212v-.105q.02-.424-.106-.657%201.206-.338%203.64-.93zm7.662-3.197q0%20.995-.868%202.054-.847%201.037-1.841%201.037-1.567%200-2.604-.466-1.418-.635-1.418-2.01%200-.636.38-1.101.382-.487.996-.487.529%200%20.889.402.38.381.38.931%200%20.381-.338.699-.317.296-.72.296-.148%200-.275-.085-.106-.084-.148-.105.17.931%201.99.931.656%200%201.206-.423.55-.424.55-1.059%200-.762-1.121-1.524-1.905-1.333-2.053-1.481-1.122-1.038-1.122-2.456%200-.402.233-.973.804-1.99%202.413-1.99%201.27%200%202.222.614%201.143.698%201.143%201.884%200%20.635-.381%201.1t-.995.466q-.529%200-.91-.381-.36-.402-.36-.931%200-.403.318-.699.338-.317.74-.317.149%200%20.276.105.148.085.19.085.021-.085.021-.148%200-.402-.804-.614-.571-.148-1.143-.148-.466%200-.952.402-.487.381-.487.826%200%20.931.72%201.65.465.466%201.63%201.144%201.163.656%201.544%201.016.17.148.424.846.275.678.275.91z%22%20style%3D%22font-style%3Anormal%3Bfont-variant%3Anormal%3Bfont-weight%3A400%3Bfont-stretch%3Anormal%3Bfont-size%3A21.16666603px%3Bfont-family%3ADuality%3B-inkscape-font-specification%3ADuality%3Bfill%3A%23ff95ff%3Bfill-opacity%3A1%3Bstroke%3A%23ffffea%3Bstroke-width%3A0%3Bstroke-linecap%3Abutt%3Bstroke-linejoin%3Around%3Bstroke-miterlimit%3A4%3Bstroke-dasharray%3Anone%3Bstroke-dashoffset%3A0%3Bstroke-opacity%3A.9754902%3Bpaint-order%3Astroke%20fill%20markers%22%20transform%3D%22translate(-1.587%20-1.587)%22%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E",dr=class{constructor(){this._element=this._createElement()}init(t){t.appendChild(this._element)}release(){this._element.remove()}_createElement(){let t=document.createElement("button"),n=document.createElement("img");t.innerText="Support",t.style.font="bold small-caps 20px sans-serif",t.style.color="white",t.style.padding="8px 8px 2px 8px",t.style.maxWidth="40%",t.style.position="absolute",t.style.bottom="0",t.style.right="50%",t.style.transform="translateX(50%)",t.style.cursor="pointer",t.style.outline="none",t.style["-webkit-tap-highlight-color"]="transparent",t.draggable=!1,t.hidden=!1,t.style.backgroundColor="rgba(0,0,0,0.4)",t.style.borderColor="white",t.style.borderStyle="solid",t.style.borderWidth="2px",t.style.borderTopLeftRadius="8px",t.style.borderTopRightRadius="8px",t.style.borderBottomStyle="none",n.style.width="100%",n.style.maxHeight="10vh",n.style.pointerEvents="none",n.src=Ud,t.appendChild(n);let o=()=>{t.style.backgroundColor="#ffd500",t.style.borderColor="#ffd500"},r=()=>{t.style.backgroundColor="rgba(0,0,0,0.25)",t.style.borderColor="white"};return t.addEventListener("pointerdown",o),t.addEventListener("pointerup",r),t.addEventListener("pointerleave",r),t.addEventListener("click",()=>{location.href=Fd}),t}}});var fn,Mn,Tn,pr,va=le(()=>{"use strict";ya();Ca();Pa();Fe();pr=class{constructor(t,n,o=null){hi(this,fn);hi(this,Mn);hi(this,Tn);this._container=o||this._createContainer(n),this._isOwnContainer=o==null,this._container.parentElement!==n&&(this._container.remove(),n.insertAdjacentElement("afterbegin",this._container)),this._container.hidden||(X.warning("The container of the HUD should have the hidden attribute"),this._container.hidden=!0),this._internalContainer=n.attachShadow({mode:"closed"}),this._internalContainer.appendChild(document.createElement("slot")),gi(this,fn,new lr),gi(this,Mn,new Ar(t)),gi(this,Tn,new dr)}get container(){return this._container}get visible(){return this._visible}set visible(t){}get _statsPanel(){return Vt(this,fn)}_init(t,n,o){let r=this._internalContainer;Vt(this,fn).init(r,n),Vt(this,Mn).init(r,o),Vt(this,Tn).init(r);for(let A of r.children)A.style.getPropertyValue("pointer-events")==""&&(A.style.pointerEvents="auto"),A.style.getPropertyValue("z-index")==""&&(A.style.zIndex="1000000");let a=this._container;a.style.position="absolute",a.style.left=a.style.top="0px",a.style.right=a.style.bottom="0px",a.style.padding=a.style.margin="0px",a.style.zIndex=String(t),a.style.userSelect="none",this._visible=!0}_release(){this._visible=!1,Vt(this,Tn).release(),Vt(this,Mn).release(),Vt(this,fn).release(),this._isOwnContainer&&(this._isOwnContainer=!1,this._container.remove())}_createContainer(t){let n=document.createElement("div");return n.hidden=!0,t.insertAdjacentElement("afterbegin",n),n}get _visible(){return!this._container.hidden}set _visible(t){this._container.hidden=!t}};fn=new WeakMap,Mn=new WeakMap,Tn=new WeakMap});var yt,ur,so,Xd,ho,Gd,Hd,qd,ao,co,lo,Ao,hr,gr,fr,po,uo,mr,ba=le(()=>{"use strict";On();yt=Ne(be(),1);va();nr();Fe();Kn();Ke();ur=class extends Jt{},so=class extends jt{},Xd={container:null,hudContainer:null,resolution:"lg",style:"best-fit",canvas:null,fullscreenUI:!0},ho=0,Gd=ho+0,Hd=ho+1,qd=ho+2,ao=class{constructor(t){if(t==null)throw new Z("Unspecified viewport container");if(!(t instanceof HTMLElement))throw new Z("Invalid viewport container");this._container=t,this._subContainer=document.createElement("div"),t.appendChild(this._subContainer)}get container(){return this._container}get subContainer(){return this._subContainer}init(){this._container.style.touchAction="none",this._container.style.backgroundColor="black"}release(){this._container.style.removeProperty("background-color"),this._container.style.removeProperty("touch-action")}},co=class{constructor(t,n,o=null){if(o!==null&&!(o instanceof HTMLCanvasElement))throw new Z("Not a canvas: "+o);this._originalCSSTextOfForegroundCanvas=o?o.style.cssText:"",this._foregroundCanvas=this._styleCanvas(o||this._createCanvas(n),Hd),this._foregroundCanvas.style.background="transparent",this._backgroundCanvas=this._styleCanvas(this._createCanvas(n),Gd),this._backgroundCanvas.hidden=!0,this._foregroundCanvas.hidden=!0;let r="encantar.js "+pt.version;this._backgroundCanvas.dataset.arEngine=r,this._foregroundCanvas.dataset.arEngine=r,t.appendChild(this._backgroundCanvas),t.appendChild(this._foregroundCanvas)}get backgroundCanvas(){return this._backgroundCanvas}get foregroundCanvas(){return this._foregroundCanvas}init(){this._backgroundCanvas.hidden=!1,this._foregroundCanvas.hidden=!1}release(){this._backgroundCanvas.hidden=!0,this._foregroundCanvas.hidden=!0,this._backgroundCanvas.style.cssText="",this._foregroundCanvas.style.cssText=this._originalCSSTextOfForegroundCanvas}_createCanvas(t){let n=document.createElement("canvas");return n.width=t.width,n.height=t.height,n}_styleCanvas(t,n){return t.style.position="absolute",t.style.left="0px",t.style.top="0px",t.style.width="100%",t.style.height="100%",t.style.zIndex=String(n),t}},lo=class{constructor(t){this._viewport=t,this._container=t.container,this._boundEventHandler=this._triggerEvent.bind(this)}init(){this._container.addEventListener("fullscreenchange",this._boundEventHandler)}release(){this._container.removeEventListener("fullscreenchange",this._boundEventHandler)}request(){let t=this._container;return t.requestFullscreen===void 0?t.webkitRequestFullscreen===void 0?yt.default.Promise.reject(new ht):document.webkitFullscreenEnabled?(t.webkitRequestFullscreen(),new yt.default.Promise((n,o)=>{setTimeout(()=>{t===document.webkitFullscreenElement?(X.log("Entering fullscreen mode..."),n()):o(new TypeError)},100)})):yt.default.Promise.reject(new Ot):document.fullscreenEnabled?new yt.default.Promise((n,o)=>{t.requestFullscreen({navigationUI:"hide"}).then(()=>{X.log("Entering fullscreen mode..."),n()},o)}):yt.default.Promise.reject(new Ot)}exit(){if(document.exitFullscreen===void 0){let t=document;return t.webkitExitFullscreen===void 0?yt.default.Promise.reject(new ht):t.webkitFullscreenElement===null?yt.default.Promise.reject(new Pe("Not in fullscreen mode")):(t.webkitExitFullscreen(),new yt.default.Promise((n,o)=>{setTimeout(()=>{t.webkitFullscreenElement===null?(X.log("Exiting fullscreen mode..."),n()):o(new TypeError)},100)}))}return document.fullscreenElement===null?yt.default.Promise.reject(new Pe("Not in fullscreen mode")):new yt.default.Promise((t,n)=>{document.exitFullscreen().then(()=>{X.log("Exiting fullscreen mode..."),t()},n)})}isAvailable(){return document.fullscreenEnabled||!!document.webkitFullscreenEnabled}isActivated(){return document.fullscreenElement!==void 0?document.fullscreenElement===this._container:document.webkitFullscreenElement!==void 0?document.webkitFullscreenElement===this._container:!1}_triggerEvent(){let t=new ur("fullscreenchange");this._viewport.dispatchEvent(t)}},Ao=class{constructor(t){this._viewport=t,this._timeout=null,this._resize=this._onResize.bind(this),this._triggerResize=this.triggerResize.bind(this),this._resizeStrategy=new gr,this._viewport.addEventListener("resize",this._resize),this.triggerResize(0)}init(){window.addEventListener("resize",this._triggerResize),screen.orientation!==void 0?screen.orientation.addEventListener("change",this._triggerResize):window.addEventListener("orientationchange",this._triggerResize),this.triggerResize(0)}release(){screen.orientation!==void 0?screen.orientation.removeEventListener("change",this._triggerResize):window.removeEventListener("orientationchange",this._triggerResize),window.removeEventListener("resize",this._triggerResize),this._viewport.removeEventListener("resize",this._resize),this._resizeStrategy.clear(this._viewport)}triggerResize(t=100){let n=new ur("resize");if(t<=0){this._viewport.dispatchEvent(n);return}this._timeout!==null&&clearTimeout(this._timeout),this._timeout=setTimeout(()=>{this._timeout=null,this._viewport.dispatchEvent(n)},t)}setStrategy(t){this._resizeStrategy.clear(this._viewport),this._resizeStrategy=t,this.triggerResize(0)}setStrategyByName(t){switch(t){case"best-fit":this.setStrategy(new po);break;case"stretch":this.setStrategy(new uo);break;case"inline":this.setStrategy(new gr);break;default:throw new Z("Invalid viewport style: "+t)}}_onResize(){let t=this._viewport,n=t.canvas,o=t.virtualSize;n.width=o.width,n.height=o.height;let r=t._backgroundCanvas,a=t._realSize;r.width=a.width,r.height=a.height,this._resizeStrategy.resize(t)}},hr=class{clear(t){t.container.style.cssText="",t._subContainer.style.cssText=""}},gr=class extends hr{resize(t){let n=t.container,o=t._subContainer,r=t.virtualSize;n.style.display="inline-block",n.style.position="relative",n.style.left="0px",n.style.top="0px",n.style.width=r.width+"px",n.style.height=r.height+"px",o.style.position="absolute",o.style.left="0px",o.style.top="0px",o.style.width="100%",o.style.height="100%"}},fr=class extends hr{resize(t){let o=t.container;o.style.position="fixed",o.style.left="0px",o.style.top="0px",o.style.width="100vw",o.style.height="100vh",o.style.zIndex=String(1e9)}},po=class extends fr{resize(t){let n=t._subContainer,o=window.innerWidth/window.innerHeight,r=t.aspectRatio,a=1,A=1,c="0px",u="0px";r<=o?(A=window.innerHeight,a=Math.round(A*r),a-=a%2,c=`calc(50% - ${a>>>1}px)`):(a=window.innerWidth,A=Math.round(a/r),A-=A%2,u=`calc(50% - ${A>>>1}px)`),n.style.position="absolute",n.style.left=c,n.style.top=u,n.style.width=a+"px",n.style.height=A+"px",super.resize(t)}},uo=class extends fr{resize(t){let n=t._subContainer;n.style.position="absolute",n.style.left="0px",n.style.top="0px",n.style.width=window.innerWidth+"px",n.style.height=window.innerHeight+"px",super.resize(t)}},mr=class extends so{constructor(t){super();let n=Object.assign({},Xd,t);this._settings=Object.freeze(n);let o=window.innerWidth/window.innerHeight,r=X.resolution(n.resolution,o);this._mediaSize=()=>r,this._resolution=n.resolution,this._style=n.style,this._containers=new ao(n.container),this._hud=new pr(this,this._subContainer,n.hudContainer),this._canvases=new co(this._subContainer,r,n.canvas),this._resizer=new Ao(this),this._resizer.setStrategyByName(this._style),this._fullscreen=new lo(this)}get container(){return this._containers.container}get style(){return this._style}get hud(){return this._hud}get resolution(){return this._resolution}get virtualSize(){return X.resolution(this._resolution,this.aspectRatio)}get aspectRatio(){let t=this._realSize;return t.width/t.height}get fullscreen(){return this._fullscreen.isActivated()}get fullscreenAvailable(){return this._fullscreen.isAvailable()}get canvas(){return this._canvases.foregroundCanvas}get _backgroundCanvas(){return this._canvases.backgroundCanvas}get _realSize(){return this._mediaSize()}get _subContainer(){return this._containers.subContainer}requestFullscreen(){return this._fullscreen.request()}exitFullscreen(){return this._fullscreen.exit()}convertToPixels(t,n="normalized"){let o=this.canvas,r=t.x,a=t.y;if(n=="adjusted"){let u=o.width/o.height;u>=1?a*=u:r/=u}else if(n!="normalized")throw new Z(`Invalid space: "${n}"`);let A=.5*(1+r)*o.width,c=.5*(1-a)*o.height;return new nt(A,c)}convertFromPixels(t,n="normalized"){let o=this.canvas,r=2*t.x/o.width-1,a=-2*t.y/o.height+1;if(n=="adjusted"){let A=o.width/o.height;A>=1?a/=A:r*=A}else if(n!="normalized")throw new Z(`Invalid space: "${n}"`);return new nt(r,a)}_init(t,n,o){n=="immersive"?this._style!="best-fit"&&this._style!="stretch"&&(X.warning(`Invalid viewport style "${this._style}" for the "${n}" mode`),this._style="best-fit",this._resizer.setStrategyByName(this._style)):n=="inline"&&this._style!="inline"&&(X.warning(`Invalid viewport style "${this._style}" for the "${n}" mode`),this._style="inline",this._resizer.setStrategyByName(this._style)),this._mediaSize=t,this._containers.init(),this._canvases.init(),this._resizer.init(),this._fullscreen.init();let r=this.fullscreenAvailable&&this._settings.fullscreenUI;this._hud._init(qd,o,r)}_release(){this._hud._release(),this._fullscreen.release(),this._resizer.release(),this._canvases.release(),this._containers.release()}}});var go,pt,On=le(()=>{"use strict";go=Ne(be(),1);Cn();Ur();ua();_a();ba();nr();Wn();Fe();pt=class{static startSession(t){return An.instantiate(t)}static isSupported(){return An.isSupported()}static get version(){return"0.4.4-dev"}static get Speedy(){return go.default}static get Tracker(){return rr}static get Source(){return cr}static Viewport(t){return new mr(t)}static Vector2(t,n){return new nt(t,n)}static Vector3(t,n,o){return new Ue(t,n,o)}static get Settings(){return We}};Object.freeze(pt);(_=>_.Speedy=_.Speedy||go.default)(window);X.log(`encantar.js version ${pt.version}. GPU-accelerated Augmented Reality for the web by Alexandre Martins. https://encantar.dev`)});var Wd=Uo((nf,wa)=>{On();wa.exports=pt});return Wd();})();

    (function liveReload() {
       new EventSource('/esbuild').
       addEventListener('change', () => location.reload());
    })();
    
//# sourceMappingURL=encantar.min.js.map
