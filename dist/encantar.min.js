/*!
 * encantar.js version 0.4.6-dev
 * GPU-accelerated Augmented Reality framework for the web
 * Copyright 2022-2026 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * https://encantar.dev
 *
 * @license LGPL-3.0-or-later
 * Date: 2026-02-09T23:40:18.360Z
*/
var AR=(()=>{var Jd=Object.create;var qo=Object.defineProperty;var jd=Object.getOwnPropertyDescriptor;var Zd=Object.getOwnPropertyNames;var $d=Object.getPrototypeOf,eA=Object.prototype.hasOwnProperty;var Yo=y=>{throw TypeError(y)};var ce=(y,t)=>()=>(y&&(t=y(y=0)),t);var Wo=(y,t)=>()=>(t||y((t={exports:{}}).exports,t),t.exports);var tA=(y,t,n,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of Zd(t))!eA.call(y,r)&&r!==n&&qo(y,r,{get:()=>t[r],enumerable:!(o=jd(t,r))||o.enumerable});return y};var Re=(y,t,n)=>(n=y!=null?Jd($d(y)):{},tA(t||!y||!y.__esModule?qo(n,"default",{value:y,enumerable:!0}):n,y));var Vo=(y,t,n)=>t.has(y)||Yo("Cannot "+n);var Vt=(y,t,n)=>(Vo(y,t,"read from private field"),n?n.call(y):t.get(y)),fi=(y,t,n)=>t.has(y)?Yo("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(y):t.set(y,n),mi=(y,t,n,o)=>(Vo(y,t,"write to private field"),o?o.call(y,n):t.set(y,n),n);var be=Wo((Ii,Fr)=>{/*!
 * Speedy Vision version 0.9.1
 * GPU-accelerated Computer Vision for JavaScript
 * Copyright 2020-2024 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * https://github.com/alemart/speedy-vision
 *
 * @license Apache-2.0
 * Date: 2024-07-03T02:16:25.769Z
 */(function(t,n){typeof Ii=="object"&&typeof Fr=="object"?Fr.exports=n():typeof define=="function"&&define.amd?define([],n):typeof Ii=="object"?Ii.Speedy=n():t.Speedy=n()})(self,()=>(()=>{var y={2199:(r,s,d)=>{"use strict";d.d(s,{w:()=>m});var c=d(6634),u=d(1001),g=d(9037),f=d(8581);let A="raf",_="default";class m extends c.Q{static get powerPreference(){return u.c.powerPreference}static set powerPreference(E){u.c.powerPreference=E}static get gpuPollingMode(){return A}static set gpuPollingMode(E){if(E!=="raf"&&E!=="asap")throw new f.qw(`Invalid GPU polling mode: "${E}"`);A=E}static get logging(){return _}static set logging(E){if(E!=="default"&&E!=="none"&&E!=="diagnostic")throw new f.qw(`Invalid logging mode: "${E}"`);E==="diagnostic"&&g.A.log("%c DIAGNOSTIC MODE ","background:red;color:white;font-size:36pt;font-weight:bold"),_=E}}},6306:(r,s,d)=>{"use strict";d.d(s,{r:()=>b});var c=d(6465),u=d(9037),g=d(8581);let f=Object.freeze({float32:Float32Array});class b{constructor(R,F,q){u.A.assert(R>0&&F>0),u.A.assert(q===b.DEFAULT_DTYPE),this._rows=R|0,this._columns=F|0,this._dtype=q}get rows(){return this._rows}get columns(){return this._columns}get dtype(){return this._dtype}static get DEFAULT_DTYPE(){return"float32"}static get BUFFER_TYPE(){return f}plus(R){return new S(this,R)}minus(R){return new D(this,R)}times(R){return typeof R=="number"?new M(this,R):new B(this,R)}transpose(){return new E(this)}inverse(){return new w(this)}compMult(R){return new Q(this,R)}ldiv(R){return new U(this,R)}toString(){return`SpeedyMatrixExpr(rows=${this.rows}, columns=${this.columns})`}_evaluate(R,F){throw new g.aQ}}let{SpeedyMatrix:A}=d(4188);class _ extends b{constructor(R,F,q){super(R,F,q),this._tempMatrix=A.Zeros(this.rows,this.columns,this.dtype)}}class m extends _{constructor(R,F,q){super(R,F,q.dtype),this._operand=q}_evaluate(R,F){let q=this._operand._evaluate(R,F),j=this._tempMatrix,V=c.U.allocateMat32(R,F,j),te=c.U.allocateMat32(R,F,q);return c.U.copyToMat32(R,F,te,q),this._compute(R,F,V,te),c.U.copyFromMat32(R,F,V,j),c.U.deallocateMat32(R,F,te),c.U.deallocateMat32(R,F,V),j}_compute(R,F,q,j){throw new g.aQ}}class x extends _{constructor(R,F,q,j){u.A.assert(q.dtype===j.dtype),super(R,F,q.dtype),this._left=q,this._right=j}_evaluate(R,F){let q=this._left._evaluate(R,F),j=this._right._evaluate(R,F),V=this._tempMatrix,te=c.U.allocateMat32(R,F,V),ge=c.U.allocateMat32(R,F,q),Be=c.U.allocateMat32(R,F,j);return c.U.copyToMat32(R,F,ge,q),c.U.copyToMat32(R,F,Be,j),this._compute(R,F,te,ge,Be),c.U.copyFromMat32(R,F,te,V),c.U.deallocateMat32(R,F,Be),c.U.deallocateMat32(R,F,ge),c.U.deallocateMat32(R,F,te),V}_compute(R,F,q,j,V){throw new g.aQ}}class E extends m{constructor(R){super(R.columns,R.rows,R)}_compute(R,F,q,j){R.exports.Mat32_transpose(q,j)}}class w extends m{constructor(R){u.A.assert(R.rows===R.columns),super(R.rows,R.columns,R),this._size=R.rows}_compute(R,F,q,j){switch(this._size){case 0:break;case 1:R.exports.Mat32_inverse1(q,j);break;case 2:R.exports.Mat32_inverse2(q,j);break;case 3:R.exports.Mat32_inverse3(q,j);break;default:R.exports.Mat32_qr_inverse(q,j);break}}}class M extends m{constructor(R,F){super(R.rows,R.columns,R),this._scalar=+F}_compute(R,F,q,j){R.exports.Mat32_scale(q,j,this._scalar)}}class S extends x{constructor(R,F){u.A.assert(R.rows===F.rows&&R.columns===F.columns),super(R.rows,R.columns,R,F)}_compute(R,F,q,j,V){R.exports.Mat32_add(q,j,V)}}class D extends x{constructor(R,F){u.A.assert(R.rows===F.rows&&R.columns===F.columns),super(R.rows,R.columns,R,F)}_compute(R,F,q,j,V){R.exports.Mat32_subtract(q,j,V)}}class B extends x{constructor(R,F){u.A.assert(R.columns===F.rows),super(R.rows,F.columns,R,F)}_compute(R,F,q,j,V){R.exports.Mat32_multiply(q,j,V)}}class Q extends x{constructor(R,F){u.A.assert(R.rows===F.rows&&R.columns===F.columns),super(F.rows,F.columns,R,F)}_compute(R,F,q,j,V){R.exports.Mat32_compmult(q,j,V)}}class U extends x{constructor(R,F){let q=R.rows,j=R.columns;u.A.assert(q>=j&&F.rows===q&&F.columns===1),super(j,1,R,F)}_compute(R,F,q,j,V){R.exports.Mat32_qr_ols(q,j,V,2)}}},6465:(r,s,d)=>{"use strict";d.d(s,{U:()=>x});var c=d(9192),u=d(8581),g=d(9037),f=d(3816);let b=d(3575),A=null,_=null,m=(M=>({as:{object:M,uint8:new Uint8Array(M.buffer),int32:new Int32Array(M.buffer),uint32:new Uint32Array(M.buffer),float32:new Float32Array(M.buffer),float64:new Float64Array(M.buffer)}}))(typeof WebAssembly>"u"?new Uint8Array(1024):new WebAssembly.Memory({initial:16,maximum:256}));class x{static ready(){return typeof WebAssembly>"u"?c.i.reject(new u.EM("This application requires WebAssembly. Please update your system.")):f.LITTLE_ENDIAN?new c.i((S,D)=>{x._ready(S,D)}):c.i.reject(new u.EM("Can't run WebAssembly code: not in a little-endian machine!"))}static get handle(){if(!A||!_)throw new u.NO("Can't get WASM handle: routines not yet loaded");return{wasm:A,memory:m,module:_}}static imports(S){let D=new E(S);return Object.getOwnPropertyNames(E.prototype).filter(B=>typeof D[B]=="function"&&B!=="constructor").reduce((B,Q)=>(B[Q]=D[Q],B),Object.create(null))}static allocateMat32(S,D,B){let Q=S.exports.malloc(B.data.byteLength);return S.exports.Mat32_create(B.rows,B.columns,B.step0,B.step1,B._data.length,Q)}static deallocateMat32(S,D,B){let Q=S.exports.Mat32_data(B);return S.exports.free(B),S.exports.free(Q),0}static copyToMat32(S,D,B,Q){g.A.assert(Q.data.byteLength===S.exports.Mat32_dataSize(B));let U=S.exports.Mat32_data(B);return D.as.float32.set(Q.data,U/Float32Array.BYTES_PER_ELEMENT),B}static copyFromMat32(S,D,B,Q){g.A.assert(Q.data.byteLength===S.exports.Mat32_dataSize(B));let U=S.exports.Mat32_data(B)/Float32Array.BYTES_PER_ELEMENT;for(let O=Q.data.length-1;O>=0;O--)Q.data[O]=D.as.float32[U+O];return B}static _ready(S,D,B=1e3){A!==null&&_!==null?S({wasm:A,memory:m,module:_}):B<=0?D(new u.MU("Can't load WASM routines")):setTimeout(x._ready,0,S,D,B-1)}}class E{constructor(S){return Object.getOwnPropertyNames(this.constructor.prototype).filter(B=>typeof this[B]=="function").filter(B=>B!=="constructor").forEach(B=>{this[B]=this[B].bind(this)}),this.memory=S,this.cstring=new w(S),Object.freeze(this)}print(S){g.A.log(this.cstring.get(S))}fatal(S){throw new u.NO(this.cstring.get(S))}bytefill(S,D,B){this.memory.as.uint8.fill(S,D,B)}copyWithin(S,D,B){this.memory.as.uint8.copyWithin(S,D,B)}}class w{constructor(S){this._decoder=new TextDecoder("utf-8"),this._memory=S}get(S){let D=this._memory.as.uint8,B=this._memory.as.uint8.byteLength,Q=S;for(;Q<B&&D[Q]!==0;)++Q;return this._decoder.decode(D.subarray(S,Q))}}(function(S){let D=B=>Uint8Array.from(atob(B),Q=>Q.charCodeAt(0));typeof WebAssembly>"u"||c.i.resolve(b).then(B=>D(B)).then(B=>WebAssembly.instantiate(B,{env:Object.assign({memory:S.as.object},x.imports(S))})).then(B=>{A=B.instance,_=B.module,B.instance.exports.srand(Date.now()*.001&4294967295),g.A.log("The WebAssembly routines have been loaded!")}).catch(B=>{throw new u.NO(`Can't load the WebAssembly routines: ${B}`,B)})})(m)},4188:(r,s,d)=>{"use strict";d.r(s),d.d(s,{SpeedyMatrix:()=>b});var c=d(6306),u=d(6465),g=d(9192),f=d(9037);class b extends c.r{constructor(_,m,x,E,w){super(_,m,c.r.DEFAULT_DTYPE),f.A.assert(w.constructor===c.r.BUFFER_TYPE[this.dtype]),f.A.assert(x>0&&E>=x),f.A.assert(w.length+_*m===0||w.length===1+x*(_-1)+E*(m-1)),this._step0=x|0,this._step1=E|0,this._data=w}static Create(_,m,x,E=c.r.DEFAULT_DTYPE){return f.A.assert(_*m>0,"Can't create a matrix without a shape"),f.A.assert(_*m===x.length,`Can't create matrix: expected ${_*m} entries, but found ${x.length}`),f.A.assert(Object.prototype.hasOwnProperty.call(c.r.BUFFER_TYPE,E),`Invalid dtype: "${E}"`),new b(_,m,1,_,Reflect.construct(c.r.BUFFER_TYPE[E],[x]))}static Zeros(_,m=_,x=c.r.DEFAULT_DTYPE){return f.A.assert(_*m>0,"Can't create a matrix without a shape"),f.A.assert(Object.prototype.hasOwnProperty.call(c.r.BUFFER_TYPE,x),`Invalid dtype: "${x}"`),new b(_,m,1,_,Reflect.construct(c.r.BUFFER_TYPE[x],[_*m]))}static Ones(_,m=_,x=c.r.DEFAULT_DTYPE){return f.A.assert(_*m>0,"Can't create a matrix without a shape"),f.A.assert(Object.prototype.hasOwnProperty.call(c.r.BUFFER_TYPE,x),`Invalid dtype: "${x}"`),new b(_,m,1,_,Reflect.construct(c.r.BUFFER_TYPE[x],[_*m]).fill(1))}static Eye(_,m=_,x=c.r.DEFAULT_DTYPE){f.A.assert(_*m>0,"Can't create a matrix without a shape"),f.A.assert(Object.prototype.hasOwnProperty.call(c.r.BUFFER_TYPE,x),`Invalid dtype: "${x}"`);let E=Reflect.construct(c.r.BUFFER_TYPE[x],[_*m]);for(let w=Math.min(_,m)-1;w>=0;w--)E[w*_+w]=1;return new b(_,m,1,_,E)}static From(_){return b.Zeros(_.rows,_.columns,_.dtype).setToSync(_)}static ready(){return u.U.ready().then(_=>{})}get data(){return this._data}get step0(){return this._step0}get step1(){return this._step1}block(_,m,x,E){f.A.assert(_<=m&&x<=E,`Invalid indices: [${_}:${m},${x}:${E}]`),_=Math.max(_,0),m=Math.min(m,this._rows-1),x=Math.max(x,0),E=Math.min(E,this._columns-1);let w=m-_+1,M=E-x+1,S=this._step0,D=this._step1,B=_*S+x*D,Q=1+m*S+E*D;return new b(w,M,S,D,this._data.subarray(B,Q))}row(_){return this.block(_,_,0,this._columns-1)}column(_){return this.block(0,this._rows-1,_,_)}diagonal(){let _=Math.min(this._rows,this._columns),m=_,x=1,E=this._step0+this._step1,w=0,M=1+(_-1)*E;return new b(m,x,E,E,this._data.subarray(w,M))}at(_,m){return _>=0&&_<this._rows&&m>=0&&m<this._columns?this._data[this._step0*_+this._step1*m]:Number.NaN}read(){let _=new Array(this._rows*this._columns),m=this._step0,x=this._step1,E=0;for(let w=0;w<this._columns;w++)for(let M=0;M<this._rows;M++)_[E++]=this._data[M*m+w*x];return _}toString(){let m=this.rows,x=this.columns,E=this.read(),w=new Array(m);for(let B=0;B<m;B++){w[B]=new Array(x);for(let Q=0;Q<x;Q++)w[B][Q]=E[Q*m+B]}let M=B=>B.toFixed(5),S=w.map(B=>"    "+B.map(M).join(", ")).join(`,
`);return`SpeedyMatrix(rows=${m}, columns=${x}, data=[
${S}
])`}setTo(_){return u.U.ready().then(m=>this.setToSync(_))}setToSync(_){let{wasm:m,memory:x}=u.U.handle,E=_._evaluate(m,x);f.A.assert(this._rows===E._rows&&this._columns===E._columns&&this.dtype===E.dtype,`Can't set the values of a ${this.rows} x ${this.columns} ${this.dtype} matrix to those of a ${E.rows} x ${E.columns} ${E.dtype} matrix`);let w=this._step0,M=this._step1,S=E._step0,D=E._step1;if(w===S&&M===D&&this._data.length===E._data.length)this._data.set(E._data);else for(let B=this._columns-1;B>=0;B--)for(let Q=this._rows-1;Q>=0;Q--)this._data[Q*w+B*M]=E._data[Q*S+B*D];return this}fill(_){return this.fillSync(_),g.i.resolve(this)}fillSync(_){if(_=+_,this._rows*this._columns===this._data.length)return this._data.fill(_),this;for(let m=0;m<this._columns;m++)for(let x=0;x<this._rows;x++)this._data[x*this._step0+m*this._step1]=_;return this}_evaluate(_,m){return this}}},6634:(r,s,d)=>{"use strict";d.d(s,{Q:()=>u});var c=d(8581);class u{constructor(){throw new c.aQ("Namespaces can't be instantiated")}}},9192:(r,s,d)=>{"use strict";d.d(s,{i:()=>A});let c=0,u=1,g=2,f=1,b=typeof queueMicrotask<"u"&&queueMicrotask||typeof process<"u"&&process.nextTick||(_=>Promise.resolve().then(()=>_()));class A{constructor(m){this._state=c,this._value=void 0,this._onFulfillment=null,this._onRejection=null,this._children=0,this[0]=this,this._parent=void 0,this._flags=0,this._fulfill=this._fulfill.bind(this),this._reject=this._reject.bind(this),this._resolve=this._resolve.bind(this),this._broadcastIfAsync=this._broadcastIfAsync.bind(this),m(this._fulfill,this._reject)}then(m,x=null){let E=new A(this._nop);return E._onFulfillment=typeof m=="function"&&m,E._onRejection=typeof x=="function"&&x,E._parent=this,this[this._children++]=E,this._flags&=~f,this._notify(),E}catch(m){return this.then(null,m)}finally(m){let x=E=>(m(),E);return this.then(x,x)}turbocharge(){let m=this;for(this._flags|=f;m._parent!==void 0;)m=m._parent,m._flags|=f;return m._notify(),this}toString(){switch(this._state){case c:return"SpeedyPromise { <pending> }";case u:return`SpeedyPromise { <fulfilled> ${this._value} }`;case g:return`SpeedyPromise { <rejected> ${this._value} }`;default:return""}}get[Symbol.toStringTag](){return"SpeedyPromise"}static resolve(m){let x=new A(this._snop);return typeof m=="object"&&m!==null&&"then"in m||typeof m=="function"&&"then"in m?x._resolve(m):(x._value=m,x._state=u),x}static reject(m){let x=new A(this._snop);return x._value=m,x._state=g,x}static all(m){return new A((x,E)=>{let w=[];for(let Q of m)w.push(Q);let M=w.length;if(M==0){x([]);return}let S=M,D=new Array(M),B=Q=>U=>{D[Q]=U,--S==0&&x(D)};for(let Q=0;Q<M;Q++){let U=w[Q];U.__proto__===A.prototype||U.__proto__===Promise.prototype?U.then(B(Q),E):A.resolve(U).then(B(Q),E)}})}static race(m){return new A((x,E)=>{let w=[];for(let S of m)w.push(S);let M=w.length;for(let S=0;S<M;S++){let D=w[S];D.__proto__===A.prototype||D.__proto__===Promise.prototype?D.then(x,E):A.resolve(D).then(x,E)}})}_fulfill(m){this._setState(u,m)}_reject(m){this._setState(g,m)}_setState(m,x){this._state==c&&(this._state=m,this._value=x,this._notify())}_notify(){if(this._state!=c){if(this._flags&f){this._broadcast();return}b(this._broadcastIfAsync)}}_broadcastIfAsync(){this._flags&f||this._broadcast()}_broadcast(){let m=this._children,x=this._state;if(x===u)for(let E=0;E<m;E++){let w=this[E],M=w._onFulfillment;try{M?M!==w._nop&&(w._resolve(M(this._value)),w._onFulfillment=w._nop):w._fulfill(this._value)}catch(S){w._reject(S)}}else if(x===g)for(let E=0;E<m;E++){let w=this[E],M=w._onRejection;try{M?M!==w._nop&&(w._resolve(M(this._value)),w._onRejection=w._nop):w._reject(this._value)}catch(S){w._reject(S)}}}_resolve(m){if(typeof m!="object"&&typeof m!="function"||m===null){this._fulfill(m);return}if(m===this)throw new TypeError;if(m.__proto__===A.prototype||m.__proto__===Promise.prototype){m.then(this._resolve,this._reject);return}try{let x=m.then;if(typeof x=="function"){let E=this._resolve,w=this._reject;try{x.call(m,M=>{E(M),E=w=this._nop},M=>{w(M),E=w=this._nop})}catch(M){E!==this._nop&&w!==this._nop&&this._reject(M)}}else this._fulfill(m)}catch(x){this._reject(x)}}_nop(){}static _snop(){}}},9420:(r,s,d)=>{"use strict";d.d(s,{gx:()=>We,bf:()=>Ie});var c=d(1001),u=d(9037),g=d(6049),f=d(8581);function b(){b=function($,ee){return new ae($,void 0,ee)};var se=RegExp.prototype,Y=new WeakMap;function ae($,ee,_e){var ve=RegExp($,ee);return Y.set(ve,_e||Y.get($)),_(ve,ae.prototype)}function ne($,ee){var _e=Y.get(ee);return Object.keys(_e).reduce(function(ve,pe){var Se=_e[pe];if(typeof Se=="number")ve[pe]=$[Se];else{for(var Ge=0;$[Se[Ge]]===void 0&&Ge+1<Se.length;)Ge++;ve[pe]=$[Se[Ge]]}return ve},Object.create(null))}return A(ae,RegExp),ae.prototype.exec=function($){var ee=se.exec.call(this,$);if(ee){ee.groups=ne(ee,this);var _e=ee.indices;_e&&(_e.groups=ne(_e,this))}return ee},ae.prototype[Symbol.replace]=function($,ee){if(typeof ee=="string"){var _e=Y.get(this);return se[Symbol.replace].call(this,$,ee.replace(/\$<([^>]+)>/g,function(pe,Se){var Ge=_e[Se];return"$"+(Array.isArray(Ge)?Ge.join("$"):Ge)}))}if(typeof ee=="function"){var ve=this;return se[Symbol.replace].call(this,$,function(){var pe=arguments;return typeof pe[pe.length-1]!="object"&&(pe=[].slice.call(pe)).push(ne(pe,ve)),ee.apply(this,pe)})}return se[Symbol.replace].call(this,$,ee)},b.apply(this,arguments)}function A(se,Y){if(typeof Y!="function"&&Y!==null)throw new TypeError("Super expression must either be null or a function");se.prototype=Object.create(Y&&Y.prototype,{constructor:{value:se,writable:!0,configurable:!0}}),Object.defineProperty(se,"prototype",{writable:!1}),Y&&_(se,Y)}function _(se,Y){return _=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(ae,ne){return ae.__proto__=ne,ae},_(se,Y)}let m=d(3816),x=Object.keys(m).filter(se=>typeof m[se]=="number").reduce((se,Y)=>(se[Y]=m[Y],se),{}),E=Object.freeze(Object.assign(Object.assign({},x),{},{FS_USE_CUSTOM_PRECISION:0,FS_OUTPUT_TYPE:0,PIXELCOMPONENT_RED:g.kQ.RED,PIXELCOMPONENT_GREEN:g.kQ.GREEN,PIXELCOMPONENT_BLUE:g.kQ.BLUE,PIXELCOMPONENT_ALPHA:g.kQ.ALPHA})),w=(se,Y)=>Object.freeze({APPLE:/(Mac|iOS|iPhone|iPad|iPod)/i.test(se)|0,APPLE_GPU:/Apple/.test(Y)|0,INTEL_GRAPHICS:/Intel.*Graphics/.test(Y)|0}),M=[/\/\*(.|\s)*?\*\//g,/\/\/.*$/gm],S=/^\s*@\s*include\s+"(.*?)"/gm,D=/@(\w+)@/g,B=[b(/@\s*unroll\s+?for\s*\(\s*(int|)\s*(\w+)\s*=\s*(\x2D?\d+|\w+)\s*;\s*\2\s*(<=?)\s*(\x2D?\d+|\w+)\s*;\s*\2\s*\+\+()\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,{counter:2}),b(/@\s*unroll\s+?for\s*\(\s*(int|)\s*(\w+)\s*=\s*(\x2D?\d+|\w+)\s*;\s*\2\s*(<=?)\s*(\x2D?\d+|\w+)\s*;\s*\2\s*\+=\s*(\x2D?\d+)\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,{counter:2})];class Q{static generateGLSL(Y,ae,ne=null,$=null){let ee=[],_e=O(Y),ve=U(Y,ae,ne,$);return F(ve.replace(M[0],"").replace(M[1],"").replace(D,(pe,Se)=>String(_e.has(Se)?Number(_e.get(Se)):(ee.push(`Undefined constant ${Se}`),0))).replace(S,(pe,Se)=>Q.generateGLSL(Y,R(Se))),Y)+ee.map(pe=>`
#error ${pe}
`).join("")}}function U(se,Y,ae=null,ne=null){let $=[];ae!==null&&$.push(ae);for(let[ee,_e]of se)$.push(`#define ${ee} ${Number(_e)}`);return $.push(Y),ne!==null&&$.push(ne),$.join(`
`)}function O(se){u.A.assert(c.c.isInitialized());let Y=new Map,ae=Object.assign(Object.create(null),E,w(u.A.platformString(),c.c.instance.renderer));for(let ne in ae)Y.set(ne,ae[ne]);for(let[ne,$]of se)Y.set(ne,$);return Y}function R(se){if(String(se).match(/^[a-zA-Z0-9_-]+\.glsl$/))return d(5235)("./"+se);throw new f.kG(`Shader preprocessor: can't read file "${se}"`)}function F(se,Y){let ae=q.bind(Y),ne=B.length;for(let $=0;$<ne;$++)se=se.replace(B[$],ae);return se}function q(se,Y,ae,ne,$,ee,_e,ve){let pe=this,Se=Number.isFinite(+ne)||pe.has(ne),Ge=Number.isFinite(+ee)||pe.has(ee);if(!Se||!Ge){if(pe.size>0)throw new f.mB(`Can't unroll loop: unknown limits (start=${ne}, end=${ee}). Code:

${se}`);return se}let Xt=pe.has(ne)?pe.get(ne):parseInt(ne),Nn=pe.has(ee)?pe.get(ee):parseInt(ee),Rn=_e.length==0?1:parseInt(_e);u.A.assert(Xt<=Nn&&Rn>0);let kt=ve.match(/\bbreak\s*;/)!==null?`switch(1) { default:
`:`{
`;kt+=`${Y} ${ae};
`,Nn+=$=="<="?1:0;for(let gt=Xt;gt<Nn;gt+=Rn)kt+=`{
${ae} = ${gt};
${ve}
}
`;return kt+=`}
`,kt}let j=Object.freeze({position:"a_position",texCoord:"a_texCoord"}),V=Object.freeze({position:0,texCoord:1}),te=`#version 300 es
precision highp float;
precision highp int;

layout (location=${V.position}) in vec2 ${j.position};
layout (location=${V.texCoord}) in vec2 ${j.texCoord};
out highp vec2 texCoord;
uniform highp vec2 texSize;

#define vsinit() gl_Position = vec4(${j.position}, 0.0f, 1.0f); texCoord = ${j.texCoord};


`,ge="#define vsmain() ;",Be=`

void main() { vsinit(); vsmain(); }
`,Oe=`#version 300 es

#if @FS_USE_CUSTOM_PRECISION@ == 0
precision mediump float; // ~float16
precision mediump sampler2D;
precision highp int; // int32
#endif

#if @FS_OUTPUT_TYPE@ == 0
#define OUT_TYPE mediump vec4
#elif @FS_OUTPUT_TYPE@ == 1
#define OUT_TYPE mediump ivec4
#elif @FS_OUTPUT_TYPE@ == 2
#define OUT_TYPE mediump uvec4
#else
#error Unknown FS_OUTPUT_TYPE
#endif

out OUT_TYPE color;
in highp vec2 texCoord;
uniform highp vec2 texSize;

@include "global.glsl"

`,Xe=Symbol();class qe{constructor(Y,ae,ne,$,ee){if(Y!==Xe)throw new f.Er;this._arguments=[...ae],this._defines=new Map(ne),this._fragmentSource=Q.generateGLSL(this._defines,$,Oe),this._vertexSource=Q.generateGLSL(this._defines,ee,te,Be),this._uniforms=this._autodetectUniforms(this._fragmentSource+`
`+this._vertexSource),this._validateArguments(this._arguments,this._uniforms)}get fragmentSource(){return this._fragmentSource}get vertexSource(){return this._vertexSource}get attributes(){return j}get locationOfAttributes(){return V}get arguments(){return[].concat(this._arguments)}get uniforms(){return Array.from(this._uniforms.keys())}uniformType(Y){if(!this._uniforms.has(Y))throw new f.qw(`Unrecognized uniform variable: "${Y}"`);return this._uniforms.get(Y)}definedConstant(Y){if(!this._defines.has(Y))throw new f.qw(`Unrecognized externally defined constant: "${Y}"`);return this._defines.get(Y)}_autodetectUniforms(Y){let ae=Y,ne=/^\s*uniform\s+(highp\s+|mediump\s+|lowp\s+)?(\w+)\s+([^;]+)/gm,$=new Map,ee;for(;(ee=ne.exec(ae))!==null;){let _e=ee[2],ve=ee[3].split(",").map(pe=>pe.trim()).filter(pe=>pe);for(let pe of ve)if(pe.endsWith("]")){if(!(ee=pe.match(/(\w+)\s*\[\s*(\d+)\s*\]$/)))throw new f.mB(`Unspecified array length for uniform "${pe}" in the shader`);let[Se,Ge]=[ee[1],Number(ee[2])];for(let Xt=0;Xt<Ge;Xt++)$.set(`${Se}[${Xt}]`,_e)}else if(!$.has(pe)||$.get(pe)===_e)$.set(pe,_e);else throw new f.Er(`Redefinition of uniform "${pe}" in the shader`)}return $}_validateArguments(Y,ae){for(let ne of Y)if(!ae.has(ne)&&!ae.has(ne+"[0]"))throw new f.qw(`Argument "${ne}" has not been declared in the shader`)}}class le extends qe{constructor(Y,ae,ne,$,ee=ge){super(Y,ae,ne,$,ee),this._fsUnprocessedSource=String($),this._vsUnprocessedSource=String(ee)}}class L extends qe{constructor(Y,ae,ne,$,ee=""){if(String($).match(/^[a-zA-Z0-9_\-/]+\.glsl$/)){if(ee!=""&&!String(ee).match(/^[a-zA-Z0-9_\-/]+\.vs\.glsl$/))throw new f.kG(`Can't import vertex shader at "${ee}"`)}else throw new f.kG(`Can't import fragment shader at "${$}"`);let _e=d(4606)("./"+String($)),ve=ee!=""?d(4606)("./"+String(ee)):ge;super(Y,ae,ne,_e,ve),this._fsFilepath=String($),this._vsFilepath=String(ee)}get fragmentSource(){return this._addHeader("// File: "+this._fsFilepath,super.fragmentSource)}get vertexSource(){return this._addHeader("// File: "+(this._vsFilepath!=""?this._vsFilepath:"(default-vs) "+this._fsFilepath),super.vertexSource)}_addHeader(Y,ae){u.A.assert(Y.startsWith("//")&&!Y.includes(`
`));let ne=ae.indexOf(`
`),$=ae.substr(0,ne),ee=ae.substr(ne);return u.A.assert($.startsWith("#version ")),$+`
`+Y+ee}}class J{constructor(Y){if(Y!==Xe)throw new f.Er;this._arguments=[],this._defines=new Map}withArguments(...Y){if(this._arguments.length>0)throw new f.Er("Redefinition of shader arguments");for(let ae=0;ae<Y.length;ae++)this._arguments.push(String(Y[ae]));return this}withDefines(Y){if(this._defines.size>0)throw new f.Er("Redefinition of externally defined constants of a shader");let ae=Object.keys(Y);for(let ne of ae){let $=Number(Y[ne]);this._defines.set(ne,$)}return this}build(){throw new f.aQ}}class ye extends J{constructor(Y,ae,ne){super(Y),this._fsSource=String(ae),this._vsSource=ne!==void 0?String(ne):void 0}build(){return new le(Xe,this._arguments,this._defines,this._fsSource,this._vsSource)}}class ie extends J{constructor(Y,ae,ne){super(Y),this._fsFilepath=String(ae),this._vsFilepath=ne!==void 0?String(ne):void 0}build(){return new L(Xe,this._arguments,this._defines,this._fsFilepath,this._vsFilepath)}}function Ie(se,Y=void 0){return new ie(Xe,se,Y)}function We(se,Y=void 0){return new ye(Xe,se,Y)}},1672:(r,s,d)=>{"use strict";d.r(s),d.d(s,{conv2D:()=>f,convX:()=>b,convY:()=>A});var c=d(9420),u=d(9037),g=d(8581);function f(m,x=1){let E=new Float32Array(m.map(U=>+U*+x)),w=Math.sqrt(E.length)|0,M=w>>1;if(w<1||w%2==0)throw new g.qw(`Can't perform a 2D convolution with an invalid kSize of ${w}`);if(w*w!=E.length)throw new g.qw(`Invalid 2D convolution kernel of ${E.length} elements (expected: square)`);let S=M<=7?"pixelAtShortOffset":"pixelAtLongOffset",Q=`
    uniform sampler2D image;

    void main()
    {
        float alpha = threadPixel(image).a;
        vec4 result = vec4(0.0f);

        ${(U=>u.A.cartesian(u.A.symmetricRange(M),u.A.symmetricRange(M)).map(O=>U(E[(O[0]+M)*w+(O[1]+M)],O[0],O[1])).join(`
`))((U,O,R)=>`
        result += ${S}(image, ivec2(${-R|0}, ${-O|0})) * float(${+U});
    `)}

        color = vec4(result.rgb, alpha);
    }
    `;return(0,c.gx)(Q).withArguments("image")}function b(m,x=1){return _("x",m,x)}function A(m,x=1){return _("y",m,x)}function _(m,x,E=1){let w=new Float32Array(x.map(O=>+O*+E)),M=w.length,S=M>>1;if(M<1||M%2==0)throw new g.qw(`Can't perform a 1D convolution with an invalid kSize of ${M}`);if(m!="x"&&m!="y")throw new g.qw(`Can't perform 1D convolution: invalid axis "${m}"`);let D=S<=7?"pixelAtShortOffset":"pixelAtLongOffset",U=`
    uniform sampler2D image;

    void main()
    {
        float alpha = threadPixel(image).a;
        vec4 pixel = vec4(0.0f);

        ${(O=>u.A.symmetricRange(S).reduce((R,F)=>R+O(w[F+S],F),""))((O,R)=>m=="x"?`
        pixel += ${D}(image, ivec2(${-R|0}, 0)) * float(${+O});
    `:`
        pixel += ${D}(image, ivec2(0, ${-R|0})) * float(${+O});
    `)}

        color = vec4(pixel.rgb, alpha);
    }
    `;return(0,c.gx)(U).withArguments("image")}},1001:(r,s,d)=>{"use strict";d.d(s,{c:()=>M});var c=d(9037),u=d(2199),g=d(3211),f=d(9192),b=d(8581);let A=Symbol(),_="default",m=16,x=16,E=null,w=_;class M extends g.c{constructor(D){c.A.assert(D===A),super(),this._reinitializeOnContextLoss=!0,this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._vendor="",this._renderer="",this._readDriverInfo(),u.w.logging==="diagnostic"&&this._logDriverInfo()}static get instance(){return E||(E=new M(A))}get gl(){return this._gl}get canvas(){return this._canvas}get renderer(){return this._renderer}get vendor(){return this._vendor}_createCanvas(D){let B=c.A.createCanvas(m,x);return B.addEventListener("webglcontextlost",Q=>{c.A.warning("Lost WebGL2 context"),setTimeout(D,0),Q.preventDefault()},!1),B}_createContext(D){if(c.A.log(`Creating a ${w} WebGL2 rendering context...`),typeof WebGL2RenderingContext>"u")throw new b.EM("This application requires WebGL2. Please update your system.");let B=D.getContext("webgl2",{premultipliedAlpha:!1,preserveDrawingBuffer:!1,powerPreference:w,alpha:!0,antialias:!1,depth:!1,stencil:!1,desynchronized:!0});if(!B)throw new b.EM("Can't create a WebGL2 Rendering Context. Try a different browser!");return B}_reinitialize(){this._reinitializeOnContextLoss&&(c.A.warning("Reinitializing WebGL2..."),this._canvas.remove(),this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._readDriverInfo(),this._notify())}_readDriverInfo(){let D=this._gl,B=null;navigator.userAgent.includes("Firefox")?(this._vendor="",this._renderer=D.getParameter(D.RENDERER)):(B=D.getExtension("WEBGL_debug_renderer_info"))!=null?(this._vendor=D.getParameter(B.UNMASKED_VENDOR_WEBGL),this._renderer=D.getParameter(B.UNMASKED_RENDERER_WEBGL)):(this._vendor="",this._renderer="")}_logDriverInfo(){c.A.log("Platform: "+c.A.platformString()),c.A.log("GL vendor: "+this.vendor),c.A.log("GL renderer: "+this.renderer)}loseContext(){let D=this._gl,B=D.getExtension("WEBGL_lose_context");if(!B)throw new b.EM("WEBGL_lose_context extension is unavailable");return D.isContextLost()||(this._reinitializeOnContextLoss=!1,B.loseContext()),B}loseAndRestoreContext(D=1){let B=Math.max(D,0)*1e3,Q=this.loseContext();return new f.i(U=>{setTimeout(()=>{this._reinitializeOnContextLoss=!0,this._reinitialize(),setTimeout(()=>U(Q),0)},B)})}static get powerPreference(){return w}static set powerPreference(D){if(!(D==="default"||D==="low-power"||D==="high-performance"))throw new b.qw(`Invalid powerPreference: "${D}"`);(E==null||w!==D)&&(w=D,E?.loseAndRestoreContext())}static isInitialized(){return E!=null}}},8581:(r,s,d)=>{"use strict";d.d(s,{EM:()=>u,Er:()=>_,FJ:()=>E,MU:()=>w,NO:()=>B,Uk:()=>D,aQ:()=>b,kG:()=>x,l:()=>m,mB:()=>M,pf:()=>S,qw:()=>A,wB:()=>f,xB:()=>c});class c extends Error{constructor(U,O=null){super([U,O?O.toString():"[speedy-vision.js]"].join(`
-> `)),this._cause=O}get name(){return this.constructor.name}set name(U){}get cause(){return this._cause}}class u extends c{constructor(U="",O=null){super(`Unsupported operation. ${U}`,O)}}class g extends c{constructor(U="",O=null){super(`Method not implemented. ${U}`,O)}}class f extends c{constructor(U="",O=null){super(`WebGL error. ${U}`,O)}static from(U){let O=["NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL"],R=U.getError(),F=O.find(q=>U[q]==R)||"Unknown";return new f(F)}}class b extends c{constructor(U="",O=null){super(`Can't call abstract method. ${U}`,O)}}class A extends c{constructor(U="",O=null){super(`Illegal argument. ${U}`,O)}}class _ extends c{constructor(U="",O=null){super(`Illegal operation. ${U}`,O)}}class m extends c{constructor(U="",O=null){super(`Out of memory. ${U}`,O)}}class x extends c{constructor(U="",O=null){super(`File not found. ${U}`,O)}}class E extends c{constructor(U="",O=null){super(`Resource not loaded. ${U}`,O)}}class w extends c{constructor(U="",O=null){super(`Timeout error. ${U}`,O)}}class M extends c{constructor(U="",O=null){super(`Parse error. ${U}`,O)}}class S extends c{constructor(U="",O=null){super(`Assertion failed. ${U}`,O)}}class D extends c{constructor(U="",O=null){super(`Access denied. ${U}`,O)}}class B extends c{constructor(U="",O=null){super(`WebAssembly error. ${U}`,O)}}},3816:(r,s,d)=>{"use strict";d.r(s),d.d(s,{DEFAULT_ENCODER_CAPACITY:()=>E,FIX_BITS:()=>f,FIX_RESOLUTION:()=>b,LITTLE_ENDIAN:()=>U,LOG2_MAX_DESCRIPTOR_SIZE:()=>w,LOG2_PYRAMID_MAX_SCALE:()=>u,MATCH_INDEX_BITS:()=>S,MATCH_INDEX_MASK:()=>D,MATCH_MAX_DISTANCE:()=>Q,MATCH_MAX_INDEX:()=>B,MAX_DESCRIPTOR_SIZE:()=>M,MAX_ENCODER_CAPACITY:()=>x,MAX_TEXTURE_LENGTH:()=>A,MIN_ENCODER_LENGTH:()=>m,MIN_KEYPOINT_SIZE:()=>_,PYRAMID_MAX_LEVELS:()=>c,PYRAMID_MAX_SCALE:()=>g});let c=8,u=0,g=1<<u,f=3,b=1<<f,A=(1<<16-f)-1,_=8,m=2,x=8192,E=2048,w=6,M=1<<w,S=32-(w+3),D=(1<<S)-1,B=(1<<S)-1,Q=(1<<32-S)-1,U=function(){return new Uint16Array(new Uint8Array([254,202]).buffer)[0]===51966}()},3211:(r,s,d)=>{"use strict";d.d(s,{c:()=>c});class c{constructor(){this._subscribers=[],this._thisptr=[],this._args=[]}subscribe(g,f,...b){this._subscribers.push(g),this._thisptr.push(f),this._args.push(b)}unsubscribe(g,f){for(let b=this._subscribers.length-1;b>=0;b--)if(this._subscribers[b]===g&&this._thisptr[b]===f){this._subscribers.splice(b,1),this._thisptr.splice(b,1),this._args.splice(b,1);break}}_notify(){for(let g=0;g<this._subscribers.length;g++)this._subscribers[g].apply(this._thisptr[g],this._args[g])}}},6049:(r,s,d)=>{"use strict";d.d(s,{f5:()=>u,kQ:()=>g,kg:()=>f,zu:()=>c});let c=Object.freeze({Image:Symbol("Image"),Video:Symbol("Video"),Canvas:Symbol("Canvas"),OffscreenCanvas:Symbol("OffscreenCanvas"),Bitmap:Symbol("Bitmap"),Data:Symbol("Data")}),u=Object.freeze({RGBA:Symbol("RGBA"),GREY:Symbol("GREY")}),g=Object.freeze({RED:1,GREEN:2,BLUE:4,ALPHA:8,ALL:15}),f=Object.freeze({[g.RED]:0,[g.GREEN]:1,[g.BLUE]:2,[g.ALPHA]:3})},9037:(r,s,d)=>{"use strict";d.d(s,{A:()=>f});var c=d(8581),u=d(9192),g=d(2199);class f{static warning(A,..._){g.w.logging!=="none"&&console.warn("[speedy-vision] "+A,..._)}static log(A,..._){g.w.logging!=="none"&&console.log("[speedy-vision] "+A,..._)}static assert(A,_=""){if(!A)throw new c.pf(_)}static functionArguments(A){let _=A.toString(),m=_.startsWith("function")?"function\\s.*\\(([^)]*)\\)":_.startsWith("(")?"\\(([^)]*)\\).*=>":"([^=]+).*=>",x=new RegExp(m).exec(_);if(x!==null)return x[1].replace(/\/\*.*?\*\//g,"").split(",").map(w=>w.replace(/=.*$/,"").trim()).filter(w=>w);throw new c.mB(`Can't detect function arguments of ${_}`)}static getAllPropertyDescriptors(A){if(A){let _=Object.getPrototypeOf(A);return Object.assign(Object.assign({},f.getAllPropertyDescriptors(_)),Object.getOwnPropertyDescriptors(A))}else return Object.create(null)}static createCanvas(A,_){let m=document.createElement("canvas");return m.width=A,m.height=_,m}static gaussianKernel(A,_=0,m=!0){if(_==0&&(_=Math.ceil(5*A)|0,_+=1-_%2),_|=0,_<1||_%2==0)throw new c.qw(`Invalid kernel size given to gaussianKernel: ${_} x 1`);if(A<=0)throw new c.qw(`Invalid sigma given to gaussianKernel: ${A}`);let x=new Array(_),E=_>>1,w=+A*1.4142135623730951,M=.3275911,S=.254829592,D=-.284496736,B=1.421413741,Q=-1.453152027,U=1.061405429,O=0;for(let R=0;R<_;R++){let F=(R-E+.5)/w,q=(R-E-.5)/w,j=1,V=1;F<0&&(j=-1,F=-F),q<0&&(V=-1,q=-q);let te=1/(1+M*F),ge=1/(1+M*q),Be=((((U*te+Q)*te+B)*te+D)*te+S)*te,Oe=((((U*ge+Q)*ge+B)*ge+D)*ge+S)*ge,Xe=1-Be*Math.exp(-F*F),qe=1-Oe*Math.exp(-q*q),le=j*Xe,L=V*qe,J=(le-L)/(2*w);x[R]=J,O+=J}if(m)for(let R=0;R<_;R++)x[R]/=O;return x}static kernel2d(A,_=A){let m=A.length;f.assert(A.length==A.length),f.assert(m>=1&&m%2==1);let x=new Array(m*m),E=0;for(let w=0;w<m;w++)for(let M=0;M<m;M++)x[E++]=A[M]*_[w];return x}static cartesian(A,_){return[].concat(...A.map(m=>_.map(x=>[m,x])))}static symmetricRange(A){if((A|=0)<0)throw new c.qw("Expected a non-negative integer as input");return[...Array(2*A+1).keys()].map(_=>_-A)}static range(A){if((A|=0)<=0)throw new c.qw("Expected a positive integer as input");return[...Array(A).keys()]}static shuffle(A){let _=A.length,m=_-1;for(let x=0;x<m;x++){let E=x+(Math.random()*(_-x)|0);if(x!==E){let w=A[x];A[x]=A[E],A[E]=w}}return A}static flatten(A){let _=[];for(let m=0,x=A.length;m<x;m++){let E=A[m];if(Array.isArray(E))for(let w=0,M=E.length;w<M;w++)_.push(E[w]);else _.push(E)}return _}static decodeFloat16(A){let _=(A&65535)>>15,m=(A&32767)>>10,x=A&1023,E=1-2*_;if(m==0)return x==0?E*0:E*x*5960464477539063e-23;if(m==31)return x==0?E*Number.POSITIVE_INFINITY:Number.NaN;let w=m>=15?1<<m-15:1/(1<<15-m);return E*w*(1+x*.0009765625)}static requestCameraStream(A={audio:!1,video:!0}){if(f.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new c.EM("Unsupported browser: no mediaDevices.getUserMedia()");return new u.i((_,m)=>{navigator.mediaDevices.getUserMedia(A).then(x=>{let E=document.createElement("video");E.onloadedmetadata=()=>{E.play(),f.log(`The camera is on! Resolution: ${E.videoWidth} x ${E.videoHeight}`),_(E)},E.setAttribute("playsinline",""),E.setAttribute("autoplay",""),(A.audio===!1||A.audio===void 0)&&E.setAttribute("muted",""),E.srcObject=x}).catch(x=>{x.name==="NotAllowedError"?m(new c.Uk("Please give access to the camera and reload the page.",x)):x.name==="OverconstrainedError"||x.name==="NotFoundError"?m(new c.EM(`Can't access the webcam with the requested constraints: ${JSON.stringify(A)}.`,x)):m(new c.xB("Can't access the webcam.",x))})})}static formatBinaryData(A){let _=new Uint8Array(A);return Array.from(_,x=>x.toString(16).padStart(2,"0")).join(" ")}static platformString(){return typeof navigator.userAgentData=="object"?navigator.userAgentData.platform:navigator.platform}}},5235:(r,s,d)=>{var c={"./colors.glsl":8609,"./filters.glsl":4672,"./fixed-point.glsl":9778,"./float16.glsl":8710,"./global.glsl":2434,"./int32.glsl":439,"./keypoint-descriptors.glsl":8545,"./keypoint-matches.glsl":6762,"./keypoints.glsl":7639,"./math.glsl":431,"./platform.glsl":6822,"./pyramids.glsl":2728,"./subpixel.glsl":6823};function u(f){var b=g(f);return d(b)}function g(f){if(!d.o(c,f)){var b=new Error("Cannot find module '"+f+"'");throw b.code="MODULE_NOT_FOUND",b}return c[f]}u.keys=function(){return Object.keys(c)},u.resolve=g,r.exports=u,u.id=5235},4606:(r,s,d)=>{var c={"./filters/convolution":1672,"./filters/convolution.js":1672,"./filters/convolution1d.glsl":8211,"./filters/convolution2d.glsl":7360,"./filters/fast-median.glsl":8191,"./filters/nightvision.glsl":4438,"./filters/normalize-image.glsl":5867,"./filters/rgb2grey.glsl":9252,"./include/colors.glsl":8609,"./include/filters.glsl":4672,"./include/fixed-point.glsl":9778,"./include/float16.glsl":8710,"./include/global.glsl":2434,"./include/int32.glsl":439,"./include/keypoint-descriptors.glsl":8545,"./include/keypoint-matches.glsl":6762,"./include/keypoints.glsl":7639,"./include/math.glsl":431,"./include/platform.glsl":6822,"./include/pyramids.glsl":2728,"./include/subpixel.glsl":6823,"./keypoints/allocate-descriptors.glsl":1341,"./keypoints/allocate-extra.glsl":7833,"./keypoints/apply-homography.glsl":2352,"./keypoints/bf-knn.glsl":7541,"./keypoints/clip-border.glsl":4868,"./keypoints/clip.glsl":5591,"./keypoints/distance-filter.glsl":191,"./keypoints/encode-keypoint-long-offsets.glsl":5467,"./keypoints/encode-keypoint-offsets.glsl":336,"./keypoints/encode-keypoint-positions.glsl":8968,"./keypoints/encode-keypoint-properties.glsl":1733,"./keypoints/encode-keypoints.glsl":9674,"./keypoints/encode-null-keypoints.glsl":2090,"./keypoints/fast.glsl":1855,"./keypoints/fast.vs.glsl":4824,"./keypoints/hamming-distance-filter.glsl":2381,"./keypoints/harris-cutoff.glsl":6060,"./keypoints/harris.glsl":9974,"./keypoints/knn-init.glsl":3047,"./keypoints/knn-transfer.glsl":3266,"./keypoints/laplacian.glsl":8018,"./keypoints/lk.glsl":3168,"./keypoints/lookup-of-locations.glsl":3890,"./keypoints/lookup-of-locations.vs.glsl":8647,"./keypoints/lsh-knn.glsl":4776,"./keypoints/mix-keypoints.glsl":2648,"./keypoints/nonmax-scale.glsl":8825,"./keypoints/nonmax-space.glsl":5693,"./keypoints/nonmax-suppression.glsl":9280,"./keypoints/orb-descriptor.glsl":9108,"./keypoints/orb-orientation.glsl":7137,"./keypoints/refine-scale.glsl":9739,"./keypoints/score-findmax.glsl":8231,"./keypoints/shuffle.glsl":2518,"./keypoints/sort-keypoints.glsl":8096,"./keypoints/subpixel-refinement.glsl":5795,"./keypoints/transfer-flow.glsl":3169,"./keypoints/transfer-orientation.glsl":1337,"./keypoints/transfer-to-extra.glsl":6187,"./keypoints/upload-keypoints.glsl":477,"./pyramids/downsample2.glsl":4050,"./pyramids/upsample2.glsl":5545,"./transforms/additive-mix.glsl":7113,"./transforms/resize.glsl":1202,"./transforms/warp-perspective.glsl":7971,"./utils/copy-components.glsl":6122,"./utils/copy-raster.glsl":371,"./utils/copy.glsl":7307,"./utils/fill-components.glsl":8614,"./utils/fill.glsl":6271,"./utils/flip-y.vs.glsl":3016,"./utils/scan-minmax2d.glsl":3630,"./utils/sobel-derivatives.glsl":8508,"./utils/sobel-derivatives.vs.glsl":8073};function u(f){var b=g(f);return d(b)}function g(f){if(!d.o(c,f)){var b=new Error("Cannot find module '"+f+"'");throw b.code="MODULE_NOT_FOUND",b}return c[f]}u.keys=function(){return Object.keys(c)},u.resolve=g,r.exports=u,u.id=4606},8211:r=>{r.exports=`#if !defined(KERNEL_SIZE) || !defined(AXIS) || (AXIS != 0 && AXIS != 1)
#error Undefined KERNEL_SIZE / AXIS
#endif
uniform sampler2D image;
uniform float kernel[@KERNEL_SIZE@];
const ivec2 axis = ivec2(1-AXIS, AXIS);
#define S(x,k) result += pixelAtShortOffset(image, ivec2((x),(x)) * axis) * kernel[k]
void main()
{
vec4 result = vec4(0.0f);
#if KERNEL_SIZE == 3
S(-1, 2);
S( 0, 1);
S( 1, 0);
#elif KERNEL_SIZE == 5
S(-2, 4);
S(-1, 3);
S( 0, 2);
S( 1, 1);
S( 2, 0);
#elif KERNEL_SIZE == 7
S(-3, 6);
S(-2, 5);
S(-1, 4);
S( 0, 3);
S( 1, 2);
S( 2, 1);
S( 3, 0);
#elif KERNEL_SIZE == 9
S(-4, 8);
S(-3, 7);
S(-2, 6);
S(-1, 5);
S( 0, 4);
S( 1, 3);
S( 2, 2);
S( 3, 1);
S( 4, 0);
#elif KERNEL_SIZE == 11
S(-5, 10);
S(-4, 9);
S(-3, 8);
S(-2, 7);
S(-1, 6);
S( 0, 5);
S( 1, 4);
S( 2, 3);
S( 3, 2);
S( 4, 1);
S( 5, 0);
#elif KERNEL_SIZE == 13
S(-6, 12);
S(-5, 11);
S(-4, 10);
S(-3, 9);
S(-2, 8);
S(-1, 7);
S( 0, 6);
S( 1, 5);
S( 2, 4);
S( 3, 3);
S( 4, 2);
S( 5, 1);
S( 6, 0);
#elif KERNEL_SIZE == 15
S(-7, 14);
S(-6, 13);
S(-5, 12);
S(-4, 11);
S(-3, 10);
S(-2, 9);
S(-1, 8);
S( 0, 7);
S( 1, 6);
S( 2, 5);
S( 3, 4);
S( 4, 3);
S( 5, 2);
S( 6, 1);
S( 7, 0);
#else
#error Invalid parameters
#endif
color = vec4(result.rgb, 1.0f);
}`},7360:r=>{r.exports=`#ifndef KERNEL_SIZE_SQUARED
#error Must define KERNEL_SIZE_SQUARED
#endif
uniform sampler2D image;
uniform float kernel[@KERNEL_SIZE_SQUARED@];
#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]
void main()
{
vec4 result = vec4(0.0f);
#if KERNEL_SIZE_SQUARED == 9
S(-1,-1, 8);
S(-1, 0, 7);
S(-1, 1, 6);
S( 0,-1, 5);
S( 0, 0, 4);
S( 0, 1, 3);
S( 1,-1, 2);
S( 1, 0, 1);
S( 1, 1, 0);
#elif KERNEL_SIZE_SQUARED == 25
S(-2,-2, 24);
S(-2,-1, 23);
S(-2, 0, 22);
S(-2, 1, 21);
S(-2, 2, 20);
S(-1,-2, 19);
S(-1,-1, 18);
S(-1, 0, 17);
S(-1, 1, 16);
S(-1, 2, 15);
S( 0,-2, 14);
S( 0,-1, 13);
S( 0, 0, 12);
S( 0, 1, 11);
S( 0, 2, 10);
S( 1,-2, 9);
S( 1,-1, 8);
S( 1, 0, 7);
S( 1, 1, 6);
S( 1, 2, 5);
S( 2,-2, 4);
S( 2,-1, 3);
S( 2, 0, 2);
S( 2, 1, 1);
S( 2, 2, 0);
#elif KERNEL_SIZE_SQUARED == 49
S(-3,-3, 48);
S(-3,-2, 47);
S(-3,-1, 46);
S(-3, 0, 45);
S(-3, 1, 44);
S(-3, 2, 43);
S(-3, 3, 42);
S(-2,-3, 41);
S(-2,-2, 40);
S(-2,-1, 39);
S(-2, 0, 38);
S(-2, 1, 37);
S(-2, 2, 36);
S(-2, 3, 35);
S(-1,-3, 34);
S(-1,-2, 33);
S(-1,-1, 32);
S(-1, 0, 31);
S(-1, 1, 30);
S(-1, 2, 29);
S(-1, 3, 28);
S( 0,-3, 27);
S( 0,-2, 26);
S( 0,-1, 25);
S( 0, 0, 24);
S( 0, 1, 23);
S( 0, 2, 22);
S( 0, 3, 21);
S( 1,-3, 20);
S( 1,-2, 19);
S( 1,-1, 18);
S( 1, 0, 17);
S( 1, 1, 16);
S( 1, 2, 15);
S( 1, 3, 14);
S( 2,-3, 13);
S( 2,-2, 12);
S( 2,-1, 11);
S( 2, 0, 10);
S( 2, 1, 9);
S( 2, 2, 8);
S( 2, 3, 7);
S( 3,-3, 6);
S( 3,-2, 5);
S( 3,-1, 4);
S( 3, 0, 3);
S( 3, 1, 2);
S( 3, 2, 1);
S( 3, 3, 0);
#else
#error Invalid KERNEL_SIZE_SQUARED
#endif
color = vec4(result.rgb, 1.0f);
}`},8191:r=>{r.exports=`uniform sampler2D image;
#define X(i,j) t = vec2(min(p[i], p[j]), max(p[i], p[j])); p[i] = t.x; p[j] = t.y;
#define S(i,x,y) p[i] = pixelAtShortOffset(image, ivec2((x),(y))).g
void main()
{
float median;
vec2 t;
#if !defined(KERNEL_SIZE)
#error Must define KERNEL_SIZE
#elif KERNEL_SIZE == 3
float p[9];
S(0,-1,-1);
S(1, 0,-1);
S(2, 1,-1);
S(3,-1, 0);
S(4, 0, 0);
S(5, 1, 0);
S(6,-1, 1);
S(7, 0, 1);
S(8, 1, 1);
X(1,2);X(4,5);X(7,8);X(0,1);X(3,4);X(6,7);X(1,2);X(4,5);X(7,8);X(0,3);X(5,8);X(4,7);X(3,6);X(1,4);X(2,5);X(4,7);X(4,2);X(6,4);X(4,2);
median = p[4];
#elif KERNEL_SIZE == 5
float p[25];
S( 0,-2,-2);
S( 1,-1,-2);
S( 2, 0,-2);
S( 3, 1,-2);
S( 4, 2,-2);
S( 5,-2,-1);
S( 6,-1,-1);
S( 7, 0,-1);
S( 8, 1,-1);
S( 9, 2,-1);
S(10,-2, 0);
S(11,-1, 0);
S(12, 0, 0);
S(13, 1, 0);
S(14, 2, 0);
S(15,-2, 1);
S(16,-1, 1);
S(17, 0, 1);
S(18, 1, 1);
S(19, 2, 1);
S(20,-2, 2);
S(21,-1, 2);
S(22, 0, 2);
S(23, 1, 2);
S(24, 2, 2);
X(0,1);X(3,4);X(2,4);X(2,3);X(6,7);X(5,7);X(5,6);X(9,10);X(8,10);X(8,9);X(12,13);X(11,13);X(11,12);X(15,16);X(14,16);X(14,15);X(18,19);X(17,19);X(17,18);X(21,22);X(20,22);X(20,21);X(23,24);X(2,5);X(3,6);X(0,6);X(0,3);X(4,7);X(1,7);X(1,4);X(11,14);X(8,14);X(8,11);X(12,15);X(9,15);X(9,12);X(13,16);X(10,16);X(10,13);X(20,23);X(17,23);X(17,20);X(21,24);X(18,24);X(18,21);X(19,22);X(8,17);X(9,18);X(0,18);X(0,9);X(10,19);X(1,19);X(1,10);X(11,20);X(2,20);X(2,11);X(12,21);X(3,21);X(3,12);X(13,22);X(4,22);X(4,13);X(14,23);X(5,23);X(5,14);X(15,24);X(6,24);X(6,15);X(7,16);X(7,19);X(13,21);X(15,23);X(7,13);X(7,15);X(1,9);X(3,11);X(5,17);X(11,17);X(9,17);X(4,10);X(6,12);X(7,14);X(4,6);X(4,7);X(12,14);X(10,14);X(6,7);X(10,12);X(6,10);X(6,17);X(12,17);X(7,17);X(7,10);X(12,18);X(7,12);X(10,18);X(12,20);X(10,20);X(10,12);
median = p[12];
#elif KERNEL_SIZE == 7
float p[49];
S( 0,-3,-3);
S( 1,-2,-3);
S( 2,-1,-3);
S( 3, 0,-3);
S( 4, 1,-3);
S( 5, 2,-3);
S( 6, 3,-3);
S( 7,-3,-2);
S( 8,-2,-2);
S( 9,-1,-2);
S(10, 0,-2);
S(11, 1,-2);
S(12, 2,-2);
S(13, 3,-2);
S(14,-3,-1);
S(15,-2,-1);
S(16,-1,-1);
S(17, 0,-1);
S(18, 1,-1);
S(19, 2,-1);
S(20, 3,-1);
S(21,-3, 0);
S(22,-2, 0);
S(23,-1, 0);
S(24, 0, 0);
S(25, 1, 0);
S(26, 2, 0);
S(27, 3, 0);
S(28,-3, 1);
S(29,-2, 1);
S(30,-1, 1);
S(31, 0, 1);
S(32, 1, 1);
S(33, 2, 1);
S(34, 3, 1);
S(35,-3, 2);
S(36,-2, 2);
S(37,-1, 2);
S(38, 0, 2);
S(39, 1, 2);
S(40, 2, 2);
S(41, 3, 2);
S(42,-3, 3);
S(43,-2, 3);
S(44,-1, 3);
S(45, 0, 3);
S(46, 1, 3);
S(47, 2, 3);
S(48, 3, 3);
X(0,1);X(2,3);X(0,2);X(1,3);X(1,2);X(4,5);X(6,7);X(4,6);X(5,7);X(5,6);X(0,4);X(2,6);X(2,4);X(1,5);X(3,7);X(3,5);X(1,2);X(3,4);X(5,6);X(8,9);X(10,11);X(8,10);X(9,11);X(9,10);X(12,13);X(14,15);X(12,14);X(13,15);X(13,14);X(8,12);X(10,14);X(10,12);X(9,13);X(11,15);X(11,13);X(9,10);X(11,12);X(13,14);X(0,8);X(4,12);X(4,8);X(2,10);X(6,14);X(6,10);X(2,4);X(6,8);X(10,12);X(1,9);X(5,13);X(5,9);X(3,11);X(7,15);X(7,11);X(3,5);X(7,9);X(11,13);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(16,17);X(18,19);X(16,18);X(17,19);X(17,18);X(20,21);X(22,23);X(20,22);X(21,23);X(21,22);X(16,20);X(18,22);X(18,20);X(17,21);X(19,23);X(19,21);X(17,18);X(19,20);X(21,22);X(24,25);X(26,27);X(24,26);X(25,27);X(25,26);X(28,29);X(30,31);X(28,30);X(29,31);X(29,30);X(24,28);X(26,30);X(26,28);X(25,29);X(27,31);X(27,29);X(25,26);X(27,28);X(29,30);X(16,24);X(20,28);X(20,24);X(18,26);X(22,30);X(22,26);X(18,20);X(22,24);X(26,28);X(17,25);X(21,29);X(21,25);X(19,27);X(23,31);X(23,27);X(19,21);X(23,25);X(27,29);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(0,16);X(8,24);X(8,16);X(4,20);X(12,28);X(12,20);X(4,8);X(12,16);X(20,24);X(2,18);X(10,26);X(10,18);X(6,22);X(14,30);X(14,22);X(6,10);X(14,18);X(22,26);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(1,17);X(9,25);X(9,17);X(5,21);X(13,29);X(13,21);X(5,9);X(13,17);X(21,25);X(3,19);X(11,27);X(11,19);X(7,23);X(15,31);X(15,23);X(7,11);X(15,19);X(23,27);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(32,33);X(34,35);X(32,34);X(33,35);X(33,34);X(36,37);X(38,39);X(36,38);X(37,39);X(37,38);X(32,36);X(34,38);X(34,36);X(33,37);X(35,39);X(35,37);X(33,34);X(35,36);X(37,38);X(40,41);X(42,43);X(40,42);X(41,43);X(41,42);X(44,45);X(46,47);X(44,46);X(45,47);X(45,46);X(40,44);X(42,46);X(42,44);X(41,45);X(43,47);X(43,45);X(41,42);X(43,44);X(45,46);X(32,40);X(36,44);X(36,40);X(34,42);X(38,46);X(38,42);X(34,36);X(38,40);X(42,44);X(33,41);X(37,45);X(37,41);X(35,43);X(39,47);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(32,48);X(40,48);X(36,40);X(44,48);X(38,42);X(34,36);X(38,40);X(42,44);X(46,48);X(37,41);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(47,48);X(0,32);X(16,48);X(16,32);X(8,40);X(24,40);X(8,16);X(24,32);X(40,48);X(4,36);X(20,36);X(12,44);X(28,44);X(12,20);X(28,36);X(4,8);X(12,16);X(20,24);X(28,32);X(36,40);X(44,48);X(2,34);X(18,34);X(10,42);X(26,42);X(10,18);X(26,34);X(6,38);X(22,38);X(14,46);X(30,46);X(14,22);X(30,38);X(6,10);X(14,18);X(22,26);X(30,34);X(38,42);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(30,32);X(34,36);X(38,40);X(42,44);X(46,48);X(1,33);X(17,33);X(9,41);X(25,41);X(9,17);X(25,33);X(5,37);X(21,37);X(13,45);X(29,45);X(13,21);X(29,37);X(5,9);X(13,17);X(21,25);X(29,33);X(37,41);X(3,35);X(19,35);X(11,43);X(27,43);X(11,19);X(27,35);X(7,39);X(23,39);X(15,47);X(31,47);X(15,23);X(31,39);X(7,11);X(15,19);X(23,27);X(31,35);X(39,43);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(31,33);X(35,37);X(39,41);X(43,45);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);
median = p[24];
#else
#error Unsupported kernel size
#endif
color = vec4(median, median, median, 1.0f);
}`},4438:r=>{r.exports=`uniform sampler2D image;
uniform sampler2D illuminationMap;
uniform float gain;
uniform float offset;
uniform float decay;
#ifndef GREYSCALE
#error Must define GREYSCALE
#endif
#if GREYSCALE == 0
const mat3 rgb2yuv = mat3(
0.299f, -0.14713f, 0.615f,
0.587f, -0.28886f, -0.51499f,
0.114f, 0.436f, -0.10001f
);
const mat3 yuv2rgb = mat3(
1.0f, 1.0f, 1.0f,
0.0f, -0.39465f, 2.03211f,
1.13983f, -0.58060f, 0.0f
);
#endif
const float eps = 0.0001f;
const float sqrt2 = 1.4142135623730951f;
const float magic = 20.0f;
const vec2 center = vec2(0.5f);
void main()
{
vec4 pixel = threadPixel(image);
vec4 imapPixel = threadPixel(illuminationMap);
float lambda = -sqrt2 * log(max(1.0f - decay, eps));
float dist = length(texCoord - center);
float vgain = gain * exp(-lambda * dist);
float normalizedGain = 2.0f * vgain;
float normalizedOffset = 2.0f * offset - 1.0f;
#if GREYSCALE != 0
float luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));
luma = clamp(luma + normalizedOffset, 0.0f, 1.0f);
color = vec4(luma, luma, luma, 1.0f);
#else
vec3 yuvPixel = rgb2yuv * pixel.rgb;
vec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;
float luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));
luma += normalizedOffset;
vec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);
rgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);
color = vec4(rgbCorrectedPixel, 1.0f);
#endif
}`},5867:r=>{r.exports=`#ifndef GREYSCALE
#error Must define GREYSCALE
#endif
#if GREYSCALE != 0
uniform sampler2D minmax2d;
#else
uniform sampler2D minmax2dRGB[3];
#endif
uniform float minValue;
uniform float maxValue;
const float eps = 1.0f / 255.0f;
void main()
{
vec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;
vec4 newMin = vec4(minmax.x);
vec4 newRange = vec4(minmax.y - minmax.x);
vec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);
#if GREYSCALE != 0
vec4 pixel = threadPixel(minmax2d);
mat4 channel = mat4(pixel, pixel, pixel, alpha);
#else
mat4 channel = mat4(
threadPixel(minmax2dRGB[0]),
threadPixel(minmax2dRGB[1]),
threadPixel(minmax2dRGB[2]),
alpha
);
#endif
vec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);
vec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);
vec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);
vec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;
color = newIntensity;
}`},9252:r=>{r.exports=`const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);
uniform sampler2D image;
void main()
{
vec4 pixel = threadPixel(image);
float g = dot(pixel, grey);
color = vec4(g, g, g, 1.0f);
}`},8609:r=>{r.exports=`#ifndef _COLORS_GLSL
#define _COLORS_GLSL
#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@
#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@
#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@
#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@
#endif`},4672:r=>{r.exports=`#ifndef _FILTERS_GLSL
#define _FILTERS_GLSL
float laplacian(sampler2D pyramid, vec2 position, float lod)
{
float pot = exp2(lod);
ivec2 pyrBaseSize = textureSize(pyramid, 0);
const vec3 ones = vec3(1.0f);
const mat3 kernel = mat3(
0,-1, 0,
-1, 4,-1,
0,-1, 0
);
#define LPC(x,y) pyrSubpixelAtExOffset(pyramid, position, lod, pot, ivec2((x),(y)), pyrBaseSize).g
mat3 neighborhood = mat3(
0.0f, LPC(0,-1), 0.0f,
LPC(-1,0), LPC(0,0), LPC(1,0),
0.0f, LPC(0,1), 0.0f
);
mat3 m = matrixCompMult(neighborhood, kernel);
return dot(ones, vec3(
dot(m[0], ones),
dot(m[1], ones),
dot(m[2], ones)
)) * (1.0f + lod);
}
#endif`},9778:r=>{r.exports=`#ifndef _FIXEDPOINT_GLSL
#define _FIXEDPOINT_GLSL
#define fixed_t int
#define fixed2_t ivec2
const int FIX_BITS = int(@FIX_BITS@);
const float FIX_RESOLUTION = float(@FIX_RESOLUTION@);
#define itofix(x) fixed_t((x) << FIX_BITS)
#define fixtoi(f) int((x) >> FIX_BITS)
#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)
#define fixtof(f) (float(f) / FIX_RESOLUTION)
#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)
#define fixtoivec2(f) ivec2((f) >> FIX_BITS)
#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))
#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)
#endif`},8710:r=>{r.exports=`#ifndef _FLOAT16_GLSL
#define _FLOAT16_GLSL
#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)
#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))
#define encodePairOfFloat16(f) vec4(encodeFloat16((f).x), encodeFloat16((f).y))
#define decodePairOfFloat16(v) vec2(decodeFloat16((v).rg), decodeFloat16((v).ba))
#define encodeNullPairOfFloat16() vec4(1.0f)
#define isNullPairOfFloat16(v) all(equal((v), encodeNullPairOfFloat16()))
#define encodeDiscardedPairOfFloat16() vec4(0.0f, 1.0f, 0.0f, 1.0f)
#define isDiscardedPairOfFloat16(v) all(equal((v), encodeDiscardedPairOfFloat16()))
#define encodeFloat16NaN() vec2(0.5f, 1.0f)
#define isEncodedFloat16NaN(v) all(equal((v), encodeFloat16NaN()))
uvec2 packf16( float f)
{
uint y = packHalf2x16(vec2(f, 0.0f));
return uvec2(y, y >> 8u) & 0xFFu;
}
float unpackf16(uvec2 v)
{
v &= 0xFFu;
return unpackHalf2x16(v.x | (v.y << 8u)).x;
}
bool isEncodedFloat16Zero(vec2 v)
{
uvec2 w = uvec2(v * 255.0f);
return 0u == w.x + w.y * (0x80u - w.y);
}
#endif`},2434:r=>{r.exports=`#ifndef _GLOBAL_GLSL
#define _GLOBAL_GLSL
#define threadLocation() ivec2(texCoord * texSize)
#define outputSize() ivec2(texSize)
#define threadPixel(img) textureLod((img), texCoord, 0.0f)
#define pixelAt(img, pos) texelFetch((img), (pos), 0)
#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))
#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)
#endif`},439:r=>{r.exports=`#ifndef _INT32_GLSL
#define _INT32_GLSL
@include "platform.glsl"
uint decodeUint32(vec4 rgba)
{
uvec4 v = uvec4(rgba * 255.0f) & 255u;
return v.x | (v.y << 8u) | (v.z << 16u) | (v.w << 24u);
}
vec4 encodeUint32(uint value)
{
#if defined(APPLE_GPU) || (defined(APPLE) && defined(INTEL_GRAPHICS))
uvec4 v = uvec4(value, value / 256u, value / 65536u, value / 16777216u) % 256u;
return vec4(v) / 255.0f;
#else
uvec4 v = uvec4(value, value >> 8u, value >> 16u, value >> 24u) & 255u;
return vec4(v) / 255.0f;
#endif
}
#endif`},8545:r=>{r.exports=`#ifndef _KEYPOINT_DESCRIPTORS_GLSL
#define _KEYPOINT_DESCRIPTORS_GLSL
#if !defined(DESCRIPTOR_SIZE)
#error Must define DESCRIPTOR_SIZE
#elif !defined(_KEYPOINTS_GLSL)
#error Must include keypoints.glsl
#endif
uint[DESCRIPTOR_SIZE] readKeypointDescriptor(sampler2D encodedKeypoints, int descriptorSize, int extraSize, int encoderLength, KeypointAddress address)
{
int descriptorOffset = sizeofEncodedKeypoint(0, extraSize) / 4;
KeypointAddress descriptorAddress = KeypointAddress(address.base, descriptorOffset);
uint[DESCRIPTOR_SIZE] descriptor;
vec4 pixel; uvec4 bytes;
@unroll
for(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {
pixel = readKeypointData(encodedKeypoints, encoderLength, descriptorAddress);
bytes = uvec4(pixel * 255.0f);
descriptor[i]   = bytes.r;
descriptor[i+1] = bytes.g;
descriptor[i+2] = bytes.b;
descriptor[i+3] = bytes.a;
descriptorAddress.offset++;
}
return descriptor;
}
uint[DESCRIPTOR_SIZE] readKeypointDescriptorFromDB(sampler2D descriptorDB, int descriptorDBStride, int index)
{
uint[DESCRIPTOR_SIZE] descriptor;
int rasterIndex = index * (DESCRIPTOR_SIZE / 4) * int(index >= 0);
vec4 pixel; uvec4 bytes; ivec2 pos;
@unroll
for(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {
pos = ivec2(rasterIndex % descriptorDBStride, rasterIndex / descriptorDBStride);
pixel = (index >= 0) ? texelFetch(descriptorDB, pos, 0) : vec4(0.0f);
bytes = uvec4(pixel * 255.0f);
descriptor[i]   = bytes.r;
descriptor[i+1] = bytes.g;
descriptor[i+2] = bytes.b;
descriptor[i+3] = bytes.a;
rasterIndex++;
}
return descriptor;
}
int distanceBetweenKeypointDescriptors(uint[DESCRIPTOR_SIZE] a, uint[DESCRIPTOR_SIZE] b)
{
const int[256] POPCNT = int[256](0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8);
uvec4 xor, u, v;
int dist = 0;
ivec4 bits;
@unroll
for(int i = 0; i < DESCRIPTOR_SIZE; i += 4) {
u = uvec4(a[i], a[i+1], a[i+2], a[i+3]);
v = uvec4(b[i], b[i+1], b[i+2], b[i+3]);
xor = (u ^ v) & 255u;
bits = ivec4(POPCNT[xor.x], POPCNT[xor.y], POPCNT[xor.z], POPCNT[xor.w]);
dist += bits.x + bits.y + bits.z + bits.w;
}
return dist;
}
#endif`},6762:r=>{r.exports=`#ifndef _KEYPOINT_MATCHES_GLSL
#define _KEYPOINT_MATCHES_GLSL
@include "int32.glsl"
const int MATCH_INDEX_BITS = int(@MATCH_INDEX_BITS@);
const int MATCH_INDEX_MASK = int(@MATCH_INDEX_MASK@);
const int MATCH_MAX_INDEX = int(@MATCH_MAX_INDEX@);
const int MATCH_MAX_DISTANCE = int(@MATCH_MAX_DISTANCE@);
struct KeypointMatch
{
int index;
int dist;
};
vec4 encodeKeypointMatch(KeypointMatch candidate)
{
uint index = uint(candidate.index) & uint(MATCH_INDEX_MASK);
uint dist = uint(clamp(candidate.dist, 0, MATCH_MAX_DISTANCE));
uint u32 = index | (dist << MATCH_INDEX_BITS);
return encodeUint32(u32);
}
KeypointMatch decodeKeypointMatch(vec4 rgba)
{
uint u32 = decodeUint32(rgba);
int dist = int(u32 >> MATCH_INDEX_BITS);
int index = int(u32 & uint(MATCH_INDEX_MASK));
return KeypointMatch(index, dist);
}
const KeypointMatch MATCH_NOT_FOUND = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);
#endif`},7639:r=>{r.exports=`#ifndef _KEYPOINTS_GLSL
#define _KEYPOINTS_GLSL
@include "math.glsl"
@include "fixed-point.glsl"
@include "float16.glsl"
@include "pyramids.glsl"
struct Keypoint
{
vec2 position;
float lod;
float orientation;
float score;
uint flags;
};
struct KeypointAddress
{
int base;
int offset;
};
const int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);
const int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);
const uint KPF_NONE = 0u;
const uint KPF_NULL = 1u;
const uint KPF_DISCARDED = 2u;
#define encodeKeypointScore(score) encodeFloat16(score)
#define decodeKeypointScore(encodedScore) decodeFloat16(encodedScore)
#define encodeKeypointOrientation(angle) ((angle) * INV_PI_OVER_2 + 0.5f)
#define decodeKeypointOrientation(value) ((value) * TWO_PI - PI)
#define encodeNullKeypoint() (vec4(1.0f))
#define encodeDiscardedKeypoint() (vec4(0.0f))
#define isNullKeypoint(keypoint) ((((keypoint).flags) & KPF_NULL) != 0u)
#define isDiscardedKeypoint(keypoint) ((((keypoint).flags) & KPF_DISCARDED) != 0u)
#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)
#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))
#define sizeofEncodedKeypointHeader() sizeofEncodedKeypoint(0,0)
#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))
vec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)
{
int rasterIndex = address.base + address.offset;
vec4 data = pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));
return rasterIndex < encoderLength * encoderLength ? data : encodeNullKeypoint();
}
KeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)
{
int threadRaster = thread.y * encoderLength + thread.x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
int keypointIndex = int(threadRaster / pixelsPerKeypoint);
KeypointAddress address = KeypointAddress(
keypointIndex * pixelsPerKeypoint,
threadRaster % pixelsPerKeypoint
);
return address;
}
Keypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)
{
Keypoint keypoint;
KeypointAddress positionAddress = KeypointAddress(address.base, 0);
KeypointAddress propertiesAddress = KeypointAddress(address.base, 1);
vec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);
ivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);
keypoint.position = fixtovec2(fixed2_t(
encodedPosition.r | (encodedPosition.g << 8),
encodedPosition.b | (encodedPosition.a << 8)
));
vec4 rawEncodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);
keypoint.lod = decodeLod(rawEncodedProperties.r);
keypoint.orientation = decodeKeypointOrientation(rawEncodedProperties.g);
keypoint.score = decodeKeypointScore(rawEncodedProperties.ba);
bool isNull = all(equal(rawEncodedPosition, vec4(1)));
bool isDiscarded = all(equal(rawEncodedPosition + rawEncodedProperties, vec4(0)));
keypoint.score = (isNull || isDiscarded) ? -1.0f : keypoint.score;
keypoint.flags = KPF_NONE;
keypoint.flags |= KPF_NULL * uint(isNull);
keypoint.flags |= KPF_DISCARDED * uint(isDiscarded);
return keypoint;
}
vec4 encodeKeypointPosition(vec2 position)
{
const vec2 zeros = vec2(0.0f);
fixed2_t pos = vec2tofix(max(position, zeros));
fixed2_t lo = pos & 255;
fixed2_t hi = (pos >> 8) & 255;
return vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;
}
#endif`},431:r=>{r.exports=`#ifndef _MATH_GLSL
#define _MATH_GLSL
#define TWO_PI          6.28318530718f
#define PI              3.14159265359f
#define PI_OVER_2       1.57079632679f
#define PI_OVER_4       0.78539816339f
#define INV_PI          0.3183098861837907f
#define INV_PI_OVER_2   0.15915494309189535f
const highp float INFINITY = 1.0f / 0.0f;
float fastAtan(float x)
{
float w = 1.0f - abs(x);
return (w >= 0.0f) ? ((PI_OVER_4 + 0.273f * w) * x) :
(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x);
}
float fastAtan2(float y, float x)
{
return (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);
}
#endif`},6822:r=>{r.exports=`#ifndef _PLATFORM_GLSL
#define _PLATFORM_GLSL
#if @APPLE@
#define APPLE 1
#endif
#if @APPLE_GPU@
#define APPLE_GPU 1
#endif
#if @INTEL_GRAPHICS@
#define INTEL_GRAPHICS 1
#endif
#endif`},2728:r=>{r.exports=`#ifndef _PYRAMIDS_GLSL
#define _PYRAMIDS_GLSL
#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))
#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))
#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))
#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))
#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))
#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))
const int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);
const float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);
const float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);
#define encodeLod(lod) ((LOG2_PYRAMID_MAX_SCALE + (lod)) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS))
float decodeLod(float encodedLod)
{
float lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;
return lod - lod * step(1.0f, encodedLod);
}
#define LOD_EPS 0.0625f
const float ENCODED_LOD_EPS = (LOD_EPS / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS));
#define isSameLod(lod1, lod2) (abs((lod1) - (lod2)) < LOD_EPS)
#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < ENCODED_LOD_EPS)
#endif`},6823:r=>{r.exports=`#ifndef _SUBPIXEL_GLSL
#define _SUBPIXEL_GLSL
#define subpixelAt(image, pos) textureLod((image), ((pos) + vec2(0.5f)) / texSize, 0.0f)
vec4 subpixelAtBI(sampler2D image, vec2 pos)
{
vec2 frc = fract(pos);
vec2 ifrc = vec2(1.0f) - frc;
vec2 p = (floor(pos) + vec2(0.5f)) / vec2(textureSize(image, 0));
vec4 pix00 = textureLod(image, p, 0.0f);
vec4 pix10 = textureLodOffset(image, p, 0.0f, ivec2(1,0));
vec4 pix01 = textureLodOffset(image, p, 0.0f, ivec2(0,1));
vec4 pix11 = textureLodOffset(image, p, 0.0f, ivec2(1,1));
mat4 pix = mat4(pix00, pix10, pix01, pix11);
vec4 mul = vec4(ifrc.x * ifrc.y, frc.x * ifrc.y, ifrc.x * frc.y, frc.x * frc.y);
return pix * mul;
}
#endif`},1341:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D inputEncodedKeypoints;
uniform int inputDescriptorSize;
uniform int inputExtraSize;
uniform int inputEncoderLength;
uniform int outputDescriptorSize;
uniform int outputExtraSize;
uniform int outputEncoderLength;
const vec4 EMPTY_DESCRIPTOR = vec4(0.0f);
void main()
{
ivec2 thread = threadLocation();
KeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);
int myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);
int headerSize = sizeofEncodedKeypointHeader();
bool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);
int addressOffset = myAddress.offset;
int pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;
KeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);
color = isDescriptor ? EMPTY_DESCRIPTOR : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);
}`},7833:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D inputEncodedKeypoints;
uniform int inputDescriptorSize;
uniform int inputExtraSize;
uniform int inputEncoderLength;
uniform int outputDescriptorSize;
uniform int outputExtraSize;
uniform int outputEncoderLength;
void main()
{
ivec2 thread = threadLocation();
KeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);
int myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);
int headerSize = sizeofEncodedKeypointHeader();
bool isHead = (myAddress.offset < headerSize / 4);
bool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);
bool isExtra = (!isHead && !isDescriptor);
int numberOfExtraPixels = outputExtraSize / 4;
int addressOffset = myAddress.offset - int(isDescriptor) * numberOfExtraPixels;
int pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;
KeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);
color = isExtra ? vec4(0.0f) : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);
}`},2352:r=>{r.exports=`@include "keypoints.glsl"
uniform mat3 homography;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
color = pixel;
if(address.offset != 0)
return;
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
if(isBadKeypoint(keypoint))
return;
vec3 pos3 = homography * vec3(keypoint.position, 1.0f);
color = encodeKeypointPosition(pos3.xy / pos3.z);
}`},7541:r=>{r.exports=`@include "keypoints.glsl"
@include "keypoint-descriptors.glsl"
@include "keypoint-matches.glsl"
uniform sampler2D encodedMatches;
uniform sampler2D encodedFilters;
uniform int matcherLength;
uniform sampler2D dbEncodedKeypoints;
uniform int dbDescriptorSize;
uniform int dbExtraSize;
uniform int dbEncoderLength;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int passId;
#ifndef NUMBER_OF_KEYPOINTS_PER_PASS
#error Undefined NUMBER_OF_KEYPOINTS_PER_PASS
#endif
const int INFINITE_DISTANCE = MATCH_MAX_DISTANCE + 1;
void main()
{
ivec2 thread = threadLocation();
int keypointIndex = thread.x + thread.y * matcherLength;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
color = encodeKeypointMatch(MATCH_NOT_FOUND);
if(isBadKeypoint(keypoint))
return;
KeypointMatch bestMatch = decodeKeypointMatch(threadPixel(encodedMatches));
KeypointMatch filterMatch = decodeKeypointMatch(threadPixel(encodedFilters));
uint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);
uint[DESCRIPTOR_SIZE] dbDescriptor;
int dbPixelsPerKeypoint = sizeofEncodedKeypoint(dbDescriptorSize, dbExtraSize) / 4;
for(int i = 0; i < NUMBER_OF_KEYPOINTS_PER_PASS; i++) {
int dbKeypointIndex = passId * NUMBER_OF_KEYPOINTS_PER_PASS + i;
KeypointAddress dbAddress = KeypointAddress(dbKeypointIndex * dbPixelsPerKeypoint, 0);
Keypoint dbKeypoint = decodeKeypoint(dbEncodedKeypoints, dbEncoderLength, dbAddress);
dbDescriptor = readKeypointDescriptor(dbEncodedKeypoints, dbDescriptorSize, dbExtraSize, dbEncoderLength, dbAddress);
int dist = !isBadKeypoint(dbKeypoint) ? distanceBetweenKeypointDescriptors(descriptor, dbDescriptor) : INFINITE_DISTANCE;
bestMatch.index = all(bvec2(
dist < bestMatch.dist || (dist == bestMatch.dist && dbKeypointIndex > bestMatch.index),
dist > filterMatch.dist || (dist == filterMatch.dist && dbKeypointIndex < filterMatch.index)
)) ? dbKeypointIndex : bestMatch.index;
bestMatch.dist = dbKeypointIndex == bestMatch.index ? dist : bestMatch.dist;
}
color = encodeKeypointMatch(bestMatch);
}`},4868:r=>{r.exports=`@include "keypoints.glsl"
uniform int imageWidth;
uniform int imageHeight;
uniform int borderTop;
uniform int borderRight;
uniform int borderBottom;
uniform int borderLeft;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
ivec2 thread = threadLocation();
KeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);
vec2 p = keypoint.position;
bool withinBorder = any(lessThan(
vec4(p.x, p.y, -p.x, -p.y),
vec4(borderLeft, borderTop, borderRight - (imageWidth - 1), borderBottom - (imageHeight - 1))
));
vec4 pixel = threadPixel(encodedKeypoints);
vec4 nullPixel = encodeNullKeypoint();
color = withinBorder ? nullPixel : pixel;
}`},5591:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int maxKeypoints;
void main()
{
ivec2 thread = threadLocation();
int newEncoderLength = outputSize().x;
KeypointAddress address = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
vec4 pixel = readKeypointData(encodedKeypoints, encoderLength, address);
color = index < maxKeypoints ? pixel : encodeNullKeypoint();
}`},191:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedKeypointsA;
uniform int encoderLengthA;
uniform sampler2D encodedKeypointsB;
uniform int encoderLengthB;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform float threshold;
void main()
{
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
vec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);
color = data;
if(address.offset >= sizeofEncodedKeypointHeader() / 4)
return;
Keypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);
Keypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);
color = encodeNullKeypoint();
if(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))
return;
color = encodeDiscardedKeypoint();
if(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))
return;
color = encodeDiscardedKeypoint();
if(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))
return;
vec2 delta = keypointA.position - keypointB.position;
bool shouldKeep = (dot(delta, delta) <= threshold * threshold);
color = shouldKeep ? data : encodeDiscardedKeypoint();
}`},5467:r=>{r.exports=`@include "float16.glsl"
uniform sampler2D offsetsImage;
uniform ivec2 imageSize;
#ifndef MAX_ITERATIONS
#error Undefined MAX_ITERATIONS
#endif
#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))
#define encodeSkipOffset(offset) (vec2((offset) & 255, (offset) >> 8) / 255.0f)
void main()
{
vec4 pixel = threadPixel(offsetsImage);
ivec2 thread = threadLocation();
int rasterIndex = thread.y * imageSize.x + thread.x;
int offset = decodeSkipOffset(pixel);
int totalOffset = offset;
vec2 encodedScore = pixel.rb;
ivec2 pos = thread; int allow = 1;
@unroll
for(int i = 0; i < MAX_ITERATIONS; i++) {
allow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb));
rasterIndex += allow * offset;
pos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);
pixel = pixelAt(offsetsImage, pos);
offset = decodeSkipOffset(pixel);
totalOffset += allow * offset;
}
totalOffset = min(totalOffset, 65535);
color.rb = encodedScore;
color.ga = encodeSkipOffset(totalOffset);
}`},336:r=>{r.exports=`@include "float16.glsl"
uniform sampler2D corners;
uniform ivec2 imageSize;
void main()
{
vec4 pixel = threadPixel(corners);
ivec2 pos = threadLocation();
vec2 encodedScore = pixel.rb;
int offset = 0, allow = 1, jumped = 0;
#define READ(j) ; \\
allow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb)); \\
offset += allow; \\
pos.x = (pos.x + 1) % imageSize.x; \\
pos.y += int(pos.x == 0); \\
pixel = (0 != (jumped |= int(pos.x == 0))) ? pixelAtShortOffset(corners, ivec2((j),1)) : pixelAtShortOffset(corners, ivec2((j),0))
READ(1); READ(2); READ(3); READ(4); READ(5); READ(6); READ(7);
color.rb = encodedScore;
color.ga = vec2(offset, 0) / 255.0f;
}`},8968:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D offsetsImage;
uniform ivec2 imageSize;
uniform int passId;
uniform int numPasses;
uniform int keypointLimit;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))
bool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)
{
int notFirstPass = int(passId > 0);
position *= notFirstPass;
p |= -(1 - notFirstPass);
p -= notFirstPass;
int rasterIndex = position.y * imageSize.x + position.x;
while(position.y < imageSize.y && p != q) {
position = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);
pixel = texelFetch(offsetsImage, position, 0);
p += int(!isEncodedFloat16Zero(pixel.rb));
rasterIndex += max(1, decodeSkipOffset(pixel));
}
return (p == q);
}
void main()
{
ivec2 thread = threadLocation();
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int q = findKeypointIndex(address, descriptorSize, extraSize);
color = vec4(0.0f);
if(address.offset != 0)
return;
color = threadPixel(encodedKeypoints);
int numPixels = encoderLength * encoderLength;
int maxKeypoints = numPixels / pixelsPerKeypoint;
int maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);
int targetPassId = q / maxKeypointsPerPass;
if(passId != targetPassId)
return;
int lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;
KeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);
Keypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);
ivec2 position = passId > 0 ? ivec2(lastKeypointFromPrevPass.position) : ivec2(0);
vec4 pixel;
color = encodeNullKeypoint();
if(q >= min(maxKeypoints, keypointLimit) || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))
return;
color = encodeKeypointPosition(vec2(position));
}`},1733:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D corners;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(encodedKeypoints);
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int q = findKeypointIndex(address, descriptorSize, extraSize);
color = pixel;
if(address.offset != 1)
return;
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
vec4 kpix = pixelAt(corners, ivec2(keypoint.position));
keypoint.score = decodeFloat16(kpix.rb);
color.r = kpix.a;
color.g = encodeKeypointOrientation(0.0f);
color.ba = encodeKeypointScore(keypoint.score);
}`},9674:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D corners;
uniform mediump usampler2D lookupTable;
uniform int stride;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int encoderCapacity;
const uvec2 NULL_ELEMENT = uvec2(0xFFFFu);
void main()
{
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
ivec2 pos = ivec2(index % stride, index / stride);
uvec4 entry = texelFetch(lookupTable, pos, 0);
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
int rasterIndex = address.base + address.offset;
int numberOfPixels = encoderLength * encoderLength;
int numberOfValidPixels = numberOfPixels - (numberOfPixels % pixelsPerKeypoint);
int maxEncoderCapacity = numberOfValidPixels / pixelsPerKeypoint;
color = encodeNullKeypoint();
if(all(equal(entry.xy, NULL_ELEMENT)) || index >= min(encoderCapacity, maxEncoderCapacity))
return;
color = encodeKeypointPosition(vec2(entry.xy));
if(address.offset == 0)
return;
color = vec4(0.0f);
if(address.offset >= sizeofEncodedKeypointHeader() / 4)
return;
vec4 pixel = texelFetch(corners, ivec2(entry.xy), 0);
vec2 encodedScore = encodeKeypointScore(decodeFloat16(pixel.rb));
float encodedOrientation = encodeKeypointOrientation(0.0f);
float encodedLod = pixel.a;
color = vec4(encodedLod, encodedOrientation, encodedScore);
}`},2090:r=>{r.exports=`@include "keypoints.glsl"
void main()
{
color = encodeNullKeypoint();
}`},1855:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
uniform sampler2D corners;
uniform sampler2D pyramid;
uniform float lod;
uniform int threshold;
#define USE_VARYINGS 1
#if !defined(FAST_TYPE)
#error Undefined FAST_TYPE
#elif FAST_TYPE == 916
in vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,
v_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;
#else
#error Invalid FAST_TYPE
#endif
#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g
#define XIP(v) textureLod(pyramid, (v), lod).g
void main()
{
float pixel = threadPixel(pyramid).g;
vec4 prev = threadPixel(corners);
ivec2 thread = threadLocation();
ivec2 size = outputSize();
float pot = exp2(lod);
float t = float(clamp(threshold, 0, 255)) / 255.0f;
float ct = pixel + t, c_t = pixel - t;
color = vec4(prev.r, pixel, prev.ba);
#if FAST_TYPE == 916
const ivec4 margin = ivec4(3, 3, 4, 4);
if(any(lessThan(ivec4(thread, size - thread), margin)))
return;
#if USE_VARYINGS
float p0 = XIP(v_pix0), p4 = XIP(v_pix4), p8 = XIP(v_pix8), p12 = XIP(v_pix12);
#else
float p0 = PIX(0,3), p4 = PIX(3,0), p8 = PIX(0,-3), p12 = PIX(-3,0);
#endif
bvec4 brighter = bvec4(p0 > ct, p4 > ct, p8 > ct, p12 > ct);
bvec4 darker = bvec4(p0 < c_t, p4 < c_t, p8 < c_t, p12 < c_t);
bvec4 bpairs = bvec4(all(brighter.xy), all(brighter.yz), all(brighter.zw), all(brighter.wx));
bvec4 dpairs = bvec4(all(darker.xy), all(darker.yz), all(darker.zw), all(darker.wx));
if(!(any(bpairs) || any(dpairs)))
return;
#if USE_VARYINGS
float p1 = XIP(v_pix1), p2 = XIP(v_pix2), p3 = XIP(v_pix3),
p5 = XIP(v_pix5), p6 = XIP(v_pix6), p7 = XIP(v_pix7),
p9 = XIP(v_pix9), p10 = XIP(v_pix10), p11 = XIP(v_pix11),
p13 = XIP(v_pix13), p14 = XIP(v_pix14), p15 = XIP(v_pix15);
#else
float p1 = PIX(1,3), p2 = PIX(2,2), p3 = PIX(3,1),
p5 = PIX(3,-1), p6 = PIX(2,-2), p7 = PIX(1,-3),
p9 = PIX(-1,-3), p10 = PIX(-2,-2), p11 = PIX(-3,-1),
p13 = PIX(-3,1), p14 = PIX(-2,2), p15 = PIX(-1,3);
#endif
bool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);
bool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));
if(!isCorner)
return;
mat4 mp = mat4(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);
mat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);
mat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;
const vec4 zeros = vec4(0.0f), ones = vec4(1.0f);
vec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);
bs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);
bs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);
bs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);
float thisScore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;
float prevScore = decodeFloat16(prev.rb);
vec3 thisResult = vec3(encodeFloat16(thisScore), encodeLod(lod));
color.rba = thisScore > prevScore ? thisResult : color.rba;
#endif
}`},4824:r=>{r.exports=`uniform mediump float lod;
#if !defined(FAST_TYPE)
#error Undefined FAST_TYPE
#elif FAST_TYPE == 916
out vec2 v_pix0, v_pix1, v_pix2, v_pix3, v_pix4, v_pix5, v_pix6, v_pix7,
v_pix8, v_pix9, v_pix10,v_pix11,v_pix12,v_pix13,v_pix14,v_pix15;
#else
#error Invalid FAST_TYPE
#endif
#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)
void vsmain()
{
float pot = exp2(lod);
#if FAST_TYPE == 916
v_pix0 = PIX(0,3); v_pix1 = PIX(1,3), v_pix2 = PIX(2,2), v_pix3 = PIX(3,1);
v_pix4 = PIX(3,0); v_pix5 = PIX(3,-1), v_pix6 = PIX(2,-2), v_pix7 = PIX(1,-3);
v_pix8 = PIX(0,-3); v_pix9 = PIX(-1,-3), v_pix10 = PIX(-2,-2), v_pix11 = PIX(-3,-1);
v_pix12 = PIX(-3,0); v_pix13 = PIX(-3,1), v_pix14 = PIX(-2,2), v_pix15 = PIX(-1,3);
#endif
}`},2381:r=>{r.exports=`@include "keypoints.glsl"
@include "keypoint-descriptors.glsl"
uniform sampler2D encodedKeypointsA;
uniform int encoderLengthA;
uniform sampler2D encodedKeypointsB;
uniform int encoderLengthB;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int threshold;
void main()
{
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
vec4 data = readKeypointData(encodedKeypointsA, encoderLengthA, address);
color = data;
if(address.offset >= sizeofEncodedKeypointHeader() / 4)
return;
Keypoint keypointA = decodeKeypoint(encodedKeypointsA, encoderLengthA, address);
Keypoint keypointB = decodeKeypoint(encodedKeypointsB, encoderLengthB, address);
color = encodeNullKeypoint();
if(isNullKeypoint(keypointA) && isNullKeypoint(keypointB))
return;
color = encodeDiscardedKeypoint();
if(isDiscardedKeypoint(keypointA) || isDiscardedKeypoint(keypointB))
return;
color = encodeDiscardedKeypoint();
if(isNullKeypoint(keypointA) || isNullKeypoint(keypointB))
return;
uint[DESCRIPTOR_SIZE] descriptorA, descriptorB;
descriptorA = readKeypointDescriptor(encodedKeypointsA, descriptorSize, extraSize, encoderLengthA, address);
descriptorB = readKeypointDescriptor(encodedKeypointsB, descriptorSize, extraSize, encoderLengthB, address);
int dist = distanceBetweenKeypointDescriptors(descriptorA, descriptorB);
bool shouldKeep = (dist <= threshold);
color = shouldKeep ? data : encodeDiscardedKeypoint();
}`},6060:r=>{r.exports=`@include "float16.glsl"
uniform sampler2D corners;
uniform sampler2D maxScore;
uniform float quality;
void main()
{
vec4 pixel = threadPixel(corners);
float score = decodeFloat16(pixel.rb);
float maxval = decodeFloat16(threadPixel(maxScore).rb);
float threshold = maxval * clamp(quality, 0.0f, 1.0f);
color = pixel;
color.rb = score >= threshold ? color.rb : encodeFloat16(0.0f);
}`},9974:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
@include "filters.glsl"
#if !defined(WINDOW_SIZE)
#error Undefined WINDOW_SIZE
#endif
#define WINDOW_RADIUS ((WINDOW_SIZE - 1) / 2)
uniform sampler2D corners;
uniform sampler2D pyramid;
uniform sampler2D derivatives;
uniform float lod;
uniform float lodStep;
uniform float gaussian[@WINDOW_SIZE@];
#define G(x) gaussian[(x) + WINDOW_RADIUS]
#define W(x,y) (G(x) * G(y))
#define H(ox,oy) dpix = pixelAtShortOffset(derivatives, ivec2((ox),(oy))); \\
df = (1.0f + lod) * decodePairOfFloat16(dpix); \\
h += vec3(df.x * df.x, df.x * df.y, df.y * df.y) * W((ox),(oy))
void main()
{
float intensity = 0.0f;
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(corners);
vec4 dpix = vec4(0.0f);
vec2 df = vec2(0.0f);
vec3 h = vec3(0.0f);
color = pixel;
#if WINDOW_SIZE == 1
H(0,0);
#elif WINDOW_SIZE == 3
H(-1,-1); H(0,-1); H(1,-1);
H(-1,0); H(0,0); H(1,0);
H(-1,1); H(0,1); H(1,1);
#elif WINDOW_SIZE == 5
H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2);
H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1);
H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0);
H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1);
H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2);
#elif WINDOW_SIZE == 7
H(-3,-3); H(-2,-3); H(-1,-3); H(0,-3); H(1,-3); H(2,-3); H(3,-3);
H(-3,-2); H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2); H(3,-2);
H(-3,-1); H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1); H(3,-1);
H(-3,0); H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0); H(3,0);
H(-3,1); H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1); H(3,1);
H(-3,2); H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2); H(3,2);
H(-3,3); H(-2,3); H(-1,3); H(0,3); H(1,3); H(2,3); H(3,3);
#else
#error Invalid WINDOW_SIZE
#endif
float response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));
response /= float(WINDOW_SIZE * WINDOW_SIZE);
float lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep);
float currentScaleStrength = abs(laplacian(pyramid, vec2(thread), lod));
float previousScaleStrength = abs(laplacian(pyramid, vec2(thread), lodPlus));
float previousResponse = decodeFloat16(pixel.rb);
vec4 result = vec4(encodeFloat16(response), encodeLod(lod), intensity);
color.rbag = (currentScaleStrength >= previousScaleStrength || previousResponse == 0.0f) ? result : pixel.rbag;
}`},3047:r=>{r.exports=`@include "keypoint-matches.glsl"
void main()
{
#if ENCODE_FILTERS != 0
KeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, 0);
#else
KeypointMatch initial = KeypointMatch(MATCH_MAX_INDEX, MATCH_MAX_DISTANCE);
#endif
color = encodeKeypointMatch(initial);
}`},3266:r=>{r.exports=`@include "keypoint-matches.glsl"
uniform sampler2D encodedMatches;
uniform sampler2D encodedKthMatches;
uniform int numberOfMatchesPerKeypoint;
uniform int kthMatch;
void main()
{
ivec2 thread = threadLocation();
ivec2 matcherSize = textureSize(encodedMatches, 0);
ivec2 kthMatcherSize = textureSize(encodedKthMatches, 0);
int rasterIndex = thread.y * matcherSize.x + thread.x;
int matchIndex = rasterIndex / numberOfMatchesPerKeypoint;
int matchCell = rasterIndex % numberOfMatchesPerKeypoint;
color = threadPixel(encodedMatches);
if(matchCell != kthMatch)
return;
color = encodeKeypointMatch(MATCH_NOT_FOUND);
if(matchIndex >= kthMatcherSize.x * kthMatcherSize.y)
return;
ivec2 pos = ivec2(matchIndex % kthMatcherSize.x, matchIndex / kthMatcherSize.x);
color = texelFetch(encodedKthMatches, pos, 0);
}`},8018:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
@include "filters.glsl"
uniform sampler2D corners;
uniform sampler2D pyramid;
uniform float lodStep;
uniform float lodOffset;
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(corners);
float lod = decodeLod(pixel.a);
float lodMinus = max(0.0f, lod - lodStep + lodOffset);
float lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep + lodOffset);
float lapMinus = laplacian(pyramid, vec2(thread), lodMinus);
float lapPlus = abs(lodPlus - lodMinus) < 1e-5 ? lapMinus : laplacian(pyramid, vec2(thread), lodPlus);
color = encodePairOfFloat16(vec2(lapMinus, lapPlus));
}`},3168:r=>{r.exports=`@include "keypoints.glsl"
@include "float16.glsl"
uniform sampler2D nextPyramid;
uniform sampler2D prevPyramid;
uniform sampler2D encodedFlow;
uniform sampler2D prevKeypoints;
uniform int level;
uniform int depth;
uniform int numberOfIterations;
uniform float discardThreshold;
uniform float epsilon;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#ifndef WINDOW_SIZE
#error Undefined WINDOW_SIZE
#endif
#define NEXT_IMAGE 1
#define PREV_IMAGE 0
const int WINDOW_RADIUS = (WINDOW_SIZE - 1) / 2;
const int WINDOW_SIZE_SQUARED = (WINDOW_SIZE) * (WINDOW_SIZE);
const int WINDOW_SIZE_PLUS = (WINDOW_SIZE) + 2;
const int WINDOW_SIZE_PLUS_SQUARED = WINDOW_SIZE_PLUS * WINDOW_SIZE_PLUS;
const int DBL_WINDOW_SIZE_PLUS_SQUARED = 2 * WINDOW_SIZE_PLUS_SQUARED;
const int WINDOW_RADIUS_PLUS = (WINDOW_SIZE_PLUS - 1) / 2;
const highp float FLT_SCALE = 9.5367431640625e-7;
const highp float FLT_EPSILON = 0.00000011920929f;
int pixelBuffer[DBL_WINDOW_SIZE_PLUS_SQUARED];
#define prevPixel(index) pixelBuffer[(index)]
#define nextPixel(index) pixelBuffer[WINDOW_SIZE_PLUS_SQUARED + (index)]
#define pixelIndex(i, j) (((j) + WINDOW_RADIUS_PLUS) * WINDOW_SIZE_PLUS + ((i) + WINDOW_RADIUS_PLUS))
ivec2 derivBuffer[WINDOW_SIZE_SQUARED];
#define derivativesAt(x, y) derivBuffer[((y) + WINDOW_RADIUS) * WINDOW_SIZE + ((x) + WINDOW_RADIUS)]
void readWindow(vec2 center, float lod)
{
const int r = WINDOW_RADIUS;
ivec2 pyrBaseSize = textureSize(prevPyramid, 0);
float pot = exp2(lod);
ivec2 offset; int idx;
#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); \\
idx = pixelIndex(offset.x, offset.y); \\
nextPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g); \\
prevPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g)
for(int j = 0; j < WINDOW_SIZE; j++) {
for(int i = 0; i < WINDOW_SIZE; i++) {
readPixelsAt(i-r, j-r);
}
}
int r1 = r+1;
for(int k = 0; k < WINDOW_SIZE; k++) {
readPixelsAt(-r1, k-r);
readPixelsAt( r1, k-r);
readPixelsAt(k-r,-r1);
readPixelsAt(k-r, r1);
}
readPixelsAt(-r1,-r1);
readPixelsAt( r1,-r1);
readPixelsAt(-r1, r1);
readPixelsAt( r1, r1);
}
ivec2 computeDerivatives(int imageCode, ivec2 offset)
{
const mat3 dx = mat3(
3, 0, -3,
10, 0, -10,
3, 0, -3
);
const mat3 dy = mat3(
3, 10, 3,
0, 0, 0,
-3, -10, -3
);
int indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;
mat3 window = mat3(
pixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],
pixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],
pixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],
pixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],
0.0f,
pixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],
pixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],
pixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],
pixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]
);
mat3 fx = matrixCompMult(dx, window);
mat3 fy = matrixCompMult(dy, window);
const vec3 ones = vec3(1.0f);
return ivec2(
dot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),
dot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)
);
}
int readBufferedPixel(int imageCode, ivec2 offset)
{
const int r = WINDOW_RADIUS;
offset = clamp(offset, -r, r);
int indexOffset = imageCode * WINDOW_SIZE_PLUS_SQUARED;
return pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];
}
int readBufferedSubpixel(int imageCode, vec2 offset)
{
ivec2 p = ivec2(floor(offset));
vec2 frc = fract(offset);
vec2 ifrc = vec2(1.0f) - frc;
vec4 pix = vec4(
readBufferedPixel(imageCode, p),
readBufferedPixel(imageCode, p + ivec2(1,0)),
readBufferedPixel(imageCode, p + ivec2(0,1)),
readBufferedPixel(imageCode, p + ivec2(1,1))
);
vec4 sub = vec4(
ifrc.x * ifrc.y,
frc.x * ifrc.y,
ifrc.x * frc.y,
frc.x * frc.y
);
return int(0.5f + dot(sub*pix, vec4(1.0f)));
}
vec2 computeMismatch(vec2 pyrGuess, vec2 localGuess)
{
const int r = WINDOW_RADIUS;
int timeDerivative;
ivec2 mismatch = ivec2(0);
int x, y, _x, _y;
vec2 d = pyrGuess + localGuess;
#define innerLoop() \\
for(_x = 0; _x < WINDOW_SIZE; _x++) { \\
x = _x - r; y = _y - r; \\
timeDerivative = ( \\
readBufferedSubpixel(NEXT_IMAGE, vec2(x, y) + d) - \\
readBufferedPixel(PREV_IMAGE, ivec2(x, y)) \\
); \\
mismatch += derivativesAt(x, y) * timeDerivative; \\
}
@unroll
for(_y = 0; _y < WINDOW_SIZE; _y++) {
innerLoop();
}
return vec2(mismatch) * FLT_SCALE;
}
bool isInsideImage(vec2 position)
{
vec2 imageSize = vec2(textureSize(nextPyramid, 0));
vec2 border = vec2(WINDOW_SIZE);
return all(bvec4(
greaterThanEqual(position, border),
lessThan(position, imageSize - border)
));
}
void main()
{
vec4 pixel = threadPixel(encodedFlow);
ivec2 thread = threadLocation();
float windowArea = float(WINDOW_SIZE * WINDOW_SIZE);
const int r = WINDOW_RADIUS;
int keypointIndex = thread.x + thread.y * outputSize().x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);
color = encodeNullPairOfFloat16();
if(isNullKeypoint(keypoint))
return;
color = encodeDiscardedPairOfFloat16();
if(isBadKeypoint(keypoint))
return;
vec2 pyrGuess = (level < depth - 1) ? decodePairOfFloat16(pixel) : vec2(0.0f);
pyrGuess *= 2.0f;
readWindow(keypoint.position, float(level));
ivec2 derivatives;
ivec3 harris3i = ivec3(0);
for(int j = 0; j < WINDOW_SIZE; j++) {
for(int i = 0; i < WINDOW_SIZE; i++) {
derivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));
harris3i += ivec3(
derivatives.x * derivatives.x,
derivatives.x * derivatives.y,
derivatives.y * derivatives.y
);
derivativesAt(i-r, j-r) = derivatives;
}
}
highp vec3 harris = vec3(harris3i) * FLT_SCALE;
highp mat2 invHarris = mat2(harris.z, -harris.y, -harris.y, harris.x);
highp float det = harris.x * harris.z - harris.y * harris.y;
highp float invDet = abs(det) >= FLT_EPSILON ? 1.0f / det : 0.0f;
highp float minEigenvalue = 0.5f * ((harris.x + harris.z) - sqrt(
(harris.x - harris.z) * (harris.x - harris.z) + 4.0f * (harris.y * harris.y)
));
int niceNumbers = int(abs(det) >= FLT_EPSILON && minEigenvalue >= discardThreshold * windowArea);
bool goodKeypoint = (level > 0) || (niceNumbers != 0);
highp float eps2 = epsilon * epsilon;
highp vec2 mismatch, delta, localGuess = vec2(0.0f);
for(int k = 0; k < numberOfIterations; k++) {
mismatch = niceNumbers != 0 ? computeMismatch(pyrGuess, localGuess) : vec2(0.0f);
delta = mismatch * invHarris * invDet;
niceNumbers *= int(eps2 <= dot(delta, delta));
localGuess += float(niceNumbers) * delta;
}
vec2 opticalFlow = pyrGuess + localGuess;
bool mustDiscard = (level == 0) && any(bvec2(
!goodKeypoint,
!isInsideImage(keypoint.position + opticalFlow)
));
color = !mustDiscard ? encodePairOfFloat16(opticalFlow) : encodeDiscardedPairOfFloat16();
}`},3890:r=>{r.exports=`#if @FS_USE_CUSTOM_PRECISION@
precision mediump int;
precision mediump float;
#endif
#if !defined(STAGE)
#error Undefined STAGE
#elif STAGE == 1
@include "float16.glsl"
uniform sampler2D corners;
#elif STAGE < 1
uniform mediump usampler2D lookupTable;
#else
#define SKIP_TEXTURE_READS 1
#define DENSITY_FACTOR 0.10
uniform mediump usampler2D lookupTable;
uniform int blockSize;
uniform int width;
uniform int height;
in vec2 v_topLeft, v_top, v_topRight,
v_left, v_center, v_right,
v_bottomLeft, v_bottom, v_bottomRight;
#endif
const uvec2 NULL_ELEMENT = uvec2(0xFFFFu);
void main()
{
#if STAGE == 1
uvec2 outSize = uvec2(outputSize());
uvec2 thread = uvec2(threadLocation());
uvec2 size = uvec2(textureSize(corners, 0));
uint location = thread.y * outSize.x + thread.x;
ivec2 pos = ivec2(location % size.x, location / size.x);
vec4 pixel = location < size.x * size.y ? texelFetch(corners, pos, 0) : vec4(0.0f);
bool isCorner = !isEncodedFloat16Zero(pixel.rb);
color = isCorner ? uvec4(uvec2(pos), 1u, 0u) : uvec4(NULL_ELEMENT, 0u, 0u);
#elif STAGE > 1
int dblBlockSize = 2 * blockSize;
ivec2 thread = threadLocation();
ivec2 offset = thread % dblBlockSize;
ivec2 delta = thread - offset;
#if SKIP_TEXTURE_READS
if(blockSize >= 8) {
uint sb = texture(lookupTable, texCoord).z;
float p = max((float(sb) / float(blockSize)) / float(blockSize), DENSITY_FACTOR);
float rowthr = float(dblBlockSize) * p + 3.0f * sqrt(p * (1.0f - p));
color = uvec4(NULL_ELEMENT, 4u * sb, 0u);
if(offset.y >= max(1, int(ceil(rowthr))))
return;
}
#endif
#define deltaCenter ivec2(0,0)
#define deltaTop ivec2(0,-blockSize)
#define deltaTopRight ivec2(blockSize,-blockSize)
#define deltaRight ivec2(blockSize,0)
#define deltaBottomRight ivec2(blockSize,blockSize)
#define deltaBottom ivec2(0,blockSize)
#define deltaBottomLeft ivec2(-blockSize,blockSize)
#define deltaLeft ivec2(-blockSize,0)
#define deltaTopLeft ivec2(-blockSize,-blockSize)
ivec2 boundary = ivec2(width - 1, height - 1) / blockSize;
ivec2 bottomRightPos = thread + deltaBottomRight;
uvec2 valid = uvec2(
bottomRightPos.x < width  || bottomRightPos.x / blockSize == boundary.x,
bottomRightPos.y < height || bottomRightPos.y / blockSize == boundary.y
);
uvec4 mask[4];
mask[0] = uvec4(1u, valid.x, valid.y, valid.x * valid.y);
mask[1] = uvec4(1u, 1u, valid.y, valid.y);
mask[2] = uvec4(1u, valid.x, 1u, valid.x);
mask[3] = uvec4(1u);
#if SKIP_TEXTURE_READS
#define calcSb(delta) texelFetch(lookupTable, blockSize * ((thread + (delta)) / blockSize), 0).z
uint center = calcSb(deltaCenter);
uint top = calcSb(deltaTop);
uint topRight = calcSb(deltaTopRight);
uint right = calcSb(deltaRight);
uint bottomRight = calcSb(deltaBottomRight);
uint bottom = calcSb(deltaBottom);
uint bottomLeft = calcSb(deltaBottomLeft);
uint left = calcSb(deltaLeft);
uint topLeft = calcSb(deltaTopLeft);
#else
#define calcSb(pos) texture(lookupTable, (pos)).z
uint center = calcSb(v_center);
uint top = calcSb(v_top);
uint topRight = calcSb(v_topRight);
uint right = calcSb(v_right);
uint bottomRight = calcSb(v_bottomRight);
uint bottom = calcSb(v_bottom);
uint bottomLeft = calcSb(v_bottomLeft);
uint left = calcSb(v_left);
uint topLeft = calcSb(v_topLeft);
#endif
uvec4 sums[4];
sums[0] = uvec4(center, right, bottom, bottomRight);
sums[1] = uvec4(left, center, bottomLeft, bottom);
sums[2] = uvec4(top, topRight, center, right);
sums[3] = uvec4(topLeft, top, left, center);
ivec2 cmp = ivec2(greaterThanEqual(offset, ivec2(blockSize)));
int option = 2 * cmp.y + cmp.x;
uvec4 cdef = sums[option] * mask[option];
uint c2b = cdef.x, d2b = cdef.y, e2b = cdef.z, f2b = cdef.w;
uint sb = center;
uint s2b = c2b + d2b + e2b + f2b;
s2b = s2b < sb ? 0xFFFFu : min(0xFFFFu, s2b);
uint w2b = uint(min(dblBlockSize, width - delta.x));
uvec2 uoffset = uvec2(offset);
uint ceiling = s2b >= uoffset.x ? (s2b - uoffset.x) / w2b + uint((s2b - uoffset.x) % w2b > 0u) : 0u;
color = uvec4(NULL_ELEMENT, s2b, 0u);
if(uoffset.y >= ceiling)
return;
uint i2b = uoffset.y * w2b + uoffset.x;
uint j2b = i2b >= c2b ? i2b - c2b : 0u;
uint k2b = j2b >= d2b ? j2b - d2b : 0u;
uint l2b = k2b >= e2b ? k2b - e2b : 0u;
uint wl = uint(min(blockSize, width - delta.x));
uint wr = uint(min(blockSize, width - delta.x - blockSize));
ivec2 magicOffset = (
(i2b < c2b) ? ivec2(i2b % wl, i2b / wl) : (
(j2b < d2b) ? ivec2(j2b % wr, j2b / wr) + ivec2(blockSize, 0) : (
(k2b < e2b) ? ivec2(k2b % wl, k2b / wl) + ivec2(0, blockSize) : (
(l2b < f2b) ? ivec2(l2b % wr, l2b / wr) + ivec2(blockSize) : ivec2(0)
))));
uvec2 a2b = texelFetch(lookupTable, delta + magicOffset, 0).xy;
color = uvec4(a2b, s2b, 0u);
#else
uvec4 pix = texture(lookupTable, texCoord);
color = all(equal(pix.xy, NULL_ELEMENT)) ? vec4(0,1,1,1) : vec4(1,0,0,1);
#endif
}`},8647:r=>{r.exports=`#if !defined(STAGE) || STAGE < 1
#error Invalid STAGE
#else
uniform mediump int blockSize;
out vec2 v_topLeft, v_top, v_topRight,
v_left, v_center, v_right,
v_bottomLeft, v_bottom, v_bottomRight;
void vsmain()
{
float b = float(blockSize);
#define V(x,y) (texCoord + (vec2((x),(y)) * b) / texSize)
v_topLeft = V(-1,-1); v_top = V(0,-1); v_topRight = V(1,-1);
v_left = V(-1,0); v_center = V(0,0); v_right = V(1,0);
v_bottomLeft = V(-1,1); v_bottom = V(0,1); v_bottomRight = V(1,1);
}
#endif`},4776:r=>{r.exports=`@include "keypoints.glsl"
@include "keypoint-matches.glsl"
@include "keypoint-descriptors.glsl"
uniform sampler2D candidates;
uniform sampler2D filters;
uniform int matcherLength;
uniform sampler2D tables;
uniform sampler2D descriptorDB;
uniform int tableIndex;
uniform int bucketCapacity;
uniform int bucketsPerTable;
uniform int tablesStride;
uniform int descriptorDBStride;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#if HASH_SIZE > SEQUENCE_MAXLEN
#error LSH: invalid HASH_SIZE
#elif SEQUENCE_COUNT * SEQUENCE_MAXLEN * 4 > 16384
#error LSH: sequences are too large!
#elif (SEQUENCE_COUNT * SEQUENCE_MAXLEN) % 4 > 0
#error LSH: sequences of invalid size!
#endif
layout(std140) uniform LSHSequences
{
uvec4 sequences[(SEQUENCE_COUNT * SEQUENCE_MAXLEN) / 4];
};
#if HASH_SIZE == 10
const int SWAP_COUNT[3] = int[3](1, 11, 56);
const int[56] SWAP = int[56](0,1,2,4,8,16,32,64,128,256,512,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768);
#elif HASH_SIZE == 11
const int SWAP_COUNT[3] = int[3](1, 12, 67);
const int[67] SWAP = int[67](0,1,2,4,8,16,32,64,128,256,512,1024,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536);
#elif HASH_SIZE == 12
const int SWAP_COUNT[3] = int[3](1, 13, 79);
const int[79] SWAP = int[79](0,1,2,4,8,16,32,64,128,256,512,1024,2048,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072);
#elif HASH_SIZE == 13
const int SWAP_COUNT[3] = int[3](1, 14, 92);
const int[92] SWAP = int[92](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144);
#elif HASH_SIZE == 14
const int SWAP_COUNT[3] = int[3](1, 15, 106);
const int[106] SWAP = int[106](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288);
#elif HASH_SIZE == 15
const int SWAP_COUNT[3] = int[3](1, 16, 121);
const int[121] SWAP = int[121](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576);
#elif HASH_SIZE == 16
const int SWAP_COUNT[3] = int[3](1, 17, 137);
const int[137] SWAP = int[137](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152);
#elif HASH_SIZE == 17
const int SWAP_COUNT[3] = int[3](1, 18, 154);
const int[154] SWAP = int[154](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304);
#elif HASH_SIZE == 18
const int SWAP_COUNT[3] = int[3](1, 19, 172);
const int[172] SWAP = int[172](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608);
#elif HASH_SIZE == 19
const int SWAP_COUNT[3] = int[3](1, 20, 191);
const int[191] SWAP = int[191](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216);
#elif HASH_SIZE == 20
const int SWAP_COUNT[3] = int[3](1, 21, 211);
const int[211] SWAP = int[211](0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,3,5,6,9,10,12,17,18,20,24,33,34,36,40,48,65,66,68,72,80,96,129,130,132,136,144,160,192,257,258,260,264,272,288,320,384,513,514,516,520,528,544,576,640,768,1025,1026,1028,1032,1040,1056,1088,1152,1280,1536,2049,2050,2052,2056,2064,2080,2112,2176,2304,2560,3072,4097,4098,4100,4104,4112,4128,4160,4224,4352,4608,5120,6144,8193,8194,8196,8200,8208,8224,8256,8320,8448,8704,9216,10240,12288,16385,16386,16388,16392,16400,16416,16448,16512,16640,16896,17408,18432,20480,24576,32769,32770,32772,32776,32784,32800,32832,32896,33024,33280,33792,34816,36864,40960,49152,65537,65538,65540,65544,65552,65568,65600,65664,65792,66048,66560,67584,69632,73728,81920,98304,131073,131074,131076,131080,131088,131104,131136,131200,131328,131584,132096,133120,135168,139264,147456,163840,196608,262145,262146,262148,262152,262160,262176,262208,262272,262400,262656,263168,264192,266240,270336,278528,294912,327680,393216,524289,524290,524292,524296,524304,524320,524352,524416,524544,524800,525312,526336,528384,532480,540672,557056,589824,655360,786432);
#else
#error Invalid HASH_SIZE
#endif
#if LEVEL < 0 || LEVEL > 2
#error Invalid LEVEL
#endif
const uint END_OF_LIST = 0xFFFFFFFFu;
const int NUMBER_OF_HASHES = SWAP_COUNT[LEVEL];
uint sequenceElement(int sequenceIndex, int elementIndex)
{
int offset = (SEQUENCE_MAXLEN) * sequenceIndex + elementIndex;
uvec4 tuple = sequences[offset / 4];
return tuple[offset & 3];
}
int descriptorHash(uint[DESCRIPTOR_SIZE] descriptor, int sequenceIndex)
{
uint bit, b, m;
int hash = 0;
@unroll
for(int i = 0; i < HASH_SIZE; i++) {
bit = sequenceElement(sequenceIndex, i);
b = bit >> 3u;
m = 1u << (bit & 7u);
hash = (hash << 1) | int((descriptor[b] & m) != 0u);
}
return hash;
}
#define readTableData(tables, tablesStride, rasterIndex) decodeUint32(texelFetch((tables), ivec2((rasterIndex) % (tablesStride), (rasterIndex) / (tablesStride)), 0))
void main()
{
ivec2 thread = threadLocation();
int keypointIndex = thread.x + thread.y * matcherLength;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
color = encodeKeypointMatch(MATCH_NOT_FOUND);
if(isBadKeypoint(keypoint))
return;
KeypointMatch candidate = decodeKeypointMatch(threadPixel(candidates));
KeypointMatch mfilter = decodeKeypointMatch(threadPixel(filters));
uint[DESCRIPTOR_SIZE] candidateDescriptor;
uint[DESCRIPTOR_SIZE] descriptor = readKeypointDescriptor(encodedKeypoints, descriptorSize, extraSize, encoderLength, address);
int hash0 = descriptorHash(descriptor, tableIndex);
for(int h = 0; h < NUMBER_OF_HASHES; h++) {
int hash = hash0 ^ SWAP[h];
int tableAddress = tableIndex * bucketsPerTable * bucketCapacity;
int bucketAddress = tableAddress + hash * bucketCapacity;
bool validEntry = true;
for(int b = 0; b < bucketCapacity; b++) {
int entryAddress = bucketAddress + b;
uint entry = validEntry ? readTableData(tables, tablesStride, entryAddress) : END_OF_LIST;
validEntry = (validEntry && entry != END_OF_LIST);
int candidateIndex = int(entry);
candidateDescriptor = readKeypointDescriptorFromDB(descriptorDB, descriptorDBStride, validEntry ? candidateIndex : -1);
int descriptorDistance = distanceBetweenKeypointDescriptors(descriptor, candidateDescriptor);
KeypointMatch match = KeypointMatch(candidateIndex, descriptorDistance);
bool betterThanCandidate = (match.dist < candidate.dist) || (match.dist == candidate.dist && match.index > candidate.index);
bool worseThanFilter = (match.dist > mfilter.dist) || (match.dist == mfilter.dist && match.index < mfilter.index);
bool nicerMatch = (validEntry && betterThanCandidate && worseThanFilter);
ivec2 v = nicerMatch ? ivec2(match.index, match.dist) : ivec2(candidate.index, candidate.dist);
candidate = KeypointMatch(v.x, v.y);
}
}
color = encodeKeypointMatch(candidate);
}`},2648:r=>{r.exports=`@include "keypoints.glsl"
@include "int32.glsl"
#if !defined(STAGE)
#error Undefined STAGE
#elif STAGE == 1
uniform sampler2D encodedKeypointsA;
uniform sampler2D encodedKeypointsB;
uniform int encoderLengthA;
uniform int encoderLengthB;
uniform int encoderCapacityA;
uniform int encoderCapacityB;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#elif STAGE == 2
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int maxKeypoints;
#elif STAGE == 3
uniform sampler2D array;
uniform int blockSize;
#elif STAGE == 4
uniform sampler2D array;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#elif STAGE == 5
uniform sampler2D array;
#else
#error Invalid STAGE
#endif
#define NULL_KEYPOINT_INDEX 0xFFFF
const highp uint UNIT = 0x10000u;
void main()
{
#if STAGE == 1
ivec2 thread = threadLocation();
KeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);
int newKeypointIndex = keypointIndex < encoderCapacityA ? keypointIndex : keypointIndex - encoderCapacityA;
color = encodeNullKeypoint();
if(newKeypointIndex >= max(encoderCapacityA, encoderCapacityB))
return;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
addr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);
vec4 dataA = readKeypointData(encodedKeypointsA, encoderLengthA, addr);
vec4 dataB = readKeypointData(encodedKeypointsB, encoderLengthB, addr);
color = keypointIndex < encoderCapacityA ? dataA : dataB;
#elif STAGE == 2
ivec2 thread = threadLocation();
int keypointIndex = thread.y * outputSize().x + thread.x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress addr = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, addr);
bool isValid = !isNullKeypoint(keypoint) && keypointIndex < maxKeypoints;
keypointIndex = isValid ? keypointIndex : NULL_KEYPOINT_INDEX;
color = encodeUint32(uint(keypointIndex & 0xFFFF) | (isValid ? UNIT : 0u));
#elif STAGE == 3
ivec2 thread = threadLocation();
ivec2 size = outputSize();
int arrayLength = size.x * size.y;
int arrayIndex = thread.y * size.x + thread.x;
int arrayIndexLeft = arrayIndex - blockSize;
int arrayIndexRight = arrayIndex + blockSize;
int mask = int(arrayIndexRight < arrayLength || arrayIndexRight / blockSize == (arrayLength - 1) / blockSize);
arrayIndexLeft = max(0, arrayIndexLeft);
arrayIndexRight = min(arrayLength - 1, arrayIndexRight);
#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)
uvec3 entries32 = uvec3(
decodeUint32(threadPixel(array)),
decodeUint32(texelFetch(array, raster2pos(arrayIndexLeft), 0)),
decodeUint32(texelFetch(array, raster2pos(arrayIndexRight), 0))
);
ivec3 sb = ivec3((entries32 >> 16u) & 0xFFFFu);
sb.z *= mask;
int dblBlockSize = 2 * blockSize;
int offset = arrayIndex % dblBlockSize;
int s2b = sb.x + (offset < blockSize ? sb.z : sb.y);
int l2b = offset < blockSize ? sb.x : sb.y;
uint keypointIndex = entries32.x & 0xFFFFu;
uint shiftedS2b = uint(s2b) << 16u;
color = encodeUint32(uint(NULL_KEYPOINT_INDEX) | shiftedS2b);
if(offset >= s2b)
return;
color = encodeUint32(keypointIndex | shiftedS2b);
if(offset < l2b)
return;
vec4 entry = texelFetch(array, raster2pos(arrayIndex + blockSize - l2b), 0);
keypointIndex = decodeUint32(entry) & 0xFFFFu;
color = encodeUint32(keypointIndex | shiftedS2b);
#elif STAGE == 4
ivec2 thread = threadLocation();
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress addr = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int keypointIndex = findKeypointIndex(addr, descriptorSize, extraSize);
#define raster2pos(k) ivec2((k) % size.x, (k) / size.x)
ivec2 size = textureSize(array, 0);
uint sortedPair = decodeUint32(texelFetch(array, raster2pos(keypointIndex), 0));
int newKeypointIndex = int(sortedPair & 0xFFFFu);
color = encodeNullKeypoint();
if(newKeypointIndex == NULL_KEYPOINT_INDEX || keypointIndex >= size.x * size.y)
return;
KeypointAddress newAddr = KeypointAddress(newKeypointIndex * pixelsPerKeypoint, addr.offset);
color = readKeypointData(encodedKeypoints, encoderLength, newAddr);
#elif STAGE == 5
uint val = decodeUint32(threadPixel(array));
color = (val & 0xFFFFu) == uint(NULL_KEYPOINT_INDEX) ? vec4(0,1,1,1) : vec4(1,0,0,1);
#endif
}`},8825:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
@include "filters.glsl"
#if !defined(USE_LAPLACIAN)
#error Undefined USE_LAPLACIAN
#endif
uniform sampler2D corners;
uniform sampler2D pyramid;
uniform float lodStep;
#if USE_LAPLACIAN
uniform sampler2D pyrLaplacian;
#endif
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(corners);
float score = decodeFloat16(pixel.rb);
float myEncodedLod = pixel.a;
float lod = decodeLod(myEncodedLod);
float lodPlus = lod + lodStep;
float lodMinus = lod - lodStep;
float pot = exp2(lod);
float potPlus = exp2(lodPlus);
float potMinus = exp2(lodMinus);
color = pixel;
if(score == 0.0f)
return;
#define P(p,u,v) textureLod(corners, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)
vec4 pix[18];
#define D(u,v) P(potMinus,(u),(v))
pix[0] = D(-1,-1); pix[1] = D(0,-1); pix[2] = D(1,-1);
pix[3] = D(-1,0); pix[4] = D(0,0); pix[5] = D(1,0);
pix[6] = D(-1,1); pix[7] = D(0,1); pix[8] = D(1,1);
#define U(u,v) P(potPlus,(u),(v))
pix[9] = U(-1,-1); pix[10] = U(0,-1); pix[11] = U(1,-1);
pix[12] = U(-1,0); pix[13] = U(0,0); pix[14] = U(1,0);
pix[15] = U(-1,1); pix[16] = U(0,1); pix[17] = U(1,1);
float scores[18];
#define C(j) decodeFloat16(pix[j].rb)
scores[0] = C(0); scores[1] = C(1); scores[2] = C(2);
scores[3] = C(3); scores[4] = C(4); scores[5] = C(5);
scores[6] = C(6); scores[7] = C(7); scores[8] = C(8);
scores[9] = C(9); scores[10] = C(10); scores[11] = C(11);
scores[12] = C(12); scores[13] = C(13); scores[14] = C(14);
scores[15] = C(15); scores[16] = C(16); scores[17] = C(17);
float lods[18];
#define E(j) decodeLod(pix[j].a)
lods[0] = E(0); lods[1] = E(1); lods[2] = E(2);
lods[3] = E(3); lods[4] = E(4); lods[5] = E(5);
lods[6] = E(6); lods[7] = E(7); lods[8] = E(8);
lods[9] = E(9); lods[10] = E(10); lods[11] = E(11);
lods[12] = E(12); lods[13] = E(13); lods[14] = E(14);
lods[15] = E(15); lods[16] = E(16); lods[17] = E(17);
#if USE_LAPLACIAN
#define L(p,u,v) textureLod(pyrLaplacian, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)
mat3 strengths[2];
strengths[0] = mat3(
#define Lm(u,v) abs(decodeFloat16(L(potMinus,(u),(v)).xy))
Lm(-1,-1), Lm(0,-1), Lm(1,-1),
Lm(-1,0), Lm(0,0), Lm(1,0),
Lm(-1,1), Lm(0,1), Lm(1,1)
);
strengths[1] = mat3(
#define Lp(u,v) abs(decodeFloat16(L(potPlus,(u),(v)).zw))
Lp(-1,-1), Lp(0,-1), Lp(1,-1),
Lp(-1,0), Lp(0,0), Lp(1,0),
Lp(-1,1), Lp(0,1), Lp(1,1)
);
float myStrength = abs(laplacian(pyramid, vec2(thread), lod));
#else
#define L(u,v) (((v)+1)*3 + ((u)+1))
mat3 strengths[2];
strengths[0] = mat3(
#define Lm(u,v) scores[L((u),(v))]
Lm(-1,-1), Lm(0,-1), Lm(1,-1),
Lm(-1,0), Lm(0,0), Lm(1,0),
Lm(-1,1), Lm(0,1), Lm(1,1)
);
strengths[1] = mat3(
#define Lp(u,v) scores[9 + L((u),(v))]
Lp(-1,-1), Lp(0,-1), Lp(1,-1),
Lp(-1,0), Lp(0,0), Lp(1,0),
Lp(-1,1), Lp(0,1), Lp(1,1)
);
float myStrength = score;
#endif
#define B(j,lod) float(isSameLod(lods[j], (lod))) * float(scores[j] > 0.0f)
mat3 nearLod[2];
nearLod[0] = mat3(
#define Bm(j) B((j), lodMinus)
Bm(0), Bm(1), Bm(2),
Bm(3), Bm(4), Bm(5),
Bm(6), Bm(7), Bm(8)
);
nearLod[1] = mat3(
#define Bp(j) B((j), lodPlus)
Bp(9), Bp(10), Bp(11),
Bp(12), Bp(13), Bp(14),
Bp(15), Bp(16), Bp(17)
);
mat3 upStrengths = matrixCompMult(strengths[1], nearLod[1]);
mat3 downStrengths = matrixCompMult(strengths[0], nearLod[0]);
vec3 maxUpStrength3 = max(upStrengths[0], max(upStrengths[1], upStrengths[2]));
vec3 maxDownStrength3 = max(downStrengths[0], max(downStrengths[1], downStrengths[2]));
vec3 maxStrength3 = max(maxUpStrength3, maxDownStrength3);
float maxStrength = max(maxStrength3.x, max(maxStrength3.y, maxStrength3.z));
color.rb = encodeFloat16(score * step(maxStrength, myStrength));
}`},5693:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
uniform sampler2D corners;
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = threadPixel(corners);
float encodedLod = pixel.a;
float score = decodeFloat16(pixel.rb);
float lod = decodeLod(encodedLod);
float pot = exp2(lod);
color = pixel;
if(score == 0.0f)
return;
#if 1
vec2 gridSize = vec2(pot);
vec2 gridLocation = floor(mod(texCoord * texSize, gridSize));
vec2 gridDelta = gridLocation / gridSize - vec2(0.5f);
float gridStep = 1.0f / pot;
const float adjustment = 1.25f;
color.rb = encodeFloat16(0.0f);
if(max(abs(gridDelta.x), abs(gridDelta.y)) > adjustment * gridStep)
return;
#endif
#define P(x,y) textureLod(corners, texCoord + pot * vec2((x), (y)) / texSize, 0.0f)
vec4 pix[9];
pix[0] = P(-1,-1); pix[1] = P(0,-1); pix[2] = P(1,-1);
pix[3] = P(-1, 0); pix[4] = pixel;   pix[5] = P(1, 0);
pix[6] = P(-1, 1); pix[7] = P(0, 1); pix[8] = P(1, 1);
#define S(j) decodeFloat16(pix[j].rb)
mat3 scores = mat3(
S(0), S(1), S(2),
S(3), S(4), S(5),
S(6), S(7), S(8)
);
#define B(j) float(isSameLod(decodeLod(pix[j].a), lod))
mat3 sameLod = mat3(
B(0), B(1), B(2),
B(3), B(4), B(5),
B(6), B(7), B(8)
);
mat3 sameLodScores = matrixCompMult(scores, sameLod);
vec3 maxScore3 = max(sameLodScores[0], max(sameLodScores[1], sameLodScores[2]));
float maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));
color.rb = encodeFloat16(score * step(maxScore, score));
}`},9280:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
uniform sampler2D image;
uniform float lodStep;
#if !defined(MULTISCALE)
#error Must define MULTISCALE
#elif MULTISCALE != 0
#define LOD_STEP (lodStep)
#define USE_MIDDLE_RING
#else
#define LOD_STEP (0.0f)
#endif
#define PIX(x,y) pixelAtShortOffset(image, ivec2((x),(y)))
#define L2(v,i) bvec2(isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))
#define L3(v,i) bvec3(isSameEncodedLod(v[i].a, alpha), isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))
#define S3(v,i) decodeFloat16(v[i].rb) * float(any(L3(v,i)))
#define S2(v,i) decodeFloat16(v[i].rb) * float(any(L2(v,i)))
#define P(i) S3(p,i)
#define Q(i) S2(q,i)
#define R(i) S2(r,i)
const vec4 O = vec4(0.0f);
void main()
{
vec4 pixel = threadPixel(image);
float lod = decodeLod(pixel.a);
float score = decodeFloat16(pixel.rb);
color = pixel;
if(score == 0.0f)
return;
vec4 p[8];
p[0] = PIX(0,1); p[1] = PIX(1,1); p[2] = PIX(1,0); p[3] = PIX(1,-1);
p[4] = PIX(0,-1); p[5] = PIX(-1,-1); p[6] = PIX(-1,0); p[7] = PIX(-1,1);
#ifdef USE_MIDDLE_RING
vec4 q[16];
q[0] = PIX(0,2); q[1] = PIX(1,2); q[2] = PIX(2,2); q[3] = PIX(2,1);
q[4] = PIX(2,0); q[5] = PIX(2,-1); q[6] = PIX(2,-2); q[7] = PIX(1,-2);
q[8] = PIX(0,-2); q[9] = PIX(-1,-2); q[10] = PIX(-2,-2); q[11] = PIX(-2,-1);
q[12] = PIX(-2,0); q[13] = PIX(-2,1); q[14] = PIX(-2,2); q[15] = PIX(-1,2);
#else
vec4 q[16];
q[0] = O; q[1] = O; q[2] = O; q[3] = O;
q[4] = O; q[5] = O; q[6] = O; q[7] = O;
q[8] = O; q[9] = O; q[10] = O; q[11] = O;
q[12] = O; q[13] = O; q[14] = O; q[15] = O;
#endif
#ifdef USE_OUTER_RING
vec4 r[16];
r[0] = PIX(0,3); r[1] = PIX(1,3); r[2] = PIX(3,1); r[3] = PIX(3,0);
r[4] = PIX(3,-1); r[5] = PIX(1,-3); r[6] = PIX(0,-3); r[7] = PIX(-1,-3);
r[8] = PIX(-3,-1); r[9] = PIX(-3,0); r[10] = PIX(-3,1); r[11] = PIX(-1,3);
r[12] = PIX(0,4); r[13] = PIX(4,0); r[14] = PIX(0,-4); r[15] = PIX(-4,0);
#else
vec4 r[16];
r[0] = O; r[1] = O; r[2] = O; r[3] = O;
r[4] = O; r[5] = O; r[6] = O; r[7] = O;
r[8] = O; r[9] = O; r[10] = O; r[11] = O;
r[12] = O; r[13] = O; r[14] = O; r[15] = O;
#endif
float alphaPlus = encodeLod(lod + LOD_STEP);
float alphaMinus = encodeLod(lod - LOD_STEP);
float alpha = encodeLod(lod);
mat3 innerScore = mat3(
P(0), P(1), P(2), P(3),
P(4), P(5), P(6), P(7),
0.0f);
mat4 middleScore = mat4(
Q(0), Q(1), Q(2), Q(3),
Q(4), Q(5), Q(6), Q(7),
Q(8), Q(9), Q(10), Q(11),
Q(12), Q(13), Q(14), Q(15)
);
mat4 outerScore = mat4(
R(0), R(1), R(2), R(3),
R(4), R(5), R(6), R(7),
R(8), R(9), R(10), R(11),
R(12), R(13), R(14), R(15)
);
vec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));
vec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));
vec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));
float maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));
float maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));
float maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));
float maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));
float finalScore = step(maxScore, score) * score;
color.rb = encodeFloat16(finalScore);
}`},9108:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedCorners;
uniform int encoderLength;
uniform sampler2D image;
uniform int extraSize;
const int descriptorSize = 32;
#define P(a,b,c,d) ivec4((a),(b),(c),(d))
const ivec4 pat31[256] = ivec4[256](
P(8,-3,9,5),
P(4,2,7,-12),
P(-11,9,-8,2),
P(7,-12,12,-13),
P(2,-13,2,12),
P(1,-7,1,6),
P(-2,-10,-2,-4),
P(-13,-13,-11,-8),
P(-13,-3,-12,-9),
P(10,4,11,9),
P(-13,-8,-8,-9),
P(-11,7,-9,12),
P(7,7,12,6),
P(-4,-5,-3,0),
P(-13,2,-12,-3),
P(-9,0,-7,5),
P(12,-6,12,-1),
P(-3,6,-2,12),
P(-6,-13,-4,-8),
P(11,-13,12,-8),
P(4,7,5,1),
P(5,-3,10,-3),
P(3,-7,6,12),
P(-8,-7,-6,-2),
P(-2,11,-1,-10),
P(-13,12,-8,10),
P(-7,3,-5,-3),
P(-4,2,-3,7),
P(-10,-12,-6,11),
P(5,-12,6,-7),
P(5,-6,7,-1),
P(1,0,4,-5),
P(9,11,11,-13),
P(4,7,4,12),
P(2,-1,4,4),
P(-4,-12,-2,7),
P(-8,-5,-7,-10),
P(4,11,9,12),
P(0,-8,1,-13),
P(-13,-2,-8,2),
P(-3,-2,-2,3),
P(-6,9,-4,-9),
P(8,12,10,7),
P(0,9,1,3),
P(7,-5,11,-10),
P(-13,-6,-11,0),
P(10,7,12,1),
P(-6,-3,-6,12),
P(10,-9,12,-4),
P(-13,8,-8,-12),
P(-13,0,-8,-4),
P(3,3,7,8),
P(5,7,10,-7),
P(-1,7,1,-12),
P(3,-10,5,6),
P(2,-4,3,-10),
P(-13,0,-13,5),
P(-13,-7,-12,12),
P(-13,3,-11,8),
P(-7,12,-4,7),
P(6,-10,12,8),
P(-9,-1,-7,-6),
P(-2,-5,0,12),
P(-12,5,-7,5),
P(3,-10,8,-13),
P(-7,-7,-4,5),
P(-3,-2,-1,-7),
P(2,9,5,-11),
P(-11,-13,-5,-13),
P(-1,6,0,-1),
P(5,-3,5,2),
P(-4,-13,-4,12),
P(-9,-6,-9,6),
P(-12,-10,-8,-4),
P(10,2,12,-3),
P(7,12,12,12),
P(-7,-13,-6,5),
P(-4,9,-3,4),
P(7,-1,12,2),
P(-7,6,-5,1),
P(-13,11,-12,5),
P(-3,7,-2,-6),
P(7,-8,12,-7),
P(-13,-7,-11,-12),
P(1,-3,12,12),
P(2,-6,3,0),
P(-4,3,-2,-13),
P(-1,-13,1,9),
P(7,1,8,-6),
P(1,-1,3,12),
P(9,1,12,6),
P(-1,-9,-1,3),
P(-13,-13,-10,5),
P(7,7,10,12),
P(12,-5,12,9),
P(6,3,7,11),
P(5,-13,6,10),
P(2,-12,2,3),
P(3,8,4,-6),
P(2,6,12,-13),
P(9,-12,10,3),
P(-8,4,-7,9),
P(-11,12,-4,-6),
P(1,12,2,-8),
P(6,-9,7,-4),
P(2,3,3,-2),
P(6,3,11,0),
P(3,-3,8,-8),
P(7,8,9,3),
P(-11,-5,-6,-4),
P(-10,11,-5,10),
P(-5,-8,-3,12),
P(-10,5,-9,0),
P(8,-1,12,-6),
P(4,-6,6,-11),
P(-10,12,-8,7),
P(4,-2,6,7),
P(-2,0,-2,12),
P(-5,-8,-5,2),
P(7,-6,10,12),
P(-9,-13,-8,-8),
P(-5,-13,-5,-2),
P(8,-8,9,-13),
P(-9,-11,-9,0),
P(1,-8,1,-2),
P(7,-4,9,1),
P(-2,1,-1,-4),
P(11,-6,12,-11),
P(-12,-9,-6,4),
P(3,7,7,12),
P(5,5,10,8),
P(0,-4,2,8),
P(-9,12,-5,-13),
P(0,7,2,12),
P(-1,2,1,7),
P(5,11,7,-9),
P(3,5,6,-8),
P(-13,-4,-8,9),
P(-5,9,-3,-3),
P(-4,-7,-3,-12),
P(6,5,8,0),
P(-7,6,-6,12),
P(-13,6,-5,-2),
P(1,-10,3,10),
P(4,1,8,-4),
P(-2,-2,2,-13),
P(2,-12,12,12),
P(-2,-13,0,-6),
P(4,1,9,3),
P(-6,-10,-3,-5),
P(-3,-13,-1,1),
P(7,5,12,-11),
P(4,-2,5,-7),
P(-13,9,-9,-5),
P(7,1,8,6),
P(7,-8,7,6),
P(-7,-4,-7,1),
P(-8,11,-7,-8),
P(-13,6,-12,-8),
P(2,4,3,9),
P(10,-5,12,3),
P(-6,-5,-6,7),
P(8,-3,9,-8),
P(2,-12,2,8),
P(-11,-2,-10,3),
P(-12,-13,-7,-9),
P(-11,0,-10,-5),
P(5,-3,11,8),
P(-2,-13,-1,12),
P(-1,-8,0,9),
P(-13,-11,-12,-5),
P(-10,-2,-10,11),
P(-3,9,-2,-13),
P(2,-3,3,2),
P(-9,-13,-4,0),
P(-4,6,-3,-10),
P(-4,12,-2,-7),
P(-6,-11,-4,9),
P(6,-3,6,11),
P(-13,11,-5,5),
P(11,11,12,6),
P(7,-5,12,-2),
P(-1,12,0,7),
P(-4,-8,-3,-2),
P(-7,1,-6,7),
P(-13,-12,-8,-13),
P(-7,-2,-6,-8),
P(-8,5,-6,-9),
P(-5,-1,-4,5),
P(-13,7,-8,10),
P(1,5,5,-13),
P(1,0,10,-13),
P(9,12,10,-1),
P(5,-8,10,-9),
P(-1,11,1,-13),
P(-9,-3,-6,2),
P(-1,-10,1,12),
P(-13,1,-8,-10),
P(8,-11,10,-6),
P(2,-13,3,-6),
P(7,-13,12,-9),
P(-10,-10,-5,-7),
P(-10,-8,-8,-13),
P(4,-6,8,5),
P(3,12,8,-13),
P(-4,2,-3,-3),
P(5,-13,10,-12),
P(4,-13,5,-1),
P(-9,9,-4,3),
P(0,3,3,-9),
P(-12,1,-6,1),
P(3,2,4,-8),
P(-10,-10,-10,9),
P(8,-13,12,12),
P(-8,-12,-6,-5),
P(2,2,3,7),
P(10,6,11,-8),
P(6,8,8,-12),
P(-7,10,-6,5),
P(-3,-9,-3,9),
P(-1,-13,-1,5),
P(-3,-7,-3,4),
P(-8,-2,-8,3),
P(4,2,12,12),
P(2,-5,3,11),
P(6,-9,11,-13),
P(3,-1,7,12),
P(11,-1,12,4),
P(-3,0,-3,6),
P(4,-11,4,12),
P(2,-4,2,1),
P(-10,-6,-8,1),
P(-13,7,-11,1),
P(-13,12,-11,-13),
P(6,0,11,-13),
P(0,-1,1,4),
P(-13,3,-9,-2),
P(-9,8,-6,-3),
P(-13,-6,-8,-2),
P(5,-9,8,10),
P(2,7,3,-9),
P(-1,-6,-1,-1),
P(9,5,11,-2),
P(11,-3,12,-8),
P(3,0,3,5),
P(-1,4,0,10),
P(3,-6,4,5),
P(-13,0,-10,5),
P(5,8,12,11),
P(8,9,9,-6),
P(7,-4,8,-12),
P(-10,4,-10,9),
P(7,3,12,4),
P(9,-7,10,-2),
P(7,0,12,-2),
P(-1,-6,0,-11)
);
void getPair(int index, mat2 rot, out vec2 p, out vec2 q)
{
ivec4 data = pat31[index];
vec2 op = vec2(data.xy);
vec2 oq = vec2(data.zw);
p = rot * op;
q = rot * oq;
}
void main()
{
vec4 pixel = threadPixel(encodedCorners);
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;
color = pixel;
if(descriptorCell < 0)
return;
Keypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);
if(isBadKeypoint(keypoint))
return;
float degreesOrientation = round(360.0f + degrees(keypoint.orientation));
float orientation = radians(degreesOrientation - mod(degreesOrientation, 12.0f));
float kcos = cos(orientation);
float ksin = sin(orientation);
mat2 rot = mat2(kcos, ksin, -ksin, kcos);
float pot = exp2(keypoint.lod);
int patternStart = 32 * descriptorCell;
uint test[4] = uint[4](0u, 0u, 0u, 0u);
for(int t = 0; t < 4; t++) {
uint bits = 0u;
vec2 p, q;
vec4 a, b;
int i = t * 8;
@unroll
for(int j = 0; j < 8; j++) {
getPair(patternStart + i + j, rot, p, q);
a = texelFetch(image, ivec2(round(keypoint.position + pot * p)), 0);
b = texelFetch(image, ivec2(round(keypoint.position + pot * q)), 0);
bits |= uint(a.g < b.g) << j;
}
test[t] = bits;
}
color = vec4(test[0], test[1], test[2], test[3]) / 255.0f;
}`},7137:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D image;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#define P(x,y) ivec2((x),(y))
const int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);
const ivec2 diskPoint[708] = ivec2[708](
P(0,-1),P(-1,0),P(1,0),P(0,1),
P(-1,-1),P(1,-1),P(-1,1),P(1,1),P(0,-2),P(-2,0),P(2,0),P(0,2),
P(-1,-2),P(1,-2),P(-2,-1),P(2,-1),P(-2,1),P(2,1),P(-1,2),P(1,2),P(-2,-2),P(2,-2),P(-2,2),P(2,2),P(0,-3),P(-3,0),P(3,0),P(0,3),
P(-1,-3),P(1,-3),P(-3,-1),P(3,-1),P(-3,1),P(3,1),P(-1,3),P(1,3),P(-2,-3),P(2,-3),P(-3,-2),P(3,-2),P(-3,2),P(3,2),P(-2,3),P(2,3),P(0,-4),P(-4,0),P(4,0),P(0,4),
P(-1,-4),P(1,-4),P(-4,-1),P(4,-1),P(-4,1),P(4,1),P(-1,4),P(1,4),P(-3,-3),P(3,-3),P(-3,3),P(3,3),P(-2,-4),P(2,-4),P(-4,-2),P(4,-2),P(-4,2),P(4,2),P(-2,4),P(2,4),P(0,-5),P(-3,-4),P(3,-4),P(-4,-3),P(4,-3),P(-5,0),P(5,0),P(-4,3),P(4,3),P(-3,4),P(3,4),P(0,5),
P(-1,-5),P(1,-5),P(-5,-1),P(5,-1),P(-5,1),P(5,1),P(-1,5),P(1,5),P(-2,-5),P(2,-5),P(-5,-2),P(5,-2),P(-5,2),P(5,2),P(-2,5),P(2,5),P(-4,-4),P(4,-4),P(-4,4),P(4,4),P(-3,-5),P(3,-5),P(-5,-3),P(5,-3),P(-5,3),P(5,3),P(-3,5),P(3,5),P(0,-6),P(-6,0),P(6,0),P(0,6),
P(-1,-6),P(1,-6),P(-6,-1),P(6,-1),P(-6,1),P(6,1),P(-1,6),P(1,6),P(-2,-6),P(2,-6),P(-6,-2),P(6,-2),P(-6,2),P(6,2),P(-2,6),P(2,6),P(-4,-5),P(4,-5),P(-5,-4),P(5,-4),P(-5,4),P(5,4),P(-4,5),P(4,5),P(-3,-6),P(3,-6),P(-6,-3),P(6,-3),P(-6,3),P(6,3),P(-3,6),P(3,6),P(0,-7),P(-7,0),P(7,0),P(0,7),
P(-1,-7),P(1,-7),P(-5,-5),P(5,-5),P(-7,-1),P(7,-1),P(-7,1),P(7,1),P(-5,5),P(5,5),P(-1,7),P(1,7),P(-4,-6),P(4,-6),P(-6,-4),P(6,-4),P(-6,4),P(6,4),P(-4,6),P(4,6),P(-2,-7),P(2,-7),P(-7,-2),P(7,-2),P(-7,2),P(7,2),P(-2,7),P(2,7),P(-3,-7),P(3,-7),P(-7,-3),P(7,-3),P(-7,3),P(7,3),P(-3,7),P(3,7),P(-5,-6),P(5,-6),P(-6,-5),P(6,-5),P(-6,5),P(6,5),P(-5,6),P(5,6),P(0,-8),P(-8,0),P(8,0),P(0,8),
P(-1,-8),P(1,-8),P(-4,-7),P(4,-7),P(-7,-4),P(7,-4),P(-8,-1),P(8,-1),P(-8,1),P(8,1),P(-7,4),P(7,4),P(-4,7),P(4,7),P(-1,8),P(1,8),P(-2,-8),P(2,-8),P(-8,-2),P(8,-2),P(-8,2),P(8,2),P(-2,8),P(2,8),P(-6,-6),P(6,-6),P(-6,6),P(6,6),P(-3,-8),P(3,-8),P(-8,-3),P(8,-3),P(-8,3),P(8,3),P(-3,8),P(3,8),P(-5,-7),P(5,-7),P(-7,-5),P(7,-5),P(-7,5),P(7,5),P(-5,7),P(5,7),P(-4,-8),P(4,-8),P(-8,-4),P(8,-4),P(-8,4),P(8,4),P(-4,8),P(4,8),P(0,-9),P(-9,0),P(9,0),P(0,9),
P(-1,-9),P(1,-9),P(-9,-1),P(9,-1),P(-9,1),P(9,1),P(-1,9),P(1,9),P(-2,-9),P(2,-9),P(-6,-7),P(6,-7),P(-7,-6),P(7,-6),P(-9,-2),P(9,-2),P(-9,2),P(9,2),P(-7,6),P(7,6),P(-6,7),P(6,7),P(-2,9),P(2,9),P(-5,-8),P(5,-8),P(-8,-5),P(8,-5),P(-8,5),P(8,5),P(-5,8),P(5,8),P(-3,-9),P(3,-9),P(-9,-3),P(9,-3),P(-9,3),P(9,3),P(-3,9),P(3,9),P(-4,-9),P(4,-9),P(-9,-4),P(9,-4),P(-9,4),P(9,4),P(-4,9),P(4,9),P(-7,-7),P(7,-7),P(-7,7),P(7,7),P(0,-10),P(-6,-8),P(6,-8),P(-8,-6),P(8,-6),P(-10,0),P(10,0),P(-8,6),P(8,6),P(-6,8),P(6,8),P(0,10),
P(-1,-10),P(1,-10),P(-10,-1),P(10,-1),P(-10,1),P(10,1),P(-1,10),P(1,10),P(-2,-10),P(2,-10),P(-10,-2),P(10,-2),P(-10,2),P(10,2),P(-2,10),P(2,10),P(-5,-9),P(5,-9),P(-9,-5),P(9,-5),P(-9,5),P(9,5),P(-5,9),P(5,9),P(-3,-10),P(3,-10),P(-10,-3),P(10,-3),P(-10,3),P(10,3),P(-3,10),P(3,10),P(-7,-8),P(7,-8),P(-8,-7),P(8,-7),P(-8,7),P(8,7),P(-7,8),P(7,8),P(-4,-10),P(4,-10),P(-10,-4),P(10,-4),P(-10,4),P(10,4),P(-4,10),P(4,10),P(-6,-9),P(6,-9),P(-9,-6),P(9,-6),P(-9,6),P(9,6),P(-6,9),P(6,9),P(0,-11),P(-11,0),P(11,0),P(0,11),
P(-1,-11),P(1,-11),P(-11,-1),P(11,-1),P(-11,1),P(11,1),P(-1,11),P(1,11),P(-2,-11),P(2,-11),P(-5,-10),P(5,-10),P(-10,-5),P(10,-5),P(-11,-2),P(11,-2),P(-11,2),P(11,2),P(-10,5),P(10,5),P(-5,10),P(5,10),P(-2,11),P(2,11),P(-8,-8),P(8,-8),P(-8,8),P(8,8),P(-3,-11),P(3,-11),P(-7,-9),P(7,-9),P(-9,-7),P(9,-7),P(-11,-3),P(11,-3),P(-11,3),P(11,3),P(-9,7),P(9,7),P(-7,9),P(7,9),P(-3,11),P(3,11),P(-6,-10),P(6,-10),P(-10,-6),P(10,-6),P(-10,6),P(10,6),P(-6,10),P(6,10),P(-4,-11),P(4,-11),P(-11,-4),P(11,-4),P(-11,4),P(11,4),P(-4,11),P(4,11),P(0,-12),P(-12,0),P(12,0),P(0,12),
P(-1,-12),P(1,-12),P(-8,-9),P(8,-9),P(-9,-8),P(9,-8),P(-12,-1),P(12,-1),P(-12,1),P(12,1),P(-9,8),P(9,8),P(-8,9),P(8,9),P(-1,12),P(1,12),P(-5,-11),P(5,-11),P(-11,-5),P(11,-5),P(-11,5),P(11,5),P(-5,11),P(5,11),P(-2,-12),P(2,-12),P(-12,-2),P(12,-2),P(-12,2),P(12,2),P(-2,12),P(2,12),P(-7,-10),P(7,-10),P(-10,-7),P(10,-7),P(-10,7),P(10,7),P(-7,10),P(7,10),P(-3,-12),P(3,-12),P(-12,-3),P(12,-3),P(-12,3),P(12,3),P(-3,12),P(3,12),P(-6,-11),P(6,-11),P(-11,-6),P(11,-6),P(-11,6),P(11,6),P(-6,11),P(6,11),P(-4,-12),P(4,-12),P(-12,-4),P(12,-4),P(-12,4),P(12,4),P(-4,12),P(4,12),P(-9,-9),P(9,-9),P(-9,9),P(9,9),P(-8,-10),P(8,-10),P(-10,-8),P(10,-8),P(-10,8),P(10,8),P(-8,10),P(8,10),P(0,-13),P(-5,-12),P(5,-12),P(-12,-5),P(12,-5),P(-13,0),P(13,0),P(-12,5),P(12,5),P(-5,12),P(5,12),P(0,13),
P(-1,-13),P(1,-13),P(-7,-11),P(7,-11),P(-11,-7),P(11,-7),P(-13,-1),P(13,-1),P(-13,1),P(13,1),P(-11,7),P(11,7),P(-7,11),P(7,11),P(-1,13),P(1,13),P(-2,-13),P(2,-13),P(-13,-2),P(13,-2),P(-13,2),P(13,2),P(-2,13),P(2,13),P(-3,-13),P(3,-13),P(-13,-3),P(13,-3),P(-13,3),P(13,3),P(-3,13),P(3,13),P(-6,-12),P(6,-12),P(-12,-6),P(12,-6),P(-12,6),P(12,6),P(-6,12),P(6,12),P(-9,-10),P(9,-10),P(-10,-9),P(10,-9),P(-10,9),P(10,9),P(-9,10),P(9,10),P(-4,-13),P(4,-13),P(-8,-11),P(8,-11),P(-11,-8),P(11,-8),P(-13,-4),P(13,-4),P(-13,4),P(13,4),P(-11,8),P(11,8),P(-8,11),P(8,11),P(-4,13),P(4,13),P(-7,-12),P(7,-12),P(-12,-7),P(12,-7),P(-12,7),P(12,7),P(-7,12),P(7,12),P(-5,-13),P(5,-13),P(-13,-5),P(13,-5),P(-13,5),P(13,5),P(-5,13),P(5,13),P(0,-14),P(-14,0),P(14,0),P(0,14),
P(-1,-14),P(1,-14),P(-14,-1),P(14,-1),P(-14,1),P(14,1),P(-1,14),P(1,14),P(-2,-14),P(2,-14),P(-10,-10),P(10,-10),P(-14,-2),P(14,-2),P(-14,2),P(14,2),P(-10,10),P(10,10),P(-2,14),P(2,14),P(-9,-11),P(9,-11),P(-11,-9),P(11,-9),P(-11,9),P(11,9),P(-9,11),P(9,11),P(-3,-14),P(3,-14),P(-6,-13),P(6,-13),P(-13,-6),P(13,-6),P(-14,-3),P(14,-3),P(-14,3),P(14,3),P(-13,6),P(13,6),P(-6,13),P(6,13),P(-3,14),P(3,14),P(-8,-12),P(8,-12),P(-12,-8),P(12,-8),P(-12,8),P(12,8),P(-8,12),P(8,12),P(-4,-14),P(4,-14),P(-14,-4),P(14,-4),P(-14,4),P(14,4),P(-4,14),P(4,14),P(-7,-13),P(7,-13),P(-13,-7),P(13,-7),P(-13,7),P(13,7),P(-7,13),P(7,13),P(-5,-14),P(5,-14),P(-10,-11),P(10,-11),P(-11,-10),P(11,-10),P(-14,-5),P(14,-5),P(-14,5),P(14,5),P(-11,10),P(11,10),P(-10,11),P(10,11),P(-5,14),P(5,14),P(0,-15),P(-9,-12),P(9,-12),P(-12,-9),P(12,-9),P(-15,0),P(15,0),P(-12,9),P(12,9),P(-9,12),P(9,12),P(0,15)
);
const int DEFAULT_PATCH_RADIUS = 15;
const int MIN_PATCH_RADIUS = 2;
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
int keypointIndex = thread.x + thread.y * outputSize().x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
vec2 m = vec2(0.0f);
float pot = exp2(keypoint.lod);
vec2 imageSize = vec2(textureSize(image, 0));
int scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));
int radius = max(scaledRadius, MIN_PATCH_RADIUS);
int count = diskPointCount[radius];
for(int j = 0; j < count; j++) {
vec2 offset = vec2(diskPoint[j]);
vec2 position = keypoint.position + round(pot * offset);
vec4 patchPixel = texture(image, (position + vec2(0.5f)) / imageSize);
m += offset * patchPixel.g;
}
float angle = fastAtan2(m.y, m.x);
float encodedOrientation = encodeKeypointOrientation(angle);
color = vec4(0.0f, encodedOrientation, 0.0f, 0.0f);
}`},9739:r=>{r.exports=`@include "keypoints.glsl"
@include "filters.glsl"
#if !defined(METHOD)
#error Undefined METHOD
#endif
uniform sampler2D pyramid;
uniform float lodStep;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#if METHOD == 1
uniform int threshold;
#endif
const float eps = 1e-6;
float cornerStrength(vec2 position, float lod)
{
#if METHOD == 0
return laplacian(pyramid, position, lod);
#elif METHOD == 1
float pot = exp2(lod);
float t = float(clamp(threshold, 0, 255)) / 255.0f;
#define P(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g
mat4 mp = mat4(
P(0,3),P(3,0),P(0,-3),P(-3,0),
P(1,3),P(2,2),P(3,1),P(3,-1),
P(2,-2),P(1,-3),P(-1,-3),P(-2,-2),
P(-3,-1),P(-3,1),P(-2,2),P(-1,3)
);
float c = P(0,0);
float ct = c + t, c_t = c - t;
mat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);
mat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;
const vec4 zeros = vec4(0.0f), ones = vec4(1.0f);
vec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);
bs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);
bs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);
bs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);
return max(dot(bs, ones), dot(ds, ones)) / 16.0f;
#else
#error Invalid method
#endif
}
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
color = pixel;
if(address.offset != 1)
return;
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
if(isBadKeypoint(keypoint))
return;
vec3 strength = vec3(
cornerStrength(keypoint.position, max(0.0f, keypoint.lod - lodStep)),
cornerStrength(keypoint.position, keypoint.lod),
cornerStrength(keypoint.position, keypoint.lod + lodStep)
);
vec3 p = mat3(
2, -3, 1,
-4, 4, 0,
2, -1, 0
) * strength;
float maxStrength = max(strength.x, max(strength.y, strength.z));
vec3 diffStrength = abs(strength - vec3(maxStrength));
vec3 strengthIndicators = vec3(lessThan(diffStrength, vec3(eps)));
float maxPoint = min(1.0f, dot(vec3(0.0f, 0.5f, 1.0f), strengthIndicators));
bool hasMax = p.x < -eps;
float pmax = hasMax ? -0.5f * p.y / p.x : maxPoint;
float alpha = abs(pmax - 0.5f) <= 0.5f ? pmax : maxPoint;
float lodOffset = mix(-lodStep, lodStep, alpha);
float lod = keypoint.lod + lodOffset;
color.r = encodeLod(lod);
}`},8231:r=>{r.exports=`@include "float16.glsl"
uniform sampler2D corners;
uniform int iterationNumber;
void main()
{
ivec2 thread = threadLocation();
ivec2 bounds = outputSize();
int jump = (1 << iterationNumber);
int clusterLength = jump << 1;
int clusterMask = clusterLength - 1;
ivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);
ivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);
ivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);
ivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);
vec4 p0 = threadPixel(corners);
vec4 p1 = texelFetch(corners, next1 % bounds, 0);
vec4 p2 = texelFetch(corners, next2 % bounds, 0);
vec4 p3 = texelFetch(corners, next3 % bounds, 0);
float s0 = decodeFloat16(p0.rb);
float s1 = decodeFloat16(p1.rb);
float s2 = decodeFloat16(p2.rb);
float s3 = decodeFloat16(p3.rb);
bool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;
bool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;
bool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;
color = vec4(0.0f);
color.rb = b0 ? p0.rb : (
b1 ? p1.rb : (
b2 ? p2.rb : p3.rb
)
);
}`},2518:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#if PERMUTATION_MAXLEN % 4 > 0 || PERMUTATION_MAXLEN * 4 > 16384
#error Invalid PERMUTATION_MAXLEN
#endif
layout(std140) uniform Permutation
{
ivec4 permutation[PERMUTATION_MAXLEN / 4];
};
int permutationElement(int index)
{
int base = index - (index % PERMUTATION_MAXLEN);
int offset = index - base;
ivec4 tuple = permutation[offset / 4];
int newOffset = tuple[offset & 3];
return base + newOffset;
}
void main()
{
ivec2 thread = threadLocation();
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
int otherIndex = permutationElement(myIndex);
KeypointAddress otherAddress = KeypointAddress(otherIndex * pixelsPerKeypoint, myAddress.offset);
Keypoint myKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);
Keypoint otherKeypoint = decodeKeypoint(encodedKeypoints, encoderLength, otherAddress);
color = readKeypointData(encodedKeypoints, encoderLength, otherAddress);
}`},8096:r=>{r.exports=`@include "keypoints.glsl"
#if !defined(STAGE)
#error Undefined STAGE
#elif STAGE == 1
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#elif STAGE == 2
uniform sampler2D permutation;
uniform int blockSize;
uniform int dblLog2BlockSize;
#elif STAGE == 3
uniform sampler2D permutation;
uniform int maxKeypoints;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
#else
#error Invalid STAGE
#endif
struct PermutationElement
{
int keypointIndex;
float score;
bool valid;
};
vec4 encodePermutationElement(PermutationElement element)
{
const vec2 ONES = vec2(1.0f);
vec2 encodedScore = element.valid ? encodeFloat16(element.score) : ONES;
vec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;
return vec4(encodedIndex, encodedScore);
}
PermutationElement decodePermutationElement(vec4 pixel)
{
const vec2 ONES = vec2(1.0f);
PermutationElement element;
element.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);
element.valid = !all(equal(pixel.ba, ONES));
element.score = element.valid ? decodeFloat16(pixel.ba) : -1.0f;
return element;
}
PermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)
{
const vec4 INVALID_PIXEL = vec4(1.0f);
ivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);
vec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;
return decodePermutationElement(pixel);
}
#if STAGE == 2
PermutationElement selectKth(sampler2D permutation, int k, int la, int ra, int lb, int rb)
{
float scoreA, scoreB;
int ha, hb, ma, mb;
bool discard1stHalf, altb;
bool locked = false;
int tmp, result = 0;
int stride = outputSize().x;
int height = outputSize().y;
for(int i = 0; i < dblLog2BlockSize; i++) {
tmp = (lb > rb && !locked) ? (la+k) : result;
result = (la > ra && !locked) ? (lb+k) : tmp;
locked = locked || (la > ra) || (lb > rb);
ha = (ra - la + 1) / 2;
hb = (rb - lb + 1) / 2;
ma = la + ha;
mb = lb + hb;
scoreA = readPermutationElement(permutation, ma, stride, height).score;
scoreB = readPermutationElement(permutation, mb, stride, height).score;
discard1stHalf = (k > ha + hb);
altb = (-scoreA < -scoreB);
k -= int(discard1stHalf && altb) * (ha + 1);
k -= int(discard1stHalf && !altb) * (hb + 1);
la += int(discard1stHalf && altb) * (ma + 1 - la);
lb += int(discard1stHalf && !altb) * (mb + 1 - lb);
ra += int(!discard1stHalf && !altb) * (ma - 1 - ra);
rb += int(!discard1stHalf && altb) * (mb - 1 - rb);
}
return readPermutationElement(permutation, result, stride, height);
}
#endif
void main()
{
#if STAGE == 1
ivec2 thread = threadLocation();
int stride = outputSize().x;
int keypointIndex = thread.y * stride + thread.x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
PermutationElement element;
element.keypointIndex = keypointIndex;
element.score = keypoint.score;
element.valid = !isBadKeypoint(keypoint);
color = encodePermutationElement(element);
#elif STAGE == 2
ivec2 thread = threadLocation();
int stride = outputSize().x;
int elementIndex = thread.y * stride + thread.x;
int blockIndex = elementIndex / blockSize;
int blockOffset = elementIndex % blockSize;
int la = blockIndex * blockSize;
int lb = la + blockSize / 2;
int ra = lb - 1;
int rb = (blockIndex + 1) * blockSize - 1;
int k = blockOffset;
PermutationElement element = selectKth(permutation, k, la, ra, lb, rb);
color = encodePermutationElement(element);
#elif STAGE == 3
ivec2 thread = threadLocation();
int newEncoderLength = outputSize().x;
KeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);
int myKeypointIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
ivec2 psize = textureSize(permutation, 0);
PermutationElement element = readPermutationElement(permutation, myKeypointIndex, psize.x, psize.y);
int oldEncoderLength = textureSize(encodedKeypoints, 0).x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(element.keypointIndex * pixelsPerKeypoint, myAddress.offset);
vec4 keypointData = readKeypointData(encodedKeypoints, oldEncoderLength, address);
color = myKeypointIndex < maxKeypoints && element.valid ? keypointData : encodeNullKeypoint();
#endif
}`},5795:r=>{r.exports=`@include "keypoints.glsl"
@include "float16.glsl"
#if !defined(METHOD)
#error Must define METHOD
#endif
uniform sampler2D pyramid;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
uniform int maxIterations;
uniform float epsilon;
const int PATCH_RADIUS = 1;
const int PATCH_SIZE = 2 * PATCH_RADIUS + 1;
const int PATCH_SIZE_SQUARED = PATCH_SIZE * PATCH_SIZE;
const int LARGE_PATCH_RADIUS = PATCH_RADIUS + 1;
const int LARGE_PATCH_SIZE = 2 * LARGE_PATCH_RADIUS + 1;
const int LARGE_PATCH_SIZE_SQUARED = LARGE_PATCH_SIZE * LARGE_PATCH_SIZE;
const int LARGER_PATCH_RADIUS = LARGE_PATCH_RADIUS + 1;
const int LARGER_PATCH_SIZE = 2 * LARGER_PATCH_RADIUS + 1;
const int LARGER_PATCH_SIZE_SQUARED = LARGER_PATCH_SIZE * LARGER_PATCH_SIZE;
const float EPS = 1e-5;
float smoothPixelBuffer[LARGER_PATCH_SIZE_SQUARED];
vec2 derivativesBuffer[LARGE_PATCH_SIZE_SQUARED];
float responseBuffer[PATCH_SIZE_SQUARED];
#define patchPixelAt(u,v) smoothPixelBuffer[((v) + LARGER_PATCH_RADIUS) * LARGER_PATCH_SIZE + ((u) + LARGER_PATCH_RADIUS)]
#define derivativesAt(u,v) derivativesBuffer[((v) + LARGE_PATCH_RADIUS) * LARGE_PATCH_SIZE + ((u) + LARGE_PATCH_RADIUS)]
#define responseAt(u,v) responseBuffer[((v) + PATCH_RADIUS) * PATCH_SIZE + ((u) + PATCH_RADIUS)]
void readPixels(vec2 center, float lod)
{
ivec2 pyrBaseSize = textureSize(pyramid, 0);
float pot = exp2(lod);
int u, v;
for(int j = 0; j < LARGER_PATCH_SIZE; j++) {
for(int i = 0; i < LARGER_PATCH_SIZE; i++) {
u = i - LARGER_PATCH_RADIUS;
v = j - LARGER_PATCH_RADIUS;
patchPixelAt(u,v) = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2(u,v), pyrBaseSize).g;
}
}
}
void computeDerivatives()
{
const mat3 dx = mat3(
-1, 0, 1,
-2, 0, 2,
-1, 0, 1
);
const mat3 dy = mat3(
1, 2, 1,
0, 0, 0,
-1,-2,-1
);
int u, v;
mat3 pix, convX, convY;
const vec3 ones = vec3(1.0f);
for(int j = 0; j < LARGE_PATCH_SIZE; j++) {
for(int i = 0; i < LARGE_PATCH_SIZE; i++) {
u = i - LARGE_PATCH_RADIUS;
v = j - LARGE_PATCH_RADIUS;
pix = mat3(
patchPixelAt(u+1,v+1), patchPixelAt(u+0,v+1), patchPixelAt(u-1,v+1),
patchPixelAt(u+1,v+0), patchPixelAt(u+0,v+0), patchPixelAt(u-1,v+0),
patchPixelAt(u+1,v-1), patchPixelAt(u+0,v-1), patchPixelAt(u-1,v-1)
);
convX = matrixCompMult(dx, pix);
convY = matrixCompMult(dy, pix);
derivativesAt(u,v) = vec2(
dot(ones, vec3(
dot(convX[0], ones),
dot(convX[1], ones),
dot(convX[2], ones)
)),
dot(ones, vec3(
dot(convY[0], ones),
dot(convY[1], ones),
dot(convY[2], ones)
))
);
}
}
}
vec2 computeResponseMap()
{
float patchArea = float(PATCH_SIZE * PATCH_SIZE);
vec3 h; vec2 d, c = vec2(0.0f);
const vec3 ones = vec3(1.0f);
float response, sum = 0.0f;
int u, v;
#define H(r,s) d = derivativesAt((r),(s)); h += vec3(d.x * d.x, d.x * d.y, d.y * d.y)
for(int j = 0; j < PATCH_SIZE; j++) {
for(int i = 0; i < PATCH_SIZE; i++) {
u = i - PATCH_RADIUS;
v = j - PATCH_RADIUS;
h = vec3(0.0f);
H(u-1,v-1); H(u+0,v-1); H(u+1,v-1);
H(u-1,v+0); H(u+0,v+0); H(u+1,v+0);
H(u-1,v+1); H(u+0,v+1); H(u+1,v+1);
response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));
response /= patchArea;
responseAt(u,v) = response;
c += vec2(u,v) * response;
sum += response;
}
}
return abs(sum) > EPS ? c / sum : vec2(0.0f);
}
#if METHOD == 0
vec2 quadratic1d()
{
float a = 0.5f * (responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0));
float b = 0.5f * (responseAt(1,0) - responseAt(-1,0));
float c = responseAt(0,0);
float d = 0.5f * (responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1));
float e = 0.5f * (responseAt(0,1) - responseAt(0,-1));
float f = responseAt(0,0);
bool hasMax = a < -EPS && d < -EPS;
return hasMax ? -0.5f * vec2(b / a, e / d) : vec2(0.0f);
}
#endif
#if METHOD == 1
vec2 taylor2d()
{
float dx = (-responseAt(-1,0) + responseAt(1,0)) * 0.5f;
float dy = (-responseAt(0,-1) + responseAt(0,1)) * 0.5f;
float dxx = responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0);
float dyy = responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1);
float dxy = (responseAt(-1,-1) + responseAt(1,1) - responseAt(1,-1) - responseAt(-1,1)) * 0.25f;
float det = dxx * dyy - dxy * dxy;
mat2 inv = mat2(dyy, -dxy, -dxy, dxx);
bool hasMax = det > EPS && dxx < 0.0f;
return hasMax ? inv * vec2(dx, dy) / (-det) : vec2(0.0f);
}
#endif
#if METHOD == 2
void bilinearUpsample(ivec2 patchOffset, vec4 pixelsOfPatch)
{
int u, v, i, j;
vec2 frc, ifrc; vec4 sub;
const vec4 ones = vec4(1.0f);
float s = 1.0f / float(PATCH_SIZE - 1);
int xoff = 2 * patchOffset.x;
int yoff = 2 * patchOffset.y;
for(j = 0; j < PATCH_SIZE; j++) {
for(i = 0; i < PATCH_SIZE; i++) {
u = i - PATCH_RADIUS;
v = j - PATCH_RADIUS;
frc = vec2(i, j) * s;
ifrc = vec2(1.0f) - frc;
sub = vec4(
ifrc.x * ifrc.y,
frc.x * ifrc.y,
ifrc.x * frc.y,
frc.x * frc.y
);
patchPixelAt(u+xoff,v+yoff) = dot(sub*pixelsOfPatch, ones);
}
}
}
#endif
#if METHOD == 3
void bicubicUpsample(ivec2 patchOffset, vec4 pixelsOfPatch, vec4 dx, vec4 dy, vec4 dxy)
{
float x, y, s = 1.0f / float(PATCH_SIZE - 1);
int u, v, i, j;
float f00 = pixelsOfPatch.x;
float f10 = pixelsOfPatch.y;
float f01 = pixelsOfPatch.z;
float f11 = pixelsOfPatch.w;
float fx00 = dx.x;
float fx10 = dx.y;
float fx01 = dx.z;
float fx11 = dx.w;
float fy00 = dy.x;
float fy10 = dy.y;
float fy01 = dy.z;
float fy11 = dy.w;
float fxy00 = dxy.x;
float fxy10 = dxy.y;
float fxy01 = dxy.z;
float fxy11 = dxy.w;
mat4 bicubic = mat4(
1, 0, -3, 2,
0, 0, 3, -2,
0, 1, -2, 1,
0, 0, -1, 1
) * mat4(
f00, f10, fx00, fx10,
f01, f11, fx01, fx11,
fy00, fy10, fxy00, fxy10,
fy01, fy11, fxy01, fxy11
) * mat4(
1, 0, 0, 0,
0, 0, 1, 0,
-3, 3, -2, -1,
2, -2, 1, 1
);
int xoff = 2 * patchOffset.x;
int yoff = 2 * patchOffset.y;
for(j = 0; j < PATCH_SIZE; j++) {
for(i = 0; i < PATCH_SIZE; i++) {
u = i - PATCH_RADIUS;
v = j - PATCH_RADIUS;
x = float(i) * s;
y = float(j) * s;
patchPixelAt(u+xoff,v+yoff) = dot(
vec4(1, x, x*x, x*x*x),
bicubic * vec4(1, y, y*y, y*y*y)
);
}
}
}
#endif
#if METHOD == 2 || METHOD == 3
void upsamplePatch(int left, int top, int right, int bottom)
{
int x, y, k;
vec4 ptch[9];
vec2 d00, d10, d01, d11;
for(k = 0; k < 9; k++) {
x = -1 + (k % 3);
y = -1 + (k / 3);
ptch[k] = vec4(
patchPixelAt(left+x, top+y),
patchPixelAt(right+x, top+y),
patchPixelAt(left+x, bottom+y),
patchPixelAt(right+x, bottom+y)
);
}
for(k = 0; k < 9; k++) {
x = -1 + (k % 3);
y = -1 + (k / 3);
#if METHOD == 2
bilinearUpsample(ivec2(x, y), ptch[k]);
#elif METHOD == 3
d00 = derivativesAt(left+x, top+y);
d10 = derivativesAt(right+x, top+y);
d01 = derivativesAt(left+x, bottom+y);
d11 = derivativesAt(right+x, bottom+y);
bicubicUpsample(ivec2(x, y), ptch[k],
vec4(d00.x, d10.x, d01.x, d11.x),
vec4(d00.y, d10.y, d01.y, d11.y),
0.25f * vec4(
(patchPixelAt(left+x + 1,top+y + 1) + patchPixelAt(left+x - 1, top+y - 1)) - (patchPixelAt(left+x + 1, top+y - 1) + patchPixelAt(left+x - 1, top+y + 1)),
(patchPixelAt(right+x + 1,top+y + 1) + patchPixelAt(right+x - 1, top+y - 1)) - (patchPixelAt(right+x + 1, top+y - 1) + patchPixelAt(right+x - 1, top+y + 1)),
(patchPixelAt(left+x + 1,bottom+y + 1) + patchPixelAt(left+x - 1, bottom+y - 1)) - (patchPixelAt(left+x + 1, bottom+y - 1) + patchPixelAt(left+x - 1, bottom+y + 1)),
(patchPixelAt(right+x + 1,bottom+y + 1) + patchPixelAt(right+x - 1, bottom+y - 1)) - (patchPixelAt(right+x + 1, bottom+y - 1) + patchPixelAt(right+x - 1, bottom+y + 1))
)
);
#endif
}
}
vec2 upsampleResponseMap(int left, int top, int right, int bottom)
{
upsamplePatch(left, top, right, bottom);
computeDerivatives();
return computeResponseMap();
}
vec2 iterativeUpsample(vec2 initialGuess)
{
int refine = 1;
float scale = 0.5f;
float eps2 = epsilon * epsilon;
vec2 guess = initialGuess, localGuess = initialGuess;
for(int k = 0; k < maxIterations; k++) {
ivec4 quad = ivec4(floor(localGuess.x), floor(localGuess.y), ceil(localGuess.x), ceil(localGuess.y));
vec2 response = (refine != 0) ? upsampleResponseMap(quad.x, quad.y, quad.z, quad.w) : vec2(0.0f);
localGuess = response * scale;
guess += localGuess;
scale *= 0.5f;
refine *= int(dot(localGuess, localGuess) >= eps2);
}
return guess;
}
#endif
void main()
{
ivec2 thread = threadLocation();
int keypointIndex = thread.x + thread.y * outputSize().x;
int pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;
KeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);
color = encodeNullPairOfFloat16();
if(isNullKeypoint(keypoint))
return;
color = encodeDiscardedPairOfFloat16();
if(isBadKeypoint(keypoint))
return;
readPixels(keypoint.position, keypoint.lod);
computeDerivatives();
vec2 offset = computeResponseMap();
#if METHOD == 0
offset = quadratic1d();
#elif METHOD == 1
offset = taylor2d();
#elif METHOD == 2 || METHOD == 3
offset = iterativeUpsample(offset);
#else
#error Unknown METHOD
#endif
float pot = exp2(keypoint.lod);
color = encodePairOfFloat16(offset * pot);
}`},3169:r=>{r.exports=`@include "keypoints.glsl"
@include "float16.glsl"
uniform sampler2D encodedFlow;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
int len = textureSize(encodedFlow, 0).x;
KeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);
int myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
color = pixel;
if(isBadKeypoint(keypoint))
return;
ivec2 location = ivec2(myIndex % len, myIndex / len);
vec4 encodedFlow = myIndex < len * len ? pixelAt(encodedFlow, location) : encodeDiscardedKeypoint();
bool discardFlow = isDiscardedPairOfFloat16(encodedFlow);
vec2 flow = !discardFlow ? decodePairOfFloat16(encodedFlow) : vec2(0.0f);
vec4 newPosition = encodeKeypointPosition(keypoint.position + flow);
vec4 newPixel = myAddress.offset == 0 ? newPosition : pixel;
color = !discardFlow ? newPixel : encodeDiscardedKeypoint();
}`},1337:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedOrientations;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
KeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
int orientationEncoderLength = textureSize(encodedOrientations, 0).x;
ivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);
vec4 targetPixel = pixelAt(encodedOrientations, location);
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);
bool isValid = !isBadKeypoint(keypoint);
float encodedOrientation = targetPixel.g;
color = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.ba) : pixel;
}`},6187:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedData;
uniform int strideOfEncodedData;
uniform sampler2D encodedKeypoints;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
vec4 readEncodedData(sampler2D encodedData, int strideOfEncodedData, int elementId, int pixelsPerElement, int pixelOffset)
{
int rasterIndex = elementId * pixelsPerElement + pixelOffset;
ivec2 pos = ivec2(rasterIndex % strideOfEncodedData, rasterIndex / strideOfEncodedData);
return texelFetch(encodedData, pos, 0);
}
void main()
{
ivec2 thread = threadLocation();
KeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);
int headerSize = sizeofEncodedKeypointHeader();
int extraCell = myAddress.offset - headerSize / 4;
int numberOfExtraCells = extraSize / 4;
color = threadPixel(encodedKeypoints);
if(extraCell < 0 || extraCell >= numberOfExtraCells)
return;
Keypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);
if(isBadKeypoint(keypoint))
return;
color = readEncodedData(encodedData, strideOfEncodedData, myIndex, numberOfExtraCells, extraCell);
}`},477:r=>{r.exports=`@include "keypoints.glsl"
uniform sampler2D encodedKeypoints;
uniform int startIndex;
uniform int endIndex;
uniform int descriptorSize;
uniform int extraSize;
uniform int encoderLength;
#ifndef BUFFER_SIZE
#error Undefined BUFFER_SIZE
#endif
layout(std140) uniform KeypointBuffer
{
vec4 keypointBuffer[BUFFER_SIZE];
};
void main()
{
vec4 pixel = threadPixel(encodedKeypoints);
ivec2 thread = threadLocation();
KeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);
int index = findKeypointIndex(address, descriptorSize, extraSize);
color = pixel;
if(index < startIndex)
return;
color = encodeNullKeypoint();
if(index >= endIndex)
return;
vec4 data = keypointBuffer[index - startIndex];
switch(address.offset) {
case 0: {
color = encodeKeypointPosition(data.xy);
break;
}
case 1: {
vec2 score = encodeKeypointScore(max(data.w, 0.0f));
float scale = encodeLod(data.z);
float rotation = encodeKeypointOrientation(0.0f);
color = vec4(scale, rotation, score);
break;
}
default: {
color = vec4(0.0f);
break;
}
}
}`},4050:r=>{r.exports=`uniform sampler2D image;
void main()
{
#if 1
color = texture(image, texCoord);
#else
ivec2 thread = threadLocation();
ivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));
color = pixelAt(image, pos);
#endif
}`},5545:r=>{r.exports=`uniform sampler2D image;
void main()
{
ivec2 thread = threadLocation();
vec4 pixel = pixelAt(image, thread / 2);
color = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);
}`},7113:r=>{r.exports=`@include "subpixel.glsl"
uniform sampler2D image0;
uniform sampler2D image1;
uniform float alpha;
uniform float beta;
uniform float gamma;
const vec4 BACKGROUND = vec4(0.0f);
void main()
{
ivec2 location = threadLocation();
ivec2 size0 = textureSize(image0, 0);
ivec2 size1 = textureSize(image1, 0);
vec4 pix0 = all(lessThan(location, size0)) ? pixelAt(image0, location) : BACKGROUND;
vec4 pix1 = all(lessThan(location, size1)) ? pixelAt(image1, location) : BACKGROUND;
vec4 pix = clamp(alpha * pix0 + beta * pix1 + vec4(gamma), 0.0f, 1.0f);
color = vec4(pix.rgb, 1.0f);
}`},1202:r=>{r.exports=`@include "subpixel.glsl"
uniform sampler2D image;
void main()
{
vec2 imageSize = vec2(textureSize(image, 0));
#if !defined(INTERPOLATION_METHOD)
#error Must define INTERPOLATION_METHOD
#elif INTERPOLATION_METHOD == 0
vec2 pos = texCoord * imageSize;
color = textureLod(image, (round(pos) + vec2(0.5f)) / imageSize, 0.0f);
#elif INTERPOLATION_METHOD == 1
color = subpixelAtBI(image, texCoord * imageSize);
#else
#error Invalid INTERPOLATION_METHOD
#endif
}`},7971:r=>{r.exports=`@include "subpixel.glsl"
uniform sampler2D image;
uniform mat3 inverseHomography;
const vec4 emptyColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);
vec2 perspectiveWarp(mat3 homography, vec2 p)
{
vec3 q = homography * vec3(p, 1.0f);
return q.xy / q.z;
}
void main()
{
ivec2 location = threadLocation();
ivec2 size = outputSize();
const vec2 zero = vec2(0.0f);
vec2 target = perspectiveWarp(inverseHomography, vec2(location));
bool withinBounds = all(bvec4(greaterThanEqual(target, zero), lessThan(target, vec2(size))));
color = withinBounds ? subpixelAtBI(image, target) : emptyColor;
}`},6122:r=>{r.exports=`@include "colors.glsl"
uniform sampler2D dest, src;
uniform int destComponents;
uniform int srcComponentId;
void main()
{
vec4 destPixel = threadPixel(dest);
vec4 srcPixel = threadPixel(src);
bvec4 flags = bvec4(
(destComponents & PIXELCOMPONENT_RED) != 0,
(destComponents & PIXELCOMPONENT_GREEN) != 0,
(destComponents & PIXELCOMPONENT_BLUE) != 0,
(destComponents & PIXELCOMPONENT_ALPHA) != 0
);
color = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);
}`},371:r=>{r.exports=`#if !defined(TYPE)
#error Undefined TYPE
#elif TYPE == 1
@include "keypoints.glsl"
#define nullPixel() encodeNullKeypoint()
#elif TYPE == 2
@include "float16.glsl"
#define nullPixel() encodeNullPairOfFloat16()
#else
#error Invalid TYPE
#endif
uniform sampler2D image;
void main()
{
ivec2 thread = threadLocation();
ivec2 imageSize = textureSize(image, 0);
int rasterIndex = thread.y * outputSize().x + thread.x;
bool isValidPixel = rasterIndex < imageSize.x * imageSize.y;
ivec2 pos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);
vec4 nullpix = nullPixel();
color = isValidPixel ? texelFetch(image, pos, 0) : nullpix;
}`},7307:r=>{r.exports=`uniform sampler2D image;
void main()
{
color = threadPixel(image);
}`},8614:r=>{r.exports=`@include "colors.glsl"
uniform sampler2D image;
uniform int pixelComponents;
uniform float value;
void main()
{
vec4 pixel = threadPixel(image);
bvec4 flags = bvec4(
(pixelComponents & PIXELCOMPONENT_RED) != 0,
(pixelComponents & PIXELCOMPONENT_GREEN) != 0,
(pixelComponents & PIXELCOMPONENT_BLUE) != 0,
(pixelComponents & PIXELCOMPONENT_ALPHA) != 0
);
color = mix(pixel, vec4(value), flags);
}`},6271:r=>{r.exports=`uniform float value;
void main()
{
color = vec4(value);
}`},3016:r=>{r.exports=`void vsmain()
{
gl_Position *= vec4(1,-1,1,1);
}`},3630:r=>{r.exports=`uniform sampler2D image;
uniform int iterationNumber;
void main()
{
ivec2 thread = threadLocation();
ivec2 last = outputSize() - ivec2(1);
int jump = (1 << iterationNumber);
int clusterLength = jump << 1;
int clusterMask = clusterLength - 1;
ivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);
ivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);
ivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);
ivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);
vec4 p0 = texelFetch(image, thread, 0);
vec4 p1 = texelFetch(image, min(next1, last), 0);
vec4 p2 = texelFetch(image, min(next2, last), 0);
vec4 p3 = texelFetch(image, min(next3, last), 0);
vec4 pmax = max(max(p0, p1), max(p2, p3));
vec4 pmin = min(min(p0, p1), min(p2, p3));
color = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);
}`},8508:r=>{r.exports=`@include "pyramids.glsl"
@include "float16.glsl"
uniform sampler2D pyramid;
uniform float lod;
#define USE_VARYINGS 1
in vec2 v_pix0, v_pix1, v_pix2,
v_pix3, v_pix4, v_pix5,
v_pix6, v_pix7, v_pix8;
const mat3 hkern = mat3(
1.0f, 0.0f,-1.0f,
2.0f, 0.0f,-2.0f,
1.0f, 0.0f,-1.0f
), vkern = mat3(
1.0f, 2.0f, 1.0f,
0.0f, 0.0f, 0.0f,
-1.0f,-2.0f,-1.0f
);
#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g
#define XIP(v) textureLod(pyramid, (v), lod).g
void main()
{
const vec3 ones = vec3(1.0f);
float pot = exp2(lod);
mat3 win = mat3(
#if USE_VARYINGS
XIP(v_pix0), XIP(v_pix1), XIP(v_pix2),
XIP(v_pix3), XIP(v_pix4), XIP(v_pix5),
XIP(v_pix6), XIP(v_pix7), XIP(v_pix8)
#else
PIX(-1,-1), PIX(0,-1), PIX(1,-1),
PIX(-1,0), PIX(0,0), PIX(1,0),
PIX(-1,1), PIX(0,1), PIX(1,1)
#endif
);
mat3 dx = matrixCompMult(hkern, win);
mat3 dy = matrixCompMult(vkern, win);
vec2 df = vec2(
dot(dx[0] + dx[1] + dx[2], ones),
dot(dy[0] + dy[1] + dy[2], ones)
);
color = encodePairOfFloat16(df);
}`},8073:r=>{r.exports=`uniform mediump float lod;
out vec2 v_pix0, v_pix1, v_pix2,
v_pix3, v_pix4, v_pix5,
v_pix6, v_pix7, v_pix8;
#define PIX(x,y) (texCoord + ((pot) * vec2((x),(y))) / texSize)
void vsmain()
{
float pot = exp2(lod);
v_pix0 = PIX(-1,-1); v_pix1 = PIX(0,-1); v_pix2 = PIX(1,-1);
v_pix3 = PIX(-1,0); v_pix4 = PIX(0,0); v_pix5 = PIX(1,0);
v_pix6 = PIX(-1,1); v_pix7 = PIX(0,1); v_pix8 = PIX(1,1);
}`},3575:r=>{r.exports=`AGFzbQEAAAABiwETYAABfmADf39/AX9gAX8AYAN/f38AYAF9AX9gAX8Bf2ACf38Bf2AFf39/f38B
f2AFf39/f38AYAZ/f39/f38Bf2AAAX9gAn99AX9gA39/fQF/YAJ/fwF9YAF/AX1gBH9/f38AYAR/
f39/AX9gEX98fHx8fHx8fHx8fHx8fHx8AGAHf39/f39/fQF/AjsEA2VudgZtZW1vcnkCAAIDZW52
BWZhdGFsAAIDZW52CGJ5dGVmaWxsAAMDZW52CmNvcHlXaXRoaW4AAwNAPwQFBgIGAQECBwgGAwAJ
AgYCBgYKBQUFCQsFBgEBDAEBBgYGAQEMAQ0OAwgPAxAIAwYBEQEBAQEBARIBEgEBDwQFAXABBQUG
CAF/AUHwmgQLB/QDHAZtYWxsb2MABARmcmVlAAYFc3JhbmQACgxNYXQzMl9jcmVhdGUAEA1NYXQz
Ml9kZXN0cm95ABcKTWF0MzJfZGF0YQAYDk1hdDMyX2RhdGFTaXplABkPTWF0MzJfdHJhbnNwb3Nl
AB0JTWF0MzJfYWRkAB4OTWF0MzJfc3VidHJhY3QAHwtNYXQzMl9zY2FsZQAgDk1hdDMyX2NvbXBt
dWx0ACEOTWF0MzJfbXVsdGlwbHkAIg5NYXQzMl9pbnZlcnNlMQAjDk1hdDMyX2ludmVyc2UyACQO
TWF0MzJfaW52ZXJzZTMAJQ1NYXQzMl9xcl9mdWxsACwQTWF0MzJfcXJfcmVkdWNlZAAvDE1hdDMy
X3FyX29scwAwEE1hdDMyX3FyX2ludmVyc2UAMxZNYXQzMl9ob21vZ3JhcGh5X25kbHQ0ADcVTWF0
MzJfaG9tb2dyYXBoeV9uZGx0ADgUTWF0MzJfYWZmaW5lX2RpcmVjdDMAOhNNYXQzMl9hZmZpbmVf
ZGlyZWN0ADsYTWF0MzJfcHJhbnNhY19ob21vZ3JhcGh5ADwUTWF0MzJfcHJhbnNhY19hZmZpbmUA
PhtNYXQzMl90cmFuc2Zvcm1fcGVyc3BlY3RpdmUAPxZNYXQzMl90cmFuc2Zvcm1fYWZmaW5lAEAJ
CgEAQQELBA8REz0Kh7oBPyMBAX8gALwiAUGAgID8B3FBgICA/AdGIAFB////A3FBAEdxC2kBAX9B
AEEAKALAmoCAAEEBajYCwJqAgABBAEEAKAK0moCAACIBQQdxIAFqIgEgAGo2ArSagIAAAkBB8JqE
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
oZlEje21oPfGsD5jDQAgHCAFoiIYIB8gA6KhIiIgFCAIoiAcIAaiIh6gIiOiIB4gHyAEoqEiHiAU
IAeiIBigIhiioSIkmUSN7bWg98awPmMNACAcmiIlIBShIiYgIqIgHyAcoSIiIBiioUQAAAAAAADw
PyAkoyIkoiEYICIgI6IgJiAeoqEgJKIhHgJAAkAgHSAgZEEBcw0AIBMgGCAEoiAeIAOiRAAAAAAA
APA/oKAiBKIgJaMhHSAcIR8MAQsgEyAYIAaiIB4gBaJEAAAAAAAA8D+goCIEoiAfmqMhHQsgFyAE
oiAfoyETAkACQCAhICWZZEEBcw0AIBogGCAGoiAeIAWiRAAAAAAAAPA/oKAiBKIgFJqjIQcMAQsg
GiAYIAiiIB4gB6JEAAAAAAAA8D+goCIEoiAcoyEHICUhFAsgGCAdmiABoiATIAKioSIXIAeioiAd
IBsgBKIgFKMiFKIgHiATIAeaIAGiIBQgAqKhIhyioqCgIBMgB6KhIBggHSAcoqKhIB4gFyAUoqKh
mUSN7bWg98awPmMNACALIA2hIhsgECAOoSIaoiAWIA8gDaEiH6KhIiCZRI3ttaD3xrA+Yw0AIBEh
BCARIQIgESEGIBEhDiARIQEgESEDIBEhBSARIQggGyAVIBmgIhWiIBYgCSALoSANIA+hoCIZoqFE
AAAAAAAA8D8gIKMiFqIiDSAMIAqhIBogGaIgHyAVoqEgFqIiFiAMoqAiDCAJoqIgCyAJoSAWIAui
oCILIBIgDSAQoqAiEKIgFiAPIAmhIA0gD6KgIg8gCqKioKAgDyAMoqEgDSALIAqioqEgFiAQIAmi
oqGZRI3ttaD3xrA+Yw0BIBYgF6IgDSAcoqBEAAAAAAAA8D+gIQUgGCAWIBOiIA0gFKKgoCEDIB4g
FiAdoiANIAeioKAhASAMIBeiIBAgHKKgIAqgIQ4gGCAKoiAMIBOiIBAgFKKgoCEGIB4gCqIgDCAd
oiAQIAeioKAhAiALIBeiIA8gHKKgIAmgIQQgGCAJoiALIBOiIA8gFKKgoCERIB4gCaIgCyAdoiAP
IAeioKAhCAwBCyARIQQgESECIBEhBiARIQ4gESEBIBEhAyARIQUgESEICyAAKAIAIicgCLY4AgAg
JyAAQRRqKAIAIihBAnRqIBG2OAIAICcgKEEDdGogBLY4AgAgJyAAKAIQIgBBAnRqIAK2OAIAICcg
ACAoaiIpQQJ0aiAGtjgCACAnIAAgKEEBdGpBAnRqIA62OAIAICcgAEEDdGogAbY4AgAgJyAoIABB
AXRqQQJ0aiADtjgCACAnIClBA3RqIAW2OAIAC7oHAhZ/Cn0CQAJAIAAoAghBA0cNACAAKAIMQQNH
DQAgASgCCEECRw0AIAEoAgwiA0EESA0AIAIoAghBAkcNACACKAIMIANGDQELQbKTgIAAEICAgIAA
IAEoAgwhAwsgA0EBdCIEQQgQkoCAgAAhBSAEQQEQkoCAgAAhBkEIQQEQkoCAgAAhBwJAIANBAUgN
ACAFQRRqKAIAIgRBDGwgBSgCECIIQQJ0IglqIQogBEEEdCAJaiELIARBFGwgCWohDCAEQRhsIg0g
CWohDiAEQRxsIg8gCWohECACKAIQQQJ0IREgASgCEEECdCESIAhBA3QhCCAGKAIQIglBA3QhEyAJ
QQJ0IRQgAkEUaigCAEECdCEVIAFBFGooAgBBAnQhFiAEQQN0IRcgBEECdCEYIAYoAgAhCSAFKAIA
IQQgAigCACECIAEoAgAhAQNAIAIgEWoqAgAhGSABIBJqKgIAIRogAioCACEbIAQgASoCACIcOAIA
IAQgGGogGjgCACAEIBdqQYCAgPwDNgIAIAQgCmogHDgCACAEIAtqIBo4AgAgBCAMakGAgID8AzYC
ACAEIA1qIBsgHIwiHJQ4AgAgBCAOaiAZIByUOAIAIAQgD2ogGyAajCIalDgCACAEIBBqIBkgGpQ4
AgAgCSAbOAIAIAkgFGogGTgCACACIBVqIQIgASAWaiEBIAQgCGohBCAJIBNqIQkgA0F/aiIDDQAL
CyAHIAUgBkEDELCAgIAAGgJAAkAgBygCACIEKgIAIhkgBCAHKAIQIglBBHRqKgIAIhqUIAQgCUEC
dGoqAgAiGyAEIAlBFGxqKgIAIhyUIAQgCUEYbGoqAgAiHZSSIAQgCUEDdGoqAgAiHiAEIAlBDGxq
KgIAIh+UIAQgCUEcbGoqAgAiIJSSIBsgH5STIBkgHJQgIJSTIB4gGpQgHZSTIiEQg4CAgAANAEMA
AIA/ISIgIYu7RI3ttaD3xrA+Y0EBcw0BC0EAKgKAiICAACIZIRsgGSEeIBkhHyAZIRogGSEcIBkh
HSAZISAgGSEiCyAAKAIAIgQgGTgCACAEIABBFGooAgAiCUECdGogGzgCACAEIAlBA3RqIB44AgAg
BCAAKAIQIgJBAnRqIB84AgAgBCACIAlqIgFBAnRqIBo4AgAgBCACIAlBAXRqQQJ0aiAcOAIAIAQg
AkEDdGogHTgCACAEIAkgAkEBdGpBAnRqICA4AgAgBCABQQN0aiAiOAIAIAcQl4CAgAAaIAYQl4CA
gAAaIAUQl4CAgAAaIAALnwgKAX8BfQF/An0Bfwp9AX8BfQN/AX0CQAJAIAAoAghBA0cNACAAKAIM
QQNHDQAgASgCCEECRw0AIAEoAgxBBEcNACACKAIIQQJHDQAgAigCDEEERg0BC0HZk4CAABCAgICA
AAsgACABKAIAIgMqAgAiBCAEIAMgAUEUaigCACIFQQJ0aioCACIGkiADIAVBA3RqKgIAIgeSIAMg
BUEDbCIIQQJ0aioCACIJkkMAAIA+lCIKkyIEQwAAAEEgAyAIIAEoAhAiAWpBAnRqKgIAIgsgCyAD
IAFBAnRqKgIAIgwgAyAFIAFqQQJ0aioCACINkiADIAVBAXQgAWpBAnRqKgIAIg6SkkMAAIA+lCIP
kyILIAuUIAkgCpMiCSAJlCAOIA+TIg4gDpQgByAKkyIHIAeUIA0gD5MiDSANlCAGIAqTIgYgBpQg
BCAElCAMIA+TIgwgDJSSkpKSkpKSlZEiBJS7IAwgBJS7IAYgBJS7IA0gBJS7IAcgBJS7IA4gBJS7
IAkgBJS7IAsgBJS7IAIoAgAiAyoCACILIAsgAyACQRRqKAIAIgVBAnRqKgIAIhCSIAMgBUEDdGoq
AgAiDJIgAyAFQQNsIghBAnRqKgIAIg2SQwAAgD6UIgmTIgtDAAAAQSADIAggAigCECIBakECdGoq
AgAiDiAOIAMgAUECdGoqAgAiESADIAUgAWpBAnRqKgIAIhKSIAMgBUEBdCABakECdGoqAgAiBpKS
QwAAgD6UIg6TIgcgB5QgDSAJkyINIA2UIAYgDpMiBiAGlCAMIAmTIgwgDJQgEiAOkyISIBKUIBAg
CZMiECAQlCALIAuUIBEgDpMiESARlJKSkpKSkpKVkSILlLsgESALlLsgECALlLsgEiALlLsgDCAL
lLsgBiALlLsgDSALlLsgByALlLsQtYCAgAAgACgCACIDIABBFGooAgAiBUEBdCICIAAoAhAiAUEB
dCIIakECdGoqAgAhECADIAggBWpBAnRqIggqAgAhByADIAIgAWpBAnRqIgIqAgAhESADIAVBA3Rq
IhMqAgAhFCADIAUgAWoiFUECdGoiFioCACEGIAMgBUECdGoiBSoCACEMIAMgAUECdGoiFyoCACES
IAMgBCAJIAMgAUEDdGoiASoCACINlCADKgIAIhhDAACAPyALlSILlJKUOAIAIBcgBCAOIA2UIBIg
C5SSlDgCACABIAQgDZQ4AgAgBSAEIAkgB5QgDCALlJKUOAIAIBYgBCAOIAeUIAYgC5SSlDgCACAI
IAQgB5Q4AgAgEyAUIAQgCiAYlCAPIAyUkpSTIAuUIAkgECAEIAogDZQgDyAHlJKUkyIHlJI4AgAg
AiARIAQgCiASlCAPIAaUkpSTIAuUIA4gB5SSOAIAIAMgFUEDdGogBzgCACAAC5sCAQZ/AkACQCAA
KAIIQQNHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMIgNBBEgNACACKAIIQQJHDQAgAigCDCAD
Rg0BC0GAlICAABCAgICAACABKAIMIQMLQQIgAxCSgICAACEEQQIgAxCSgICAACEFQQNBAxCSgICA
ACEGQQNBAxCSgICAACEHQQNBAxCSgICAACEIIAQgASAGQQNBAxCSgICAACIDEMGAgIAAIAUgAiAD
IAcQwYCAgAAgAyAIIAQgBRC2gICAACIBIAYQp4CAgAAaIAAgByADEKeAgIAAGiADEJeAgIAAGiAB
EJeAgIAAGiAHEJeAgIAAGiAGEJeAgIAAGiAFEJeAgIAAGiAEEJeAgIAAGiAAC/kFAhZ/Bn0CQAJA
IAAoAghBAkcNACAAKAIMQQNHDQAgASgCCEECRw0AIAEoAgwiA0EDSA0AIAIoAghBAkcNACACKAIM
IANGDQELQaeUgIAAEICAgIAAIAEoAgwhAwsgA0EBdCIEQQYQkoCAgAAhBSAEQQEQkoCAgAAhBkEG
QQEQkoCAgAAhBwJAIANBAUgNACAFQRRqKAIAIgRBDGwgBSgCECIIQQJ0IglqIQogBEEEdCAJaiEL
IARBFGwgCWohDCACKAIQQQJ0IQ0gASgCEEECdCEOIAhBA3QhDyAGKAIQIglBA3QhECAJQQJ0IREg
AkEUaigCAEECdCESIAFBFGooAgBBAnQhEyAEQQN0IRQgBEECdCEVIAYoAgAhCSAFKAIAIQQgAigC
ACECIAEoAgAhAQNAIAIgDWooAgAhFiABIA5qKAIAIQggAigCACEXIAQgASgCACIYNgIAIAQgFWog
CDYCACAEIBRqQYCAgPwDNgIAIAQgCmogGDYCACAEIAtqIAg2AgAgBCAMakGAgID8AzYCACAJIBc2
AgAgCSARaiAWNgIAIAIgEmohAiABIBNqIQEgBCAPaiEEIAkgEGohCSADQX9qIgMNAAsLIAcgBSAG
QQMQsICAgAAaAkACQCAHKAIAIgQqAgAiGSAEIAcoAhAiCUECdGoqAgAiGpIgBCAJQQN0aioCACIb
kiAEIAlBDGxqKgIAIhySIAQgCUEEdGoqAgAiHZIgBCAJQRRsaioCACIekhCDgICAAA0AIBkgHZQg
GiAclJOLu0SN7bWg98awPmNBAXMNAQtBACoCgIiAgAAiGSEaIBkhGyAZIRwgGSEdIBkhHgsgACgC
ACIEIBk4AgAgBCAAQRRqKAIAIglBAnRqIBo4AgAgBCAJQQN0aiAbOAIAIAQgACgCECICQQJ0aiAc
OAIAIAQgAiAJakECdGogHTgCACAEIAIgCUEBdGpBAnRqIB44AgAgBxCXgICAABogBhCXgICAABog
BRCXgICAABogAAvNBQMBfAJ/FXwCQAJAIAAoAghBAkcNACAAKAIMQQNHDQAgASgCCEECRw0AIAEo
AgxBA0cNACACKAIIQQJHDQAgAigCDEEDRg0BC0HKlICAABCAgICAAAtBACoCgIiAgAC7IQMCQAJA
IAEoAgAiBCABKAIQIgVBAnRqKgIAuyIGIAQgAUEUaigCACIBIAVqQQJ0aioCALsiB6EiCCAEIAFB
A3RqKgIAuyIJoiAHIAQgAUEBdCAFakECdGoqAgC7IgqhIgsgBCoCALsiDKIgCiAGoSINIAQgAUEC
dGoqAgC7Ig6ioKAiD5lEje21oPfGsD5jDQAgAigCACIEIAIoAhAiBUECdGoqAgC7IhAgBCACQRRq
KAIAIgEgBWpBAnRqKgIAuyIRoSAEIAFBA3RqKgIAuyISoiARIAQgAUEBdCAFakECdGoqAgC7IhOh
IAQqAgC7IhSiIBMgEKEgBCABQQJ0aioCALsiFaKgoJlEje21oPfGsD5jDQBEAAAAAAAA8D8gD6Mi
FiALIBSiIA0gFaKgIAggEqKgoiIPIBYgCSAOoSIXIBCiIAwgCaEiGCARoqAgDiAMoSIZIBOioKIi
GqIgFiAXIBSiIBggFaKgIBkgEqKgoiIXIBYgCyAQoiANIBGioCAIIBOioKIiCKKhmUSN7bWg98aw
PmNBAXNFDQAgFiAOIAqiIAcgCaKhIgMgEKIgBiAJoiAMIAqioSIKIBGioCAMIAeiIAYgDqKhIgcg
E6KgoiEGIBYgAyAUoiAKIBWioCAHIBKioKIhAwwBCyADIQ8gAyEXIAMhCCADIRogAyEGCyAAKAIA
IgQgD7Y4AgAgBCAAQRRqKAIAIgFBAnRqIBe2OAIAIAQgAUEDdGogA7Y4AgAgBCAAKAIQIgVBAnRq
IAi2OAIAIAQgBSABakECdGogGrY4AgAgBCAFIAFBAXRqQQJ0aiAGtjgCACAAC4EDAQl/AkACQCAA
KAIIQQJHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMIgNBA0gNACACKAIIQQJHDQAgAigCDCAD
Rg0BC0HtlICAABCAgICAACABKAIMIQMLQQIgAxCSgICAACEEQQIgAxCSgICAACEFQQNBAxCSgICA
ACEGQQNBAxCSgICAACEHQQNBAxCUgICAACEIEJaAgIAAIAhBAEEBQQBBAhCagICAACEJQQNBAxCS
gICAACEDQQNBAxCSgICAACEKEJaAgIAAIApBAEEBQQBBAhCagICAACELIAQgASAGIAMQwYCAgAAg
BSACIAMgBxDBgICAACAJIAQgBRC5gICAACEBIAMgCCAGEKeAgIAAGiAKIAcgAxCngICAABogACAL
EJWAgIAAGiALEJeAgIAAGiAKEJeAgIAAGiADEJeAgIAAGiABEJeAgIAAGiAIEJeAgIAAGiAHEJeA
gIAAGiAGEJeAgIAAGiAFEJeAgIAAGiAEEJeAgIAAGiAAC5kUAhx/DX0jgICAgABBEGsiBySAgICA
AAJAAkAgACgCCEEDRw0AIAAoAgxBA0cNACACKAIIQQJHDQAgAigCDCIIQQRIDQAgAygCCEECRw0A
IAMoAgwgCEcNAAJAIAFFDQAgASgCCEEBRw0BIAEoAgwgCEcNAQsgBEEBSA0AIAVBAUgNACAGQwAA
AABgDQELQZCVgIAAEICAgIAAIAIoAgwhCAsCQCABRQ0AIAFDAAAAABCbgICAABoLIAhBAnQiCUGy
lYCAABCFgICAACEKIAlB0ZWAgAAQhYCAgAAgCBCNgICAACILIAhBBBCOgICAACAIIARBAnQiDCAI
b2sgDGoiDUECdEHwlYCAABCFgICAACEOAkAgDUEBSA0AQQAhDyAIQQFIIRAgDiERA0ACQCAQDQBB
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
NgIACwv2EgMAQYAIC7ISAAD4f091dCBvZiBtZW1vcnkhAERvdWJsZSBmcmVlAEFzc2VydGlvbiBm
YWlsZWQgYXQgbWF0MzIuYzo2MQBPdXQgb2YgbWVtb3J5IGF0IG1hdDMyLmM6NjMAQXNzZXJ0aW9u
IGZhaWxlZCBhdCBtYXQzMi5jOjg0AE91dCBvZiBtZW1vcnkgYXQgbWF0MzIuYzo4NgBPdXQgb2Yg
bWVtb3J5IGF0IG1hdDMyLmM6ODkAT3V0IG9mIG1lbW9yeSBhdCBtYXQzMi5jOjEzNgAAAGANAAAB
AAAAAAAAAAAAAAABAAAAAQAAAAIAAABEb3VibGUgZnJlZSBhdCBtYXQzMi5jOjE0OQBBc3NlcnRp
b24gZmFpbGVkIGF0IG1hdDMyLmM6MTg0AEFzc2VydGlvbiBmYWlsZWQgYXQgbWF0MzIuYzoxODgA
QXNzZXJ0aW9uIGZhaWxlZCBhdCBtYXQzMi5jOjI3NQBEb3VibGUgZnJlZSBhdCBtYXQzMi5jOjI5
AEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMyLmM6MzYAQXNzZXJ0aW9uIGZhaWxlZCBh
dCBhcml0aG1ldGljMzIuYzo1OABBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjgw
AEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMyLmM6OTkAQXNzZXJ0aW9uIGZhaWxlZCBh
dCBhcml0aG1ldGljMzIuYzoxMjEAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzox
NDMAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzoxNjgAQXNzZXJ0aW9uIGZhaWxl
ZCBhdCBhcml0aG1ldGljMzIuYzoxODkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIu
YzoyMTgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzoyNzEAQXNzZXJ0aW9uIGZh
aWxlZCBhdCBhcml0aG1ldGljMzIuYzozMjIAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGlj
MzIuYzozNTYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzozNzgAQXNzZXJ0aW9u
IGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzo0MjAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1l
dGljMzIuYzo0MzYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6MjYxAEFzc2VydGlvbiBmYWls
ZWQgYXQgcXIzMi5jOjI2NQBBc3NlcnRpb24gZmFpbGVkIGF0IHFyMzIuYzoyODYAQXNzZXJ0aW9u
IGZhaWxlZCBhdCBxcjMyLmM6MjkwAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjMyMQBBc3Nl
cnRpb24gZmFpbGVkIGF0IHFyMzIuYzozMjUAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6Mzc5
AE91dCBvZiBtZW1vcnkgYXQgcXIzMi5jOjM2AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjY5
AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjczAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5j
OjE4NABEb3VibGUgZnJlZSBhdCBxcjMyLmM6NTUAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6
MTQ4AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjIyNABBc3NlcnRpb24gZmFpbGVkIGF0IHFy
MzIuYzoyMjgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzoyNDQAQXNzZXJ0aW9u
IGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzoyODAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3Jh
cGh5MzIuYzozNTkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBob21vZ3JhcGh5MzIuYzo0NDQAQXNzZXJ0
aW9uIGZhaWxlZCBhdCBhZmZpbmUzMi5jOjExOQBBc3NlcnRpb24gZmFpbGVkIGF0IGFmZmluZTMy
LmM6MTk2AEFzc2VydGlvbiBmYWlsZWQgYXQgYWZmaW5lMzIuYzoyMjkAQXNzZXJ0aW9uIGZhaWxl
ZCBhdCByYW5zYWMzMi5jOjcxAE91dCBvZiBtZW1vcnkgYXQgcmFuc2FjMzIuYzo4NABPdXQgb2Yg
bWVtb3J5IGF0IHJhbnNhYzMyLmM6ODgAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjkzAE91
dCBvZiBtZW1vcnkgYXQgcmFuc2FjMzIuYzoxMDcARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoy
MzYARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoyNDMARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIu
YzoyNDYARG91YmxlIGZyZWUgYXQgcmFuc2FjMzIuYzoyNDkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBy
YW5zYWMzMi5jOjI3NQBPdXQgb2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6Mjg4AE91dCBvZiBtZW1v
cnkgYXQgcmFuc2FjMzIuYzoyOTIAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjI5NwBPdXQg
b2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6MzExAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDM2
AERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDQzAERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6
NDQ2AERvdWJsZSBmcmVlIGF0IHJhbnNhYzMyLmM6NDQ5AEFzc2VydGlvbiBmYWlsZWQgYXQgdHJh
bnNmb3JtMzIuYzozOQBBc3NlcnRpb24gZmFpbGVkIGF0IHRyYW5zZm9ybTMyLmM6NzcAQXNzZXJ0
aW9uIGZhaWxlZCBhdCB0cmFuc2Zvcm0zMi5jOjExNAAAQbQaCwwIAAAAUA0AAAEAAAAAQcAaCyQA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
`}},t={};function n(r){var s=t[r];if(s!==void 0)return s.exports;var d=t[r]={exports:{}};return y[r](d,d.exports,n),d.exports}n.d=(r,s)=>{for(var d in s)n.o(s,d)&&!n.o(r,d)&&Object.defineProperty(r,d,{enumerable:!0,get:s[d]})},n.o=(r,s)=>Object.prototype.hasOwnProperty.call(r,s),n.r=r=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})};var o={};return(()=>{"use strict";n.d(o,{default:()=>zr});var r=n(1001),s=n(9037),d=n(2199),c=n(9192);let u=[],g=[],f="asap"+Math.random().toString(36).substr(1);window.addEventListener("message",C=>{if(C.source!==window||C.data!==f||(C.stopPropagation(),u.length==0))return;let e=u.pop(),i=g.pop();e.apply(void 0,i)},!0);function b(C,...e){u.unshift(C),g.unshift(e),window.postMessage(f,"*")}var A=n(8581);let _=2,m=navigator.userAgent.includes("Firefox")?(C,...e)=>setTimeout(C,10,...e):(C,...e)=>requestAnimationFrame(()=>C.apply(void 0,e));class x{constructor(e=_){s.A.assert(e>0),this._initialized=!1,this._pixelBuffer=new Array(e).fill(null).map(()=>new Uint8Array(0)),this._pbo=new Array(e).fill(null),this._consumerIndex=0,this._producerIndex=e-1,this._promise=Array.from({length:e},()=>c.i.resolve()),this._busy=new Array(e).fill(!1),this._ready=new Array(e).fill(!0)}init(e){this._allocatePBOs(e),e.subscribe(this._allocatePBOs,this,e),this._initialized=!0}release(e){return e.unsubscribe(this._allocatePBOs,this),this._deallocatePBOs(e),this._initialized=!1,null}readPixelsSync(e,i=0,a=0,l=e.width,p=e.height){s.A.assert(this._initialized);let h=e.gl,I=e.glFbo;l=Math.max(0,Math.min(l,e.width)),p=Math.max(0,Math.min(p,e.height)),i=Math.max(0,Math.min(i,e.width-l)),a=Math.max(0,Math.min(a,e.height-p));let P=l*p*4;return this._reallocate(P),h.isContextLost()?this._pixelBuffer[0].subarray(0,P):(h.bindFramebuffer(h.FRAMEBUFFER,I),h.readPixels(i,a,l,p,h.RGBA,h.UNSIGNED_BYTE,this._pixelBuffer[0]),h.bindFramebuffer(h.FRAMEBUFFER,null),this._pixelBuffer[0].subarray(0,P))}readPixelsAsync(e,i=0,a=0,l=e.width,p=e.height,h=!1){s.A.assert(this._initialized);let I=e.gl,P=e.glFbo;l=Math.max(0,Math.min(l,e.width)),p=Math.max(0,Math.min(p,e.height)),i=Math.max(0,Math.min(i,e.width-l)),a=Math.max(0,Math.min(a,e.height-p));let v=l*p*4;if(this._reallocate(v),I.isContextLost())return c.i.resolve(this._pixelBuffer[0].subarray(0,v));if(!h){let K=this._pixelBuffer[0].subarray(0,v);return x._readPixelsViaPBO(I,this._pbo[0],K,P,i,a,l,p).then(()=>K)}let T=this._pixelBuffer.length,N=this._producerIndex;if(!this._busy[N]){let K=this._pbo[N],H=this._pixelBuffer[N].subarray(0,v);this._producerIndex=(N+1)%T,this._ready[N]=!1,this._busy[N]=!0,this._promise[N]=x._readPixelsViaPBO(I,K,H,P,i,a,l,p).then(()=>{this._busy[N]=!1,this._ready[N]=!0})}let k=this._consumerIndex;return this._consumerIndex=(k+1)%T,this._ready[k]?(this._ready[k]=!1,c.i.resolve(this._pixelBuffer[k])):this._promise[k].then(()=>(this._ready[k]=!1,this._pixelBuffer[k]))}_reallocate(e){if(!(e<=this._pixelBuffer[0].byteLength))for(let i=0;i<this._pixelBuffer.length;i++){let a=new Uint8Array(e);this._pixelBuffer[i]=a}}_allocatePBOs(e){let i=e.gl;for(let a=0;a<this._pbo.length;a++)this._pbo[a]=i.createBuffer()}_deallocatePBOs(e){let i=e.gl;for(let a=this._pbo.length-1;a>=0;a--)i.deleteBuffer(this._pbo[a]),this._pbo[a]=null}static _readPixelsViaPBO(e,i,a,l,p,h,I,P){let v=I*P*4;s.A.assert(a.byteLength>=v,"Invalid buffer size"),e.bindBuffer(e.PIXEL_PACK_BUFFER,i),e.bufferData(e.PIXEL_PACK_BUFFER,v,e.DYNAMIC_READ),e.bindFramebuffer(e.FRAMEBUFFER,l),e.readPixels(p,h,I,P,e.RGBA,e.UNSIGNED_BYTE,0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindBuffer(e.PIXEL_PACK_BUFFER,null);let T=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),new c.i((N,k)=>{d.w.gpuPollingMode!="asap"?m(x._clientWaitAsync,e,T,0,N,k):b(x._clientWaitAsync,e,T,0,N,k)}).then(()=>{e.bindBuffer(e.PIXEL_PACK_BUFFER,i),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,a),e.bindBuffer(e.PIXEL_PACK_BUFFER,null)}).catch(N=>{throw new A.Er("Can't getBufferSubDataAsync(): error in clientWaitAsync()",N)}).finally(()=>{e.deleteSync(T)})}static _clientWaitAsync(e,i,a,l,p,h=10,I=1e3){(function P(){let v=e.clientWaitSync(i,a,0);I--<=0?p(new A.MU("GPU polling timeout",A.wB.from(e))):v===e.CONDITION_SATISFIED||v===e.ALREADY_SIGNALED?l():d.w.gpuPollingMode!="asap"?requestAnimationFrame(P):b(P)})()}}var E=n(3816);class w{constructor(e,i,a,l=e.RGBA,p=e.RGBA8,h=e.UNSIGNED_BYTE,I=e.NEAREST,P=e.MIRRORED_REPEAT){this._gl=e,this._width=Math.max(1,i|0),this._height=Math.max(1,a|0),this._hasMipmaps=!1,this._format=l,this._internalFormat=p,this._dataType=h,this._filter=I,this._wrap=P,this._glTexture=w._createTexture(this._gl,this._width,this._height,this._format,this._internalFormat,this._dataType,this._filter,this._wrap)}release(){let e=this._gl;if(this._glTexture==null)throw new A.Er("The SpeedyTexture has already been released");return this.discardMipmaps(),e.deleteTexture(this._glTexture),this._glTexture=null,this._width=this._height=0,null}upload(e,i=this._width,a=this._height){let l=this._gl;return e instanceof HTMLVideoElement&&e.readyState<2?this:(s.A.assert(i>0&&a>0),this.discardMipmaps(),this._width=i,this._height=a,this._internalFormat=l.RGBA8,this._format=l.RGBA,this._dataType=l.UNSIGNED_BYTE,w._upload(l,this._glTexture,this._width,this._height,e,0,this._format,this._internalFormat,this._dataType),this)}clear(){let e=this._gl;return e.isContextLost()?this:(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texImage2D(e.TEXTURE_2D,0,this._internalFormat,this._width,this._height,0,this._format,this._dataType,null),e.bindTexture(e.TEXTURE_2D,null),this.discardMipmaps(),this)}resize(e,i){let a=this._gl;if(this._width===e&&this._height===i)return this;if(e|=0,i|=0,e>E.MAX_TEXTURE_LENGTH||i>E.MAX_TEXTURE_LENGTH)throw new A.EM(`Maximum texture size exceeded. Using ${e} x ${i}, expected up to ${E.MAX_TEXTURE_LENGTH} x ${E.MAX_TEXTURE_LENGTH}.`);if(e<1||i<1)throw new A.qw(`Invalid texture size: ${e} x ${i}`);return a.isContextLost()?this:(this._width=e,this._height=i,a.bindTexture(a.TEXTURE_2D,this._glTexture),a.texImage2D(a.TEXTURE_2D,0,this._internalFormat,this._width,this._height,0,this._format,this._dataType,null),a.bindTexture(a.TEXTURE_2D,null),this.discardMipmaps(),this)}generateMipmaps(e=[]){let i=this._gl;if(this._hasMipmaps)return this;if(i.bindTexture(i.TEXTURE_2D,this._glTexture),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST_MIPMAP_LINEAR),i.generateMipmap(i.TEXTURE_2D),i.bindTexture(i.TEXTURE_2D,null),e.length>0){let a=this.width,l=this.height,p=1+Math.floor(Math.log2(Math.max(a,l)));s.A.assert(e.length<=p);for(let h=1;h<e.length;h++){let I=Math.max(1,a>>>h),P=Math.max(1,l>>>h);s.A.assert(e[h].width===I&&e[h].height===P),e[h].copyTo(this,h)}}return this._hasMipmaps=!0,this}discardMipmaps(){let e=this._gl;this._hasMipmaps&&(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,this._filter),e.bindTexture(e.TEXTURE_2D,null),this._hasMipmaps=!1)}hasMipmaps(){return this._hasMipmaps}isReleased(){return this._glTexture==null}get glTexture(){return this._glTexture}get width(){return this._width}get height(){return this._height}get gl(){return this._gl}static _createTexture(e,i,a,l,p,h,I,P){s.A.assert(i>0&&a>0);let v=e.createTexture();return e.bindTexture(e.TEXTURE_2D,v),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,I),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,I),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,P),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,P),e.texImage2D(e.TEXTURE_2D,0,p,i,a,0,l,h,null),e.bindTexture(e.TEXTURE_2D,null),v}static _upload(e,i,a,l,p,h,I,P,v){return e.bindTexture(e.TEXTURE_2D,i),e.texImage2D(e.TEXTURE_2D,h,P,a,l,0,I,v,p),e.bindTexture(e.TEXTURE_2D,null),i}}class M extends w{constructor(e,i,a,l=void 0,p=void 0,h=void 0,I=void 0,P=void 0){super(e,i,a,l,p,h,I,P),this._glFbo=M._createFramebuffer(e,this._glTexture)}release(){let e=this._gl;if(this._glFbo==null)throw new A.Er("The SpeedyDrawableTexture has already been released");return e.deleteFramebuffer(this._glFbo),this._glFbo=null,super.release()}get glFbo(){return this._glFbo}copyTo(e,i=0){let a=this._gl;if(a.isContextLost())return;let l=1<<(i|=0),p=Math.max(1,Math.floor(e.width/l)),h=Math.max(1,Math.floor(e.height/l));s.A.assert(this._width===p&&this._height===h),M._copyToTexture(a,this._glFbo,e.glTexture,0,0,this._width,this._height,i)}clear(){return this.clearToColor(0,0,0,0)}clearToColor(e,i,a,l){let p=this._gl;return p.isContextLost()?this:(e=Math.max(0,Math.min(+e,1)),i=Math.max(0,Math.min(+i,1)),a=Math.max(0,Math.min(+a,1)),l=Math.max(0,Math.min(+l,1)),this.discardMipmaps(),p.bindFramebuffer(p.FRAMEBUFFER,this._glFbo),p.viewport(0,0,this._width,this._height),p.clearColor(e,i,a,l),p.clear(p.COLOR_BUFFER_BIT),p.bindFramebuffer(p.FRAMEBUFFER,null),this)}inspect(e,i){if(i===void 0){i=new x,i.init(e);let a=i.readPixelsSync(this);return i.release(e),new Uint8Array(a)}else{let a=i.readPixelsSync(this);return new Uint8Array(a)}}inspect32(e,i){return s.A.assert(E.LITTLE_ENDIAN),new Uint32Array(this.inspect(e,i).buffer)}static _createFramebuffer(e,i){let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,i,0);let l=e.checkFramebufferStatus(e.FRAMEBUFFER);if(l!=e.FRAMEBUFFER_COMPLETE){let p=["FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"].filter(h=>e[h]===l)[0]||"unknown error";throw new A.wB(`Can't create framebuffer: ${p} (${l})`)}return e.bindFramebuffer(e.FRAMEBUFFER,null),a}static _copyToTexture(e,i,a,l,p,h,I,P=0){return e.bindTexture(e.TEXTURE_2D,a),e.bindFramebuffer(e.FRAMEBUFFER,i),e.copyTexSubImage2D(e.TEXTURE_2D,P,0,0,l,p,h,I),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a}}var S=n(9420);let D=Object.freeze({sampler2D:"uniform1i",isampler2D:"uniform1i",usampler2D:"uniform1i",float:"uniform1f",int:"uniform1i",uint:"uniform1ui",bool:"uniform1i",vec2:"uniform2f",vec3:"uniform3f",vec4:"uniform4f",ivec2:"uniform2i",ivec3:"uniform3i",ivec4:"uniform4i",uvec2:"uniform2ui",uvec3:"uniform3ui",uvec4:"uniform4ui",bvec2:"uniform2i",bvec3:"uniform3i",bvec4:"uniform4i",mat2:"uniformMatrix2fv",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"});class B extends Function{constructor(e,i,a={}){return super("...args","return this._self._call(...args)"),this._self=this.bind(this),this._self._init(e,i,a),this._self}_init(e,i,a){if(e.isContextLost())throw new A.Er("Can't initialize SpeedyProgram: lost context");a=Object.assign({renderToTexture:!0,pingpong:!1},a),this._gl=e,this._program=B._compile(e,i.vertexSource,i.fragmentSource),this._geometry=new Q(e,{position:i.locationOfAttributes.position,texCoord:i.locationOfAttributes.texCoord}),this._argnames=i.arguments,this._argIsArray=new Array(this._argnames.length).fill(!1),this._ubo=null,this._renderToTexture=!!a.renderToTexture,this._width=1,this._height=1,this._size=[1,1],this._texture=new Array(a.pingpong?2:1).fill(null),this._textureIndex=0,this._uniform=new Map,this._shaderdecl=i,e.useProgram(this._program);for(let l of i.uniforms){let p=i.uniformType(l),h=e.getUniformLocation(this._program,l);this._uniform.set(l,new U(p,h))}for(let l=0;l<this._argnames.length;l++){let p=this._argnames[l];if(!this._uniform.has(p)&&(this._argIsArray[l]=this._uniform.has(R(p,0)),!this._argIsArray[l]))throw new A.Er(`Expected uniform "${p}", as declared in the argument list`)}}_call(...e){let i=this._gl,a=this._argnames,l=this._texture[this._textureIndex];if(e.length!=a.length)throw new A.qw(`Can't run shader: incorrect number of arguments (expected ${a.length}, got ${e.length})`);for(let I=e.length-1;I>=0;I--)if(e[I]===l)throw new A.EM("Can't run shader: don't use its output texture as an input to itself. Consider using pingpong rendering!");if(i.isContextLost())return l;i.useProgram(this._program),i.bindVertexArray(this._geometry.vao);let p=this._renderToTexture?l.glFbo:null,h=this._uniform.get("texSize");this._size[0]=this._width,this._size[1]=this._height,h.setValue(i,this._size);for(let I=0,P=0;I<e.length;I++){let v=a[I];if(!this._argIsArray[I])P=this._uniform.get(v).setValue(i,e[I],P);else{let T=e[I];if(Array.isArray(T)){if(this._uniform.has(R(v,T.length)))throw new A.qw(`Can't run shader: too few elements in the "${v}" array`);for(let N=0,k=void 0;(k=this._uniform.get(R(v,N)))!==void 0;N++)P=k.setValue(i,T[N],P)}else throw new A.qw(`Can't run shader: expected an array for "${v}"`)}}return this._ubo!==null&&this._ubo.update(),i.bindFramebuffer(i.FRAMEBUFFER,p),i.viewport(0,0,this._width,this._height),i.drawArrays(i.TRIANGLES,0,6),i.bindFramebuffer(i.FRAMEBUFFER,null),i.bindVertexArray(null),l?.discardMipmaps(),this._pingpong(),l}outputs(e,i,...a){return this._setOutputTexture(...a),this._setOutputSize(e,i),this}_setOutputSize(e,i){s.A.assert(e>0&&i>0),this._width=e|0,this._height=i|0;for(let a=0;a<this._texture.length;a++)this._texture[a]!=null&&this._texture[a].resize(this._width,this._height);return this}_setOutputTexture(...e){s.A.assert(e.length===this._texture.length,`Incorrect number of textures (expected ${this._texture.length})`);for(let i=0;i<this._texture.length;i++)this._texture[i]=e[i];return this._textureIndex=0,this}clear(){let e=this._texture[this._textureIndex];for(let i=0;i<this._texture.length;i++)this._texture[i].clear();return this._pingpong(),e}setUBO(e,i){return this._ubo===null&&(this._ubo=new O(this._gl,this._program)),this._ubo.set(e,i),this}release(){let e=this._gl;return this._ubo!=null&&(this._ubo=this._ubo.release()),this._texture.fill(null),this._geometry=this._geometry.release(),e.deleteProgram(this._program),this._program=null,null}definedConstant(e){return this._shaderdecl.definedConstant(e)}_pingpong(){this._texture.length>1&&(this._textureIndex=1-this._textureIndex)}static _compile(e,i,a){let l=e.createProgram(),p=e.createShader(e.VERTEX_SHADER),h=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(p,i),e.compileShader(p),e.attachShader(l,p),e.shaderSource(h,a),e.compileShader(h),e.attachShader(l,h),e.linkProgram(l),e.validateProgram(l),e.getProgramParameter(l,e.LINK_STATUS))return l;let I=[e.getShaderInfoLog(h),e.getShaderInfoLog(p),e.getProgramInfoLog(l)];e.deleteProgram(l),e.deleteShader(h),e.deleteShader(p);let P=k=>Math.max(0,2-Math.floor(Math.log10(k))),v=k=>new Array(P(k)).fill(" ").join("")+k+". ",N=(I[0]?a:i).split(`
`).map((k,K)=>v(1+K)+k).join(`
`);throw new A.wB(`

---------- ERROR ----------

`+I.filter(k=>k).join(`
`)+`

---------- SOURCE CODE ----------

`+N+`
`)}}function Q(C,e){return this.vao=C.createVertexArray(),this.vbo=Object.freeze({position:C.createBuffer(),texCoord:C.createBuffer()}),this._gl=C,C.bindVertexArray(this.vao),C.bindBuffer(C.ARRAY_BUFFER,this.vbo.position),C.bufferData(C.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),C.STATIC_DRAW),C.enableVertexAttribArray(e.position),C.vertexAttribPointer(e.position,2,C.FLOAT,!1,0,0),C.bindBuffer(C.ARRAY_BUFFER,this.vbo.texCoord),C.bufferData(C.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),C.STATIC_DRAW),C.enableVertexAttribArray(e.texCoord),C.vertexAttribPointer(e.texCoord,2,C.FLOAT,!1,0,0),C.bindBuffer(C.ARRAY_BUFFER,null),C.bindVertexArray(null),Object.freeze(this)}Q.prototype.release=function(){let C=this._gl;return C.deleteVertexArray(this.vao),C.deleteBuffer(this.vbo.position),C.deleteBuffer(this.vbo.texCoord),null};function U(C,e){if(this.type=String(C),!Object.prototype.hasOwnProperty.call(D,this.type))throw new A.EM(`Unsupported uniform type: ${this.type}`);this.location=e,this.setter=D[this.type];let i=Number(this.setter.match(/^uniform(Matrix)?(\d)/)[2])|0;this.dim=this.type.startsWith("mat")?2:this.type.indexOf("vec")>=0?1:0,this.length=this.dim==2?i*i:i,this._value=null}U.prototype.setValue=function(C,e,i=-1){let a=C[this.setter];if(typeof e=="object"&&this.type.endsWith("sampler2D")){if(i>=C.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw new A.EM(`Can't activate texture unit ${i}: max is ${C.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);if(Array.isArray(e))throw new A.EM("Can't pass arrays of textures to shaders");if(e==null)throw new A.qw(`Can't run shader: cannot use ${e} as an input texture`);if(i<0)throw new A.qw("Missing texNo");let l=e;C.activeTexture(C.TEXTURE0+i),C.bindTexture(C.TEXTURE_2D,l.glTexture),C.uniform1i(this.location,i),i++}else if(!(e===this._value&&typeof e!="object"))if(typeof e=="number"||typeof e=="boolean")a.call(C,this.location,e);else if(Array.isArray(e))if(e.length===this.length)this.dim==2?a.call(C,this.location,!1,e):a.call(C,this.location,...e);else throw new A.qw(`Can't run shader: incorrect number of values for ${this.type}: "${e}"`);else throw new A.qw(`Can't run shader: unrecognized argument "${e}"`);return this._value=e,i};function O(C,e){this._gl=C,this._program=e,this._nextIndex=0,this._ubo=Object.create(null)}O.prototype.set=function(C,e){let i=this._gl;this._ubo[C]===void 0&&(this._ubo[C]={buffer:i.createBuffer(),blockBindingIndex:this._nextIndex++,blockIndex:-1,data:null});let a=this._ubo[C];if(a.blockIndex<0){let l=i.getUniformBlockIndex(this._program,C);i.uniformBlockBinding(this._program,l,a.blockBindingIndex),a.blockIndex=l}a.data=e},O.prototype.update=function(){let C=this._gl;for(let e in this._ubo){let i=this._ubo[e];C.bindBuffer(C.UNIFORM_BUFFER,i.buffer),C.bufferData(C.UNIFORM_BUFFER,i.data,C.DYNAMIC_DRAW),C.bindBufferBase(C.UNIFORM_BUFFER,i.blockBindingIndex,i.buffer),C.bindBuffer(C.UNIFORM_BUFFER,null)}},O.prototype.release=function(){let C=this._gl;for(let e in this._ubo){let i=this._ubo[e];C.deleteBuffer(i.buffer),i.data=null}return null};function R(C,e){let i=R.cache,a=i.get(C);return a===void 0&&i.set(C,a=[]),a[e]===void 0&&(a[e]=`${C}[${e}]`),a[e]}R.cache=new Map;let F=Object.freeze({usesPingpongRendering(){return{pingpong:!0}},rendersToCanvas(){return{renderToTexture:!1}}});class q{constructor(e){this._gpu=e,this._programs=[]}declare(e,i,a={}){return Object.defineProperty(this,e,{get:(()=>{let l=Symbol(e);return()=>this[l]||(this[l]=this._createProgram(i.build(),a))})()}),this}get program(){return F}release(){for(let e=0;e<this._programs.length;e++)this._programs[e].release();return null}_createProgram(e,i={}){let a=new B(this._gpu.gl,e,i);return this._programs.push(a),a}}let j=(0,S.bf)("utils/copy.glsl").withArguments("image"),V=(0,S.bf)("utils/copy-raster.glsl").withDefines({TYPE:1}).withArguments("image"),te=(0,S.bf)("utils/copy-raster.glsl").withDefines({TYPE:2}).withArguments("image"),ge=(0,S.bf)("utils/copy.glsl","utils/flip-y.vs.glsl").withArguments("image"),Be=(0,S.bf)("utils/fill.glsl").withArguments("value"),Oe=(0,S.bf)("utils/fill-components.glsl").withArguments("image","pixelComponents","value"),Xe=(0,S.bf)("utils/copy-components.glsl").withArguments("dest","src","destComponents","srcComponentId"),qe=(0,S.bf)("utils/scan-minmax2d.glsl").withArguments("image","iterationNumber"),le=(0,S.bf)("utils/sobel-derivatives.glsl","utils/sobel-derivatives.vs.glsl").withArguments("pyramid","lod");class L extends q{constructor(e){super(e),this.declare("renderToCanvas",ge,Object.assign({},this.program.rendersToCanvas())).declare("copy",j).declare("copyKeypoints",V).declare("copy2DVectors",te).declare("fill",Be).declare("fillComponents",Oe).declare("copyComponents",Xe).declare("scanMinMax2D",qe,Object.assign({},this.program.usesPingpongRendering())).declare("sobelDerivatives",le)}}var J=n(1672);let ye=(0,S.bf)("filters/rgb2grey.glsl").withArguments("image"),ie=[3,5,7].reduce((C,e)=>(C[e]=(0,S.bf)("filters/convolution2d.glsl").withDefines({KERNEL_SIZE_SQUARED:e*e}).withArguments("image","kernel"),C),{}),Ie=[3,5,7,9,11,13,15].reduce((C,e)=>(C[e]=(0,S.bf)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:e,AXIS:0}).withArguments("image","kernel"),C),{}),We=[3,5,7,9,11,13,15].reduce((C,e)=>(C[e]=(0,S.bf)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:e,AXIS:1}).withArguments("image","kernel"),C),{}),se=[3,5,7].reduce((C,e)=>(C[e]=(0,S.bf)("filters/fast-median.glsl").withDefines({KERNEL_SIZE:e}).withArguments("image"),C),{}),Y=(0,S.bf)("filters/normalize-image.glsl").withDefines({GREYSCALE:1}).withArguments("minmax2d","minValue","maxValue"),ae=(0,S.bf)("filters/normalize-image.glsl").withDefines({GREYSCALE:0}).withArguments("minmax2dRGB","minValue","maxValue"),ne=(0,S.bf)("filters/nightvision.glsl").withDefines({GREYSCALE:0}).withArguments("image","illuminationMap","gain","offset","decay"),$=(0,S.bf)("filters/nightvision.glsl").withDefines({GREYSCALE:1}).withArguments("image","illuminationMap","gain","offset","decay"),ee=C=>Math.max(1,C/6),_e=C=>s.A.gaussianKernel(ee(C),C),ve=C=>new Array(C).fill(1/C);class pe extends q{constructor(e){super(e),this.declare("rgb2grey",ye).declare("median3",se[3]).declare("median5",se[5]).declare("median7",se[7]).declare("convolution3",ie[3]).declare("convolution5",ie[5]).declare("convolution7",ie[7]).declare("convolution3x",Ie[3]).declare("convolution3y",We[3]).declare("convolution5x",Ie[5]).declare("convolution5y",We[5]).declare("convolution7x",Ie[7]).declare("convolution7y",We[7]).declare("convolution9x",Ie[9]).declare("convolution9y",We[9]).declare("convolution11x",Ie[11]).declare("convolution11y",We[11]).declare("convolution13x",Ie[13]).declare("convolution13y",We[13]).declare("convolution15x",Ie[15]).declare("convolution15y",We[15]).declare("normalizeGreyscale",Y).declare("normalizeColored",ae).declare("nightvision",ne).declare("nightvisionGreyscale",$).declare("illuminationMapLoX",(0,J.convX)(s.A.gaussianKernel(80,31))).declare("illuminationMapLoY",(0,J.convY)(s.A.gaussianKernel(80,31))).declare("illuminationMapX",(0,J.convX)(s.A.gaussianKernel(80,63))).declare("illuminationMapY",(0,J.convY)(s.A.gaussianKernel(80,63))).declare("illuminationMapHiX",(0,J.convX)(s.A.gaussianKernel(80,255))).declare("illuminationMapHiY",(0,J.convY)(s.A.gaussianKernel(80,255))).declare("gaussian3x",(0,J.convX)([.25,.5,.25])).declare("gaussian3y",(0,J.convY)([.25,.5,.25])).declare("gaussian5x",(0,J.convX)([.05,.25,.4,.25,.05])).declare("gaussian5y",(0,J.convY)([.05,.25,.4,.25,.05])).declare("gaussian7x",(0,J.convX)(_e(7))).declare("gaussian7y",(0,J.convY)(_e(7))).declare("gaussian9x",(0,J.convX)(_e(9))).declare("gaussian9y",(0,J.convY)(_e(9))).declare("gaussian11x",(0,J.convX)(_e(11))).declare("gaussian11y",(0,J.convY)(_e(11))).declare("box3x",(0,J.convX)(ve(3))).declare("box3y",(0,J.convY)(ve(3))).declare("box5x",(0,J.convX)(ve(5))).declare("box5y",(0,J.convY)(ve(5))).declare("box7x",(0,J.convX)(ve(7))).declare("box7y",(0,J.convY)(ve(7))).declare("box9x",(0,J.convX)(ve(9))).declare("box9y",(0,J.convY)(ve(9))).declare("box11x",(0,J.convX)(ve(11))).declare("box11y",(0,J.convY)(ve(11)))}}var Se=n(6634);let Ge=4,Xt=11;class Nn extends Se.Q{static create(e,i,a){s.A.assert(a%Ge==0,`Invalid descriptorSize: ${a}`);let l=i.length,p=a/Ge,h=Math.log2(p*Math.max(l,1))/2,P=1<<Math.min(Xt,Math.ceil(h)),v=P,T=P,N=v*T/p;if(l>N)throw new A.EM(`The capacity of the descriptorDB (${N} for ${a*8}-bit descriptors) has been exceeded`);let k=new Uint8Array(v*T*Ge);for(let W=0;W<l;W++){let re=W*a,Ne=i[W];s.A.assert(Ne.byteLength===a),s.A.assert(re+a<=k.byteLength),k.set(Ne,re)}let K=1048576,H=l*a;return s.A.log(`Creating a ${v}x${T} database of ${l} ${a*8}-bit descriptors (total size: ${(H/K).toFixed(2)} MB)`),e.resize(v,T),e.upload(k),e}}let Rn=8,Sr=15,kt=[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],gt=[10,11,12,13,14,15,16,17,18,19,20],Er=[32,64],Oa=(C,e,i)=>!gt.includes(e)||!kt.includes(C)?null:[{name:"x-small",bucketCapacity:1,tableCount:C,hashSize:e,capacity:sn(e,1,i)},{name:"small",bucketCapacity:2,tableCount:C,hashSize:e,capacity:sn(e,2,i)},{name:"small-plus",bucketCapacity:3,tableCount:C,hashSize:e,capacity:sn(e,3,i)},{name:"medium",bucketCapacity:4,tableCount:C,hashSize:e,capacity:sn(e,4,i)},{name:"medium-plus",bucketCapacity:5,tableCount:C,hashSize:e,capacity:sn(e,5,i)},{name:"large",bucketCapacity:6,tableCount:C,hashSize:e,capacity:sn(e,6,i)},{name:"x-large",bucketCapacity:8,tableCount:C,hashSize:e,capacity:sn(e,8,i)}],it=Math.max(...gt),In=Math.max(...kt),Eo=C=>(s.A.range(In).forEach(e=>C.subarray(e*it,(e+1)*it).sort()),C),xo=(C,e)=>(s.A.range(In).forEach(i=>e.subarray((i+1)*it-C,(i+1)*it).fill(195939070)),e),xr=(C=>gt.reduce((e,i)=>(e[i]=C(i),e),{}))(C=>({32:Eo(xo(it-C,new Uint32Array([...s.A.shuffle(s.A.range(256)),...s.A.shuffle(s.A.range(256)),...s.A.shuffle(s.A.range(256))].slice(0,In*it)))),64:Eo(xo(it-C,new Uint32Array([...s.A.shuffle(s.A.range(512)),...s.A.shuffle(s.A.range(512))].slice(0,In*it))))})),$n=4,za=C=>C>1?1<<Math.ceil(Math.log2(C)):1;class Fa{constructor(e,i,a,l=Rn,p=Sr,h=.95){let I=a.length,P=I>0?a[0].byteLength:0,v=Oa(l,p,h);s.A.assert(I>0,"Can't build LSH tables without descriptors!"),s.A.assert(Er.includes(P),`Can't build LSH tables: unacceptable descriptor size of ${P} bytes`),s.A.assert(a.findIndex(T=>T.byteLength!==P)<0,`Can't build LSH tables: incorrectly sized descriptors. Expected ${P} bytes for each`),s.A.assert(I<E.MATCH_MAX_INDEX,`Can't build LSH tables: too many descriptors (${a.length})`),s.A.assert(v!=null,`Can't build LSH tables: unacceptable number of tables (${l}) x hash size (${p})`),this._profile=v.find(T=>I<=T.capacity)||v[v.length-1],this._descriptorSize=P,this._descriptorCount=I,this._sequences=this._pickSequences(this._descriptorSize),this._tables=this._createStaticTables(e,this._sequences,a,P),this._descriptorDB=Nn.create(i,a,P)}get descriptorSize(){return this._descriptorSize}get descriptorCount(){return this._descriptorCount}get sequences(){return this._sequences}get hashSize(){return this._profile.hashSize}get bucketCapacity(){return this._profile.bucketCapacity}get bucketsPerTable(){return 1<<this._profile.hashSize}get tableCount(){return this._profile.tableCount}get tableSize(){return this.bucketsPerTable*this.bucketCapacity*$n}get totalSize(){return this.tableCount*this.tableSize}get tables(){return this._tables}get descriptorDB(){return this._descriptorDB}_pickSequences(e){return s.A.assert(Object.prototype.hasOwnProperty.call(xr,this.hashSize)),s.A.assert(Object.prototype.hasOwnProperty.call(xr[this.hashSize],e)),xr[this.hashSize][e]}_createStaticTables(e,i,a,l){let h=this._profile.name,I=this._profile.capacity,P=this.tableCount,v=this.bucketsPerTable,T=this.bucketCapacity*$n,N=this.hashSize,k=this.tableCount*this.bucketsPerTable*this.bucketCapacity,K=Math.min(za(Math.sqrt(k)),4096),H=Math.ceil(k/K),W=a.length;s.A.assert(N<=it),s.A.assert(P<=In),s.A.assert(k<=K*H);let re=1048576;if(s.A.log(`Building ${P} ${h} LSH tables with ${W} ${l*8}-bit descriptors each and hashSize = ${N} bits (${K}x${H}, with ${(this.tableSize/re).toFixed(2)} MB per table and total size = ${(this.totalSize/re).toFixed(2)} MB), `),W>I){let ue=100*W/I;s.A.warning(`There are too many descriptors (${W}) for a ${h} LSH table. That's ${ue.toFixed(2)}% of its theoretical capacity. Consider increasing the hashSize (currently set to ${N}) or reducing the number of descriptors to avoid degradation.`)}let Ne=new ArrayBuffer(K*H*$n),Qe=new Uint8Array(Ne).fill(255),xe=new DataView(Ne),Ce=s.A.shuffle(s.A.range(W)),Je=new Array(P).fill(0);for(let ue=0;ue<W;ue++){let ct=Ce[ue],Yt=this._hashCodes(a[ct],i);for(let Et=0;Et<P;Et++){let Kt=Yt[Et],kn=Et*v*T+Kt*T,Wt=4294967295;for(let ln=0;ln<T;ln+=$n){let Ho=kn+ln;if(Wt=xe.getUint32(Ho,!0),Wt==4294967295){xe.setUint32(Ho,ct,!0);break}}Wt!=4294967295&&Je[Et]++}}let je=Je.reduce((ue,ct)=>ue+ct,0),at=Je.map(ue=>100*ue/W);return s.A.log(`When building ${P} ${h} LSH tables with ${W} ${l*8}-bit descriptors each and hashSize = ${N} bits, I got the following discard profile: `+at.map(ue=>ue.toFixed(2)+"%").join(", ")+`. Average: ${(100*je/(P*W)).toFixed(2)}%. Minimum: ${Math.min(...at).toFixed(2)}%. Table capacity: ${I}.`),e.resize(K,H),e.upload(Qe),e}_hashCodes(e,i){let a=this.tableCount,l=this.hashSize,p=this.bucketsPerTable,h=new Array(a);s.A.assert(l<=it&&i.length>=it*a);for(let I=0;I<a;I++){let P=it*I,v=0;for(let T=0;T<l;T++){let N=i[P+T],k=N>>>3,K=1<<(N&7);v=v<<1|(e[k]&K)!=0}s.A.assert(v>=0&&v<p),h[I]=v}return h}}function Ua(C,e){let i=Math.exp(-C),a=1,l=1,p=1;for(let h=1;h<=e;h++)a+=(p*=C)/(l*=h);return a*i}function sn(C,e,i=.99){let a=1<<C,l=e,p=i,h=1,I=a*l,P=0,v=0;for(;h<I;)P=Math.floor((h+I)/2),v=Ua(P/a,l),v>p?h=P+1:I=P;return P}let Xa=(0,S.bf)("keypoints/fast.glsl","keypoints/fast.vs.glsl").withDefines({FAST_TYPE:916}).withArguments("corners","pyramid","lod","threshold"),ei=[1,3,5,7].reduce((C,e)=>(C[e]=(0,S.bf)("keypoints/harris.glsl").withDefines({WINDOW_SIZE:e}).withArguments("corners","pyramid","derivatives","lod","lodStep","gaussian"),C),{}),Ga=(0,S.bf)("keypoints/score-findmax.glsl").withArguments("corners","iterationNumber"),Ha=(0,S.bf)("keypoints/harris-cutoff.glsl").withArguments("corners","maxScore","quality"),qa=(0,S.bf)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:0}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),Ya=(0,S.bf)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:1}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),Wa=(0,S.bf)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:2}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),Va=(0,S.bf)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:3}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),Ja=(0,S.bf)("keypoints/refine-scale.glsl").withDefines({METHOD:0}).withArguments("pyramid","lodStep","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ja=(0,S.bf)("keypoints/refine-scale.glsl").withDefines({METHOD:1}).withArguments("pyramid","lodStep","encodedKeypoints","descriptorSize","extraSize","encoderLength","threshold"),Za=(0,S.bf)("keypoints/allocate-descriptors.glsl").withArguments("inputEncodedKeypoints","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),$a=(0,S.bf)("keypoints/allocate-extra.glsl").withArguments("inputEncodedKeypoints","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),ec=(0,S.bf)("keypoints/transfer-to-extra.glsl").withArguments("encodedData","strideOfEncodedData","encodedKeypoints","descriptorSize","extraSize","encoderLength"),tc=(0,S.bf)("keypoints/orb-descriptor.glsl").withArguments("image","encodedCorners","extraSize","encoderLength"),nc=(0,S.bf)("keypoints/orb-orientation.glsl").withArguments("image","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ic=(0,S.bf)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:0}).withArguments("image","lodStep"),rc=(0,S.bf)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:1}).withArguments("image","lodStep"),oc=(0,S.bf)("keypoints/nonmax-space.glsl").withArguments("corners"),sc=(0,S.bf)("keypoints/nonmax-scale.glsl").withDefines({USE_LAPLACIAN:1}).withArguments("corners","pyramid","pyrLaplacian","lodStep"),ac=(0,S.bf)("keypoints/nonmax-scale.glsl").withDefines({USE_LAPLACIAN:0}).withArguments("corners","pyramid","lodStep"),cc=(0,S.bf)("keypoints/laplacian.glsl").withArguments("corners","pyramid","lodStep","lodOffset"),St=[3,5,7,9,11,13,15,17,19,21].reduce((C,e)=>(C[e]=(0,S.bf)("keypoints/lk.glsl").withDefines({WINDOW_SIZE:e}).withArguments("encodedFlow","prevKeypoints","nextPyramid","prevPyramid","level","depth","numberOfIterations","discardThreshold","epsilon","descriptorSize","extraSize","encoderLength"),C),{}),lc=(0,S.bf)("keypoints/transfer-flow.glsl").withArguments("encodedFlow","encodedKeypoints","descriptorSize","extraSize","encoderLength"),dc=(0,S.bf)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:0}),Ac=(0,S.bf)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:1}),pc=(0,S.bf)("keypoints/knn-transfer.glsl").withArguments("encodedMatches","encodedKthMatches","numberOfMatchesPerKeypoint","kthMatch"),uc=(0,S.bf)("keypoints/bf-knn.glsl").withDefines({DESCRIPTOR_SIZE:32,NUMBER_OF_KEYPOINTS_PER_PASS:16}).withArguments("encodedMatches","encodedFilters","matcherLength","dbEncodedKeypoints","dbDescriptorSize","dbExtraSize","dbEncoderLength","encodedKeypoints","descriptorSize","extraSize","encoderLength","passId"),hc=(0,S.bf)("keypoints/bf-knn.glsl").withDefines({DESCRIPTOR_SIZE:64,NUMBER_OF_KEYPOINTS_PER_PASS:8}).withArguments("encodedMatches","encodedFilters","matcherLength","dbEncodedKeypoints","dbDescriptorSize","dbExtraSize","dbEncoderLength","encodedKeypoints","descriptorSize","extraSize","encoderLength","passId"),gc=(0,S.bf)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:0}),fc=(0,S.bf)("keypoints/knn-init.glsl").withDefines({ENCODE_FILTERS:1}),ti=Er.reduce((C,e)=>(C[e]=gt.reduce((i,a)=>(i[a]=[0,1,2].reduce((l,p)=>(l[p]=(0,S.bf)("keypoints/lsh-knn.glsl").withDefines({DESCRIPTOR_SIZE:e,HASH_SIZE:a,LEVEL:p,SEQUENCE_MAXLEN:it,SEQUENCE_COUNT:In}).withArguments("candidates","filters","matcherLength","tables","descriptorDB","tableIndex","bucketCapacity","bucketsPerTable","tablesStride","descriptorDBStride","encodedKeypoints","descriptorSize","extraSize","encoderLength"),l),{}),i),{}),C),{}),mc=(0,S.bf)("keypoints/knn-transfer.glsl").withArguments("encodedMatches","encodedKthMatches","numberOfMatchesPerKeypoint","kthMatch"),Ic=(0,S.bf)("keypoints/sort-keypoints.glsl").withDefines({STAGE:1}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength"),_c=(0,S.bf)("keypoints/sort-keypoints.glsl").withDefines({STAGE:2}).withArguments("permutation","blockSize","dblLog2BlockSize"),yc=(0,S.bf)("keypoints/sort-keypoints.glsl").withDefines({STAGE:3}).withArguments("permutation","maxKeypoints","encodedKeypoints","descriptorSize","extraSize"),Sc=(0,S.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:1}).withArguments("encodedKeypointsA","encodedKeypointsB","encoderLengthA","encoderLengthB","encoderCapacityA","encoderCapacityB","descriptorSize","extraSize","encoderLength"),Ec=(0,S.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:2}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","maxKeypoints"),xc=(0,S.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:3}).withArguments("array","blockSize"),Cc=(0,S.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:5}).withArguments("array"),Pc=(0,S.bf)("keypoints/mix-keypoints.glsl").withDefines({STAGE:4}).withArguments("array","encodedKeypoints","descriptorSize","extraSize","encoderLength"),vc=(0,S.bf)("keypoints/lookup-of-locations.glsl").withDefines({FS_OUTPUT_TYPE:2,STAGE:1}).withArguments("corners"),bc=(0,S.bf)("keypoints/lookup-of-locations.glsl","keypoints/lookup-of-locations.vs.glsl").withDefines({FS_OUTPUT_TYPE:2,FS_USE_CUSTOM_PRECISION:1,STAGE:2}).withArguments("lookupTable","blockSize","width","height"),wc=(0,S.bf)("keypoints/lookup-of-locations.glsl").withDefines({STAGE:-1}).withArguments("lookupTable"),Tc=(0,S.bf)("keypoints/encode-keypoints.glsl").withArguments("corners","lookupTable","stride","descriptorSize","extraSize","encoderLength","encoderCapacity"),Mc=(0,S.bf)("keypoints/encode-keypoint-offsets.glsl").withArguments("corners","imageSize"),Bc=(0,S.bf)("keypoints/encode-keypoint-long-offsets.glsl").withDefines({MAX_ITERATIONS:6}).withArguments("offsetsImage","imageSize"),Nc=(0,S.bf)("keypoints/encode-keypoint-positions.glsl").withArguments("offsetsImage","imageSize","passId","numPasses","keypointLimit","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Rc=(0,S.bf)("keypoints/encode-keypoint-properties.glsl").withArguments("corners","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Dc=(0,S.bf)("keypoints/encode-null-keypoints.glsl").withArguments(),kc=(0,S.bf)("keypoints/transfer-orientation.glsl").withArguments("encodedOrientations","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Qc=(0,S.bf)("keypoints/upload-keypoints.glsl").withDefines({BUFFER_SIZE:1024}).withArguments("encodedKeypoints","startIndex","endIndex","descriptorSize","extraSize","encoderLength"),Lc=(0,S.bf)("keypoints/apply-homography.glsl").withArguments("homography","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Kc=(0,S.bf)("keypoints/clip-border.glsl").withArguments("imageWidth","imageHeight","borderTop","borderRight","borderBottom","borderLeft","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Oc=(0,S.bf)("keypoints/distance-filter.glsl").withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),zc=(0,S.bf)("keypoints/hamming-distance-filter.glsl").withDefines({DESCRIPTOR_SIZE:32}).withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),Fc=(0,S.bf)("keypoints/hamming-distance-filter.glsl").withDefines({DESCRIPTOR_SIZE:64}).withArguments("encodedKeypointsA","encoderLengthA","encodedKeypointsB","encoderLengthB","descriptorSize","extraSize","encoderLength","threshold"),Uc=(0,S.bf)("keypoints/shuffle.glsl").withDefines({PERMUTATION_MAXLEN:2048}).withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength"),Xc=(0,S.bf)("keypoints/clip.glsl").withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","maxKeypoints");class Gc extends q{constructor(e){super(e),this.declare("fast9_16",Xa,Object.assign({},this.program.usesPingpongRendering())).declare("harris1",ei[1],Object.assign({},this.program.usesPingpongRendering())).declare("harris3",ei[3],Object.assign({},this.program.usesPingpongRendering())).declare("harris5",ei[5],Object.assign({},this.program.usesPingpongRendering())).declare("harris7",ei[7],Object.assign({},this.program.usesPingpongRendering())).declare("harrisScoreFindMax",Ga,Object.assign({},this.program.usesPingpongRendering())).declare("harrisScoreCutoff",Ha).declare("subpixelQuadratic1d",qa).declare("subpixelTaylor2d",Ya).declare("subpixelBicubic",Va).declare("subpixelBilinear",Wa).declare("refineScaleLoG",Ja).declare("refineScaleFAST916",ja).declare("allocateDescriptors",Za).declare("allocateExtra",$a).declare("transferToExtra",ec).declare("orbDescriptor",tc).declare("orbOrientation",nc).declare("nonmax",ic).declare("pyrnonmax",rc).declare("nonmaxSpace",oc).declare("nonmaxScale",sc).declare("nonmaxScaleSimple",ac).declare("laplacian",cc).declare("lk21",St[21],Object.assign({},this.program.usesPingpongRendering())).declare("lk19",St[19],Object.assign({},this.program.usesPingpongRendering())).declare("lk17",St[17],Object.assign({},this.program.usesPingpongRendering())).declare("lk15",St[15],Object.assign({},this.program.usesPingpongRendering())).declare("lk13",St[13],Object.assign({},this.program.usesPingpongRendering())).declare("lk11",St[11],Object.assign({},this.program.usesPingpongRendering())).declare("lk9",St[9],Object.assign({},this.program.usesPingpongRendering())).declare("lk7",St[7],Object.assign({},this.program.usesPingpongRendering())).declare("lk5",St[5],Object.assign({},this.program.usesPingpongRendering())).declare("lk3",St[3],Object.assign({},this.program.usesPingpongRendering())).declare("transferFlow",lc).declare("bfMatcherInitCandidates",dc).declare("bfMatcherInitFilters",Ac).declare("bfMatcherTransfer",pc,Object.assign({},this.program.usesPingpongRendering())).declare("bfMatcher32",uc,Object.assign({},this.program.usesPingpongRendering())).declare("bfMatcher64",hc,Object.assign({},this.program.usesPingpongRendering())).declare("lshKnnInitCandidates",gc).declare("lshKnnInitFilters",fc).declare("lshKnnTransfer",mc,Object.assign({},this.program.usesPingpongRendering())).declare("sortCreatePermutation",Ic).declare("sortMergePermutation",_c,Object.assign({},this.program.usesPingpongRendering())).declare("sortApplyPermutation",yc).declare("mixKeypointsPreInit",Sc).declare("mixKeypointsInit",Ec).declare("mixKeypointsSort",xc,Object.assign({},this.program.usesPingpongRendering())).declare("mixKeypointsView",Cc).declare("mixKeypointsApply",Pc).declare("encodeNullKeypoints",Dc).declare("encodeKeypoints",Tc).declare("initLookupTable",vc).declare("sortLookupTable",bc,Object.assign({},this.program.usesPingpongRendering())).declare("viewLookupTable",wc).declare("encodeKeypointSkipOffsets",Mc).declare("encodeKeypointLongSkipOffsets",Bc,Object.assign({},this.program.usesPingpongRendering())).declare("encodeKeypointPositions",Nc,Object.assign({},this.program.usesPingpongRendering())).declare("encodeKeypointProperties",Rc).declare("transferOrientation",kc).declare("uploadKeypoints",Qc,Object.assign({},this.program.usesPingpongRendering())).declare("applyHomography",Lc).declare("clipBorder",Kc).declare("distanceFilter",Oc).declare("hammingDistanceFilter32",zc).declare("hammingDistanceFilter64",Fc).declare("shuffle",Uc).declare("clip",Xc);for(let i of Object.keys(ti))for(let a of Object.keys(ti[i]))for(let l of Object.keys(ti[i][a])){let p=`lshKnn${i}h${a}lv${l}`;this.declare(p,ti[i][a][l],Object.assign({},this.program.usesPingpongRendering()))}}}let Hc=(0,S.bf)("pyramids/upsample2.glsl").withArguments("image"),qc=(0,S.bf)("pyramids/downsample2.glsl").withArguments("image");class Yc extends q{constructor(e){super(e),this.declare("upsample2",Hc).declare("downsample2",qc).declare("smoothX",(0,J.convX)([.05,.25,.4,.25,.05])).declare("smoothY",(0,J.convY)([.05,.25,.4,.25,.05])).declare("smoothX2",(0,J.convX)([.1,.5,.8,.5,.1])).declare("smoothY2",(0,J.convY)([.1,.5,.8,.5,.1],1/2))}}let Wc=(0,S.bf)("transforms/warp-perspective.glsl").withArguments("image","inverseHomography"),Vc=(0,S.bf)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:0}).withArguments("image"),Jc=(0,S.bf)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:1}).withArguments("image"),jc=(0,S.bf)("transforms/additive-mix.glsl").withArguments("image0","image1","alpha","beta","gamma");class Zc extends q{constructor(e){super(e),this.declare("warpPerspective",Wc).declare("resizeNearest",Vc).declare("resizeBilinear",Jc).declare("additiveMix",jc)}}class Co{constructor(e){this._gpu=e,this._filters=null,this._transforms=null,this._pyramids=null,this._keypoints=null,this._utils=null}get filters(){return this._filters||(this._filters=new pe(this._gpu))}get transforms(){return this._transforms||(this._transforms=new Zc(this._gpu))}get pyramids(){return this._pyramids||(this._pyramids=new Yc(this._gpu))}get keypoints(){return this._keypoints||(this._keypoints=new Gc(this._gpu))}get utils(){return this._utils||(this._utils=new L(this._gpu))}release(){for(let e in this)if(Object.prototype.hasOwnProperty.call(this,e)&&this[e]!=null){let i=this[e];i instanceof q&&i.release()}return null}}let $c=1024,Po=Symbol("Bucket");class el{constructor(e,i,a){this.texture=e,this.index=i,this.next=a,this.free=!0}}class ni{constructor(e,i=$c){s.A.assert(i>0),this._bucket=Array.from({length:i},(a,l)=>new el(null,l,l-1)),this._head=i-1,this._gpu=e}allocate(){if(this._head<0)throw new A.l(`Exhausted pool (capacity: ${this._bucket.length})`);let e=this._bucket[this._head];return e.free=!1,this._head=e.next,e.texture==null&&(e.texture=ni._createManagedTexture(this._gpu.gl,e)),e.texture}free(e){let i=e[Po];return s.A.assert(i!==void 0&&!i.free,"Unmanaged texture or double free"),i.next=this._head,i.free=!0,this._head=i.index,null}release(){for(let e=0;e<this._bucket.length;e++)this._bucket[e].texture!=null&&(this._bucket[e].texture=this._bucket[e].texture.release());return null}static _createManagedTexture(e,i){let a=new M(e,1,1);return Object.defineProperty(a,Po,{configurable:!1,enumerable:!1,writable:!1,value:i})}}var Ae=n(6049);let Gt=Symbol();class Ht{constructor(e){if(e!==Gt)throw new A.Er;this._data=null}static load(e){if(e instanceof HTMLImageElement)return ii.load(e);if(e instanceof HTMLVideoElement)return _n.load(e);if(e instanceof HTMLCanvasElement)return ri.load(e);if(typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas)return oi.load(e);if(e instanceof ImageBitmap)return si.load(e);if(e instanceof ImageData)return ai.load(e);throw new A.qw(`Unsupported media type: ${e}`)}get data(){return this._data}isLoaded(){return this._data!==null}get type(){throw new A.aQ}get width(){throw new A.aQ}get height(){throw new A.aQ}clone(){throw new A.aQ}release(){return this._data=null}_load(e){throw new A.aQ}static _waitUntil(e,i,a=3e4){return new c.i((l,p)=>{s.A.log(`Waiting for ${i} to be triggered in ${e}...`);let h=setTimeout(()=>{I(),p(new A.MU(`${i} has not been triggered in ${e}: timeout (${a}ms)`))},a);function I(){clearTimeout(h),e.removeEventListener("error",P,!1),e.removeEventListener(i,v,!1)}function P(){let N=e.error!==null&&typeof e.error=="object"?e.error:{code:-1,message:""},k=`${N.message} (error code ${N.code})`;I(),p(new A.FJ(`Can't load ${e}. ${k}`))}function v(){I(),l(e)}e.addEventListener("error",P,!1),e.addEventListener(i,v,!1)})}}class ii extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return Ae.zu.Image}get width(){return this._data?this._data.naturalWidth:0}get height(){return this._data?this._data.naturalHeight:0}clone(){if(this._data==null)throw new A.Er("Media not loaded");let e=this._data.cloneNode(!0);return ii.load(e)}_load(e){return this.isLoaded()&&this.release(),e.complete&&e.naturalWidth!==0?new c.i(i=>{this._data=e,i(this)}):Ht._waitUntil(e,"load").then(()=>(this._data=e,this))}static load(e){return new ii(Gt)._load(e)}}class _n extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return Ae.zu.Video}get width(){return this._data?this._data.videoWidth:0}get height(){return this._data?this._data.videoHeight:0}clone(){if(this._data==null)throw new A.Er("Media not loaded");let e=this._data.cloneNode(!0);return _n.load(e)}_load(e){return this.isLoaded()&&this.release(),s.A.log("Loading a video..."),e.load(),_n._waitUntilPlayable(e).then(()=>_n._handleAutoplay(e).then(()=>(this._data=e,this)))}static load(e){return new _n(Gt)._load(e)}static _handleAutoplay(e){return e.autoplay?new c.i((i,a)=>{let l=e.play();if(l===void 0){i();return}l.then(i,a)}):c.i.resolve()}static _waitUntilPlayable(e){return e.readyState>=3?c.i.resolve(e):new c.i((l,p)=>{let h=0,I=setInterval(()=>{e.readyState>=3?(clearInterval(I),l(e)):(h+=500)>=3e4&&(clearInterval(I),p(new A.MU("The video took too long to load")))},500)})}}class ri extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return Ae.zu.Canvas}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(this._data==null)throw new A.Er("Media not loaded");let e=s.A.createCanvas(this.width,this.height);return e.getContext("2d").drawImage(this._data,0,0),ri.load(e)}_load(e){return this.isLoaded()&&this.release(),new c.i(i=>{this._data=e,i(this)})}static load(e){return new ri(Gt)._load(e)}}class oi extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return Ae.zu.OffscreenCanvas}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(this._data==null)throw new A.Er("Media not loaded");let e=new OffscreenCanvas(this.width,this.height);return e.getContext("2d").drawImage(this._data,0,0),oi.load(e)}_load(e){return this.isLoaded()&&this.release(),new c.i(i=>{this._data=e,i(this)})}static load(e){return new oi(Gt)._load(e)}}class si extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return Ae.zu.Bitmap}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(this._data==null)throw new A.Er("Media not loaded");return new c.i((e,i)=>{createImageBitmap(this._data).then(a=>{new si(Gt)._load(a).then(e,i)},i)})}release(){return this._data!=null&&this._data.close(),super.release()}_load(e){return this.isLoaded()&&this.release(),new c.i(i=>{this._data=e,i(this)})}static load(e){return new si(Gt)._load(e)}}class ai extends Ht{constructor(e){super(e),this._data=null}get data(){return this._data}get type(){return Ae.zu.Data}get width(){return this._data?this._data.width:0}get height(){return this._data?this._data.height:0}clone(){if(this._data==null)throw new A.Er("Media not loaded");let e=new ImageData(new Uint8ClampedArray(this._data.data),this._data.width,this._data.height);return ai.load(e)}_load(e){return this.isLoaded()&&this.release(),new c.i(i=>{this._data=e,i(this)})}static load(e){return new ai(Gt)._load(e)}}var tl=n(3211);class nl extends tl.c{constructor(){super(),this._speedyGL=r.c.instance,this._programs=new Co(this),this._texturePool=new ni(this),this._speedyGL.subscribe(this._reset,this)}get programs(){return this._programs}get gl(){return this._speedyGL.gl}get canvas(){return this._speedyGL.canvas}get texturePool(){return this._texturePool}renderToCanvas(e){let i=e.width,a=e.height,l=this.canvas;return(i>l.width||a>l.height)&&(s.A.warning(`Resizing the canvas to ${i} x ${a}`),l.width=i,l.height=a),this.programs.utils.renderToCanvas.outputs(i,a,null),this.programs.utils.renderToCanvas(e),l}upload(e,i){return i.upload(e.data,e.width,e.height)}release(){return s.A.assert(!this.isReleased()),this._programs=this._programs.release(),this._texturePool=this._texturePool.release(),this._speedyGL.unsubscribe(this._reset),null}isReleased(){return this._programs==null}loseAndRestoreWebGLContext(){return this._speedyGL.loseAndRestoreContext().then(()=>{})}_reset(){this.isReleased()||(this._programs=new Co(this),this._texturePool=new ni(this),this._notify())}}class rt{constructor(e,i){this._width=Math.max(0,+e),this._height=Math.max(0,+i)}get width(){return this._width}set width(e){this._width=Math.max(0,+e)}get height(){return this._height}set height(e){this._height=Math.max(0,+e)}toString(){return`SpeedySize(${this.width}, ${this.height})`}equals(e){return this.width===e.width&&this.height===e.height}area(){return this.width*this.height}}let Cr=Symbol();class an{constructor(e,i,a={}){if(e!==Cr)throw new A.Er;if(this._source=i,this._format=a.format!==void 0?a.format:Ae.f5.RGBA,this._options=Object.freeze(Object.assign(Object.assign({},a),{},{format:this._format})),i.isLoaded()){if(this._format!==Ae.f5.RGBA&&this._format!==Ae.f5.GREY)throw new A.qw(`Invalid format: ${this._format}`)}else throw new A.Er(`Source not loaded: ${i}`)}static load(e,i={},a=!0){return Ht.load(e).then(l=>{s.A.assert(l.width!==0&&l.height!==0);let p=new an(Cr,l,i);return a&&s.A.log(`Loaded SpeedyMedia with a ${e}.`),p})}get source(){return this._source?this._source.data:null}get type(){if(this.isReleased())return"unknown";switch(this._source.type){case Ae.zu.Image:return"image";case Ae.zu.Video:return"video";case Ae.zu.Canvas:return"canvas";case Ae.zu.OffscreenCanvas:return"offscreen-canvas";case Ae.zu.Bitmap:return"bitmap";case Ae.zu.Data:return"data";default:return"unknown"}}get width(){return this._source?this._source.width:0}get height(){return this._source?this._source.height:0}get size(){return this._source?new rt(this._source.width,this._source.height):new rt(0,0)}get options(){return this._options}release(){return this.isReleased()||(s.A.log("Releasing SpeedyMedia object..."),this._source=this._source.release()),null}isReleased(){return this._source==null}clone(){if(this.isReleased())throw new A.Er("Can't clone a SpeedyMedia that has been released");let e=new an(Cr,this._source,this._options);return c.i.resolve(e)}toBitmap(){if(this.isReleased())throw new A.Er("Can't convert SpeedyMedia to ImageBitmap: the media has been released");if(this._source.isLoaded())return this._source.type==Ae.zu.Bitmap?c.i.resolve(this._source.data):new c.i((e,i)=>createImageBitmap(this._source.data).then(e,i));throw new A.Er("Can't convert SpeedyMedia to bitmap: the media hasn't been loaded")}}class il extends Se.Q{static get renderer(){return r.c.instance.renderer}static get vendor(){return r.c.instance.vendor}}class Ve{constructor(e,i){this._x=+e,this._y=+i}get x(){return this._x}set x(e){this._x=+e}get y(){return this._y}set y(e){this._y=+e}toString(){return`SpeedyVector2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}equals(e){return this.x===e.x&&this.y===e.y}dot(e){return this.x*e.x+this.y*e.y}distanceTo(e){let i=this.x-e.x,a=this.y-e.y;return Math.sqrt(i*i+a*a)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalized(){let e=this.length();return e>0?new Ve(this.x/e,this.y/e):new Ve(0,0)}plus(e){return new Ve(this.x+e.x,this.y+e.y)}minus(e){return new Ve(this.x-e.x,this.y-e.y)}times(e){return new Ve(this.x*e,this.y*e)}}class ci{constructor(e,i){this._x=+e,this._y=+i}get x(){return this._x}set x(e){this._x=+e}get y(){return this._y}set y(e){this._y=+e}toString(){return`SpeedyPoint2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}plus(e){return new ci(this.x+e.x,this.y+e.y)}minus(e){return new Ve(this.x-e.x,this.y-e.y)}equals(e){return this.x===e.x&&this.y===e.y}}var pp=n(6306),G=n(6465),Qt=n(4188);class rl extends Function{constructor(){return super("...args","return args.length > 1 ? this._create(...args) : this._from(args[0])"),this.bind(this)}_create(e,i=e,a=[]){return Qt.SpeedyMatrix.Create(e,i,a)}_from(e){return Qt.SpeedyMatrix.From(e)}Zeros(e,i=e){return Qt.SpeedyMatrix.Zeros(e,i)}Ones(e,i=e){return Qt.SpeedyMatrix.Ones(e,i)}Eye(e,i=e){return Qt.SpeedyMatrix.Eye(e,i)}ready(){return Qt.SpeedyMatrix.ready()}qr(e,i,a,{mode:l="reduced"}={}){let p=a,h=a.rows,I=a.columns;if(l=="reduced"){if(e.rows!=h||e.columns!=I||i.rows!=I||i.columns!=I)throw new A.qw("Invalid shape for reduced QR")}else if(l=="full"){if(e.rows!=h||e.columns!=h||i.rows!=h||i.columns!=I)throw new A.qw("Invalid shape for full QR")}else throw new A.qw(`Invalid mode for QR: "${l}"`);return G.U.ready().then(({wasm:P,memory:v})=>{let T=G.U.allocateMat32(P,v,e),N=G.U.allocateMat32(P,v,i),k=G.U.allocateMat32(P,v,p);return G.U.copyToMat32(P,v,k,p),l=="reduced"?P.exports.Mat32_qr_reduced(T,N,k):P.exports.Mat32_qr_full(T,N,k),G.U.copyFromMat32(P,v,T,e),G.U.copyFromMat32(P,v,N,i),G.U.deallocateMat32(P,v,k),G.U.deallocateMat32(P,v,N),G.U.deallocateMat32(P,v,T),[e,i]})}ols(e,i,a,{method:l="qr"}={}){let p=i.rows,h=i.columns,I=e;if(p<h||h==0)throw new A.qw("Can't solve an underdetermined system of equations");if(a.rows!=p||a.columns!=1||I.rows!=h||I.columns!=1)throw new A.qw("Invalid shapes");return G.U.ready().then(({wasm:P,memory:v})=>{let T=G.U.allocateMat32(P,v,i),N=G.U.allocateMat32(P,v,a),k=G.U.allocateMat32(P,v,I);switch(G.U.copyToMat32(P,v,T,i),G.U.copyToMat32(P,v,N,a),l){case"qr":P.exports.Mat32_qr_ols(k,T,N,2);break;default:throw new A.qw(`Invalid method: "${l}"`)}return G.U.copyFromMat32(P,v,k,I),G.U.deallocateMat32(P,v,k),G.U.deallocateMat32(P,v,N),G.U.deallocateMat32(P,v,T),e})}solve(e,i,a,{method:l="qr"}={}){let p=i.rows,h=i.columns,I=e;if(p!=h)throw new A.qw("Can't solve an over or underdetermined system of equations");if(a.rows!=p||a.columns!=1||I.rows!=p||I.columns!=1)throw new A.qw("Invalid shapes");return G.U.ready().then(({wasm:P,memory:v})=>{switch(l){case"qr":return this.ols(I,i,a,{method:l});default:throw new A.qw(`Invalid method: "${l}"`)}})}perspective(e,i,a){if(i.rows!=2||i.columns!=4||a.rows!=2||a.columns!=4)throw new A.qw("You need two 2x4 input matrices to compute a perspective transformation");if(e.rows!=3||e.columns!=3)throw new A.qw("The output of perspective() is a 3x3 homography");return G.U.ready().then(({wasm:l,memory:p})=>{let h=G.U.allocateMat32(l,p,e),I=G.U.allocateMat32(l,p,i),P=G.U.allocateMat32(l,p,a);return G.U.copyToMat32(l,p,I,i),G.U.copyToMat32(l,p,P,a),l.exports.Mat32_homography_ndlt4(h,I,P),G.U.copyFromMat32(l,p,h,e),G.U.deallocateMat32(l,p,P),G.U.deallocateMat32(l,p,I),G.U.deallocateMat32(l,p,h),e})}findHomography(e,i,a,{method:l="default",mask:p=null,reprojectionError:h=3,numberOfHypotheses:I=512,bundleSize:P=128}={}){if(i.rows!=2||i.columns<4||a.rows!=2||a.columns!=i.columns)throw new A.qw("You need two 2 x n (n >= 4) input matrices to compute a homography");if(e.rows!=3||e.columns!=3)throw new A.qw("The output of findHomography() is a 3x3 homography");if(p!=null&&(p.rows!=1||p.columns!=i.columns))throw new A.qw("Invalid shape of the inliers mask");return G.U.ready().then(({wasm:v,memory:T})=>{let N=G.U.allocateMat32(v,T,e),k=G.U.allocateMat32(v,T,i),K=G.U.allocateMat32(v,T,a),H=p!=null?G.U.allocateMat32(v,T,p):0;switch(G.U.copyToMat32(v,T,k,i),G.U.copyToMat32(v,T,K,a),l){case"pransac":s.A.assert(h>=0&&I>0&&P>0),v.exports.Mat32_pransac_homography(N,H,k,K,I,P,h);break;case"default":case"dlt":v.exports.Mat32_homography_ndlt(N,k,K);break;default:throw new A.qw(`Illegal method for findHomography(): "${l}"`)}return G.U.copyFromMat32(v,T,N,e),p!=null&&G.U.copyFromMat32(v,T,H,p),p!=null&&G.U.deallocateMat32(v,T,H),G.U.deallocateMat32(v,T,K),G.U.deallocateMat32(v,T,k),G.U.deallocateMat32(v,T,N),e})}applyPerspectiveTransform(e,i,a){if(i.rows!=2||e.rows!=2||i.columns!=e.columns)throw new A.qw("Invalid shapes");if(a.rows!=3||a.columns!=3)throw new A.qw("The perspective transformation must be a 3x3 matrix");return G.U.ready().then(({wasm:l,memory:p})=>{let h=G.U.allocateMat32(l,p,a),I=G.U.allocateMat32(l,p,i),P=G.U.allocateMat32(l,p,e);return G.U.copyToMat32(l,p,I,i),G.U.copyToMat32(l,p,h,a),l.exports.Mat32_transform_perspective(P,I,h),G.U.copyFromMat32(l,p,P,e),G.U.deallocateMat32(l,p,P),G.U.deallocateMat32(l,p,I),G.U.deallocateMat32(l,p,h),e})}affine(e,i,a){if(i.rows!=2||i.columns!=3||a.rows!=2||a.columns!=3)throw new A.qw("You need two 2x3 input matrices to compute an affine transform");if(e.rows!=2||e.columns!=3)throw new A.qw("The output of affine() is a 2x3 matrix");return G.U.ready().then(({wasm:l,memory:p})=>{let h=G.U.allocateMat32(l,p,e),I=G.U.allocateMat32(l,p,i),P=G.U.allocateMat32(l,p,a);return G.U.copyToMat32(l,p,I,i),G.U.copyToMat32(l,p,P,a),l.exports.Mat32_affine_direct3(h,I,P),G.U.copyFromMat32(l,p,h,e),G.U.deallocateMat32(l,p,P),G.U.deallocateMat32(l,p,I),G.U.deallocateMat32(l,p,h),e})}findAffineTransform(e,i,a,{method:l="default",mask:p=null,reprojectionError:h=3,numberOfHypotheses:I=512,bundleSize:P=128}={}){if(i.rows!=2||i.columns<3||a.rows!=2||a.columns!=i.columns)throw new A.qw("You need two 2 x n (n >= 3) input matrices to compute an affine transform");if(e.rows!=2||e.columns!=3)throw new A.qw("The output of findAffineTransform() is a 2x3 matrix");if(p!=null&&(p.rows!=1||p.columns!=i.columns))throw new A.qw("Invalid shape of the inliers mask");return G.U.ready().then(({wasm:v,memory:T})=>{let N=G.U.allocateMat32(v,T,e),k=G.U.allocateMat32(v,T,i),K=G.U.allocateMat32(v,T,a),H=p!=null?G.U.allocateMat32(v,T,p):0;switch(G.U.copyToMat32(v,T,k,i),G.U.copyToMat32(v,T,K,a),l){case"pransac":s.A.assert(h>=0&&I>0&&P>0),v.exports.Mat32_pransac_affine(N,H,k,K,I,P,h);break;case"default":v.exports.Mat32_affine_direct(N,k,K);break;default:throw new A.qw(`Illegal method for findAffineTransform(): "${l}"`)}return G.U.copyFromMat32(v,T,N,e),p!=null&&G.U.copyFromMat32(v,T,H,p),p!=null&&G.U.deallocateMat32(v,T,H),G.U.deallocateMat32(v,T,K),G.U.deallocateMat32(v,T,k),G.U.deallocateMat32(v,T,N),e})}applyAffineTransform(e,i,a){if(i.rows!=2||e.rows!=2||i.columns!=e.columns)throw new A.qw("Invalid shapes");if(a.rows!=2||a.columns!=3)throw new A.qw("The affine transformation must be a 2x3 matrix");return G.U.ready().then(({wasm:l,memory:p})=>{let h=G.U.allocateMat32(l,p,a),I=G.U.allocateMat32(l,p,i),P=G.U.allocateMat32(l,p,e);return G.U.copyToMat32(l,p,I,i),G.U.copyToMat32(l,p,h,a),l.exports.Mat32_transform_affine(P,I,h),G.U.copyFromMat32(l,p,P,e),G.U.deallocateMat32(l,p,P),G.U.deallocateMat32(l,p,I),G.U.deallocateMat32(l,p,h),e})}}let z=Object.freeze({Nothing:Symbol("Nothing"),Image:Symbol("Image"),Keypoints:Symbol("Keypoints"),Vector2:Symbol("Vector2"),LSHTables:Symbol("LSHTables"),KeypointMatches:Symbol("KeypointMatches")});class cn{constructor(e){this._type=e}get type(){return this._type}hasType(e){return this._type===e}isEmpty(){return this.hasType(z.Nothing)}toString(){return`message of type ${Object.keys(z).find(i=>z[i]===this.type)}`}inspect(e){throw new A.aQ}set(...e){throw new A.aQ}static create(e){return Al(e)}}class vo extends cn{constructor(){super(z.Nothing)}set(){return this}inspect(e){return{type:this.constructor.name}}}class ol extends cn{constructor(){super(z.Image),this._image=null,this._format=Ae.f5.RGBA}set(e,i=Ae.f5.RGBA){return this._image=e,this._format=i,this}inspect(e){let i=Object.keys(Ae.f5).find(a=>Ae.f5[a]===this.format);return{type:this.constructor.name,format:String(i),imageSize:this.image?`${this.image.width}x${this.image.height}`:"0x0",image:this.image?"<image data>":"",hasMipmaps:this.image&&this.image.hasMipmaps()?"yes":"no"}}get image(){return this._image}get format(){return this._format}}class sl extends cn{constructor(){super(z.Keypoints),this._encodedKeypoints=null,this._descriptorSize=0,this._extraSize=0,this._encoderLength=1}set(e,i,a,l){return this._encodedKeypoints=e,this._descriptorSize=i|0,this._extraSize=a|0,this._encoderLength=l|0,s.A.assert(this._descriptorSize>=0&&this._extraSize>=0),s.A.assert(this._encoderLength===this._encodedKeypoints.width,"Invalid encoderLength"),s.A.assert(this._encodedKeypoints.width===this._encodedKeypoints.height,"Invalid encodedKeypoints texture"),this}inspect(e){return{type:this.constructor.name,descriptorSize:this.descriptorSize,extraSize:this.extraSize,encoderLength:this.encoderLength,encodedKeypointsSize:this.encodedKeypoints?`${this.encodedKeypoints.width}x${this.encodedKeypoints.height}`:"0x0",encodedKeypoints:this.encodedKeypoints?s.A.formatBinaryData(this.encodedKeypoints.inspect(e).buffer):""}}get encodedKeypoints(){return this._encodedKeypoints}get descriptorSize(){return this._descriptorSize}get extraSize(){return this._extraSize}get encoderLength(){return this._encoderLength}}class al extends cn{constructor(){super(z.Vector2),this._vectors=null}set(e){return this._vectors=e,this}inspect(e){return{type:this.constructor.name,vectorsSize:this.vectors?`${this.vectors.width}x${this.vectors.height}`:"0x0",vectors:this.vectors?s.A.formatBinaryData(this.vectors.inspect(e).buffer):""}}get vectors(){return this._vectors}}class cl extends cn{constructor(){super(z.LSHTables),this._lsh=null}set(e){return this._lsh=e,this}inspect(e){return{type:this.constructor.name,lsh:"<LSH tables>"}}get lsh(){return this._lsh}}class ll extends cn{constructor(){super(z.KeypointMatches),this._encodedMatches=null,this._matchesPerKeypoint=1}set(e,i){return this._encodedMatches=e,this._matchesPerKeypoint=i|0,s.A.assert(this._matchesPerKeypoint>0),this}inspect(e){return{type:this.constructor.name,matchesPerKeypoint:this.matchesPerKeypoint,encodedMatchesSize:this.encodedMatches?`${this.encodedMatches.width}x${this.encodedMatches.height}`:"0x0",encodedMatches:this.encodedMatches?s.A.formatBinaryData(this.encodedMatches.inspect(e).buffer):""}}get encodedMatches(){return this._encodedMatches}get matchesPerKeypoint(){return this._matchesPerKeypoint}}let dl=Object.freeze({[z.Nothing]:vo,[z.Image]:ol,[z.Keypoints]:sl,[z.Vector2]:al,[z.LSHTables]:cl,[z.KeypointMatches]:ll});function Al(C){return new dl[C]}let bo=C=>!0;class pl{constructor(e,i=bo){this._expectedMessageType=e,this._isValidMessage=typeof i=="function"?i:bo,s.A.assert(this._expectedMessageType!=z.Nothing)}isCompatibleWith(e){return this._expectedMessageType==e._expectedMessageType}accepts(e){return e.hasType(this._expectedMessageType)&&this._isValidMessage(e)}toString(){return`Port expects ${Object.keys(z).find(i=>z[i]===this._expectedMessageType)} satisfying ${this._isValidMessage}`}get expectedMessageType(){return this._expectedMessageType}}let ul="in",hl="out",gl=/^[a-z][a-zA-Z0-9]*$/,wo=new vo;class To{constructor(e,i,a){this._name=String(e),this._spec=i,this._node=a,this._message=wo,s.A.assert(gl.test(this._name),`Port name "${this._name}" is not acceptable`)}get name(){return this._name}get node(){return this._node}connectTo(e){throw new A.aQ}isInputPort(){throw new A.aQ}isOutputPort(){return!this.isInputPort()}clearMessage(){this._message=wo}hasMessage(){return!this._message.isEmpty()}read(){if(this._message.isEmpty())throw new A.Er(`Can't read from port ${this.name}: nothing to read`);return this._message}write(e){throw new A.EM(`Can't write ${e} to port ${this.name}: unsupported operation`)}inspect(e){return this._message.inspect(e)}static get DEFAULT_NAME(){throw new A.aQ}}class Pr extends To{constructor(e,i,a){super(e,i,a),this._cachedMessage=null}connectTo(e){if(!e.isInputPort())throw new A.qw(`Can't connect output port ${this.name} to port ${e.name}: expected an input port`);e.connectTo(this)}isInputPort(){return!1}write(e){if(!this._spec.accepts(e))throw new A.qw(`Can't write ${e} to port ${this.name}. ${this._spec}`);this._message=e}swrite(...e){this._cachedMessage==null&&(this._cachedMessage=cn.create(this._spec.expectedMessageType)),this.write(this._cachedMessage.set(...e))}static get DEFAULT_NAME(){return hl}}class vr extends To{constructor(e,i,a){super(e,i,a),this._incomingLink=null}get incomingLink(){return this._incomingLink}connectTo(e){if(e.isOutputPort()){if(!this._spec.isCompatibleWith(e._spec))throw new A.qw(`Can't connect port ${this.name} of "${this.node.fullName}" to port ${e.name} of "${e.node.fullName}": incompatible types`)}else throw new A.qw(`Can't connect input port ${this.name} of "${this.node.fullName}" to input port ${e.name} of "${e.node.fullName}": expected an output port`);this._incomingLink=e}disconnect(){this._incomingLink=null}isInputPort(){return!0}pullMessage(e=""){let i=e.length>0?`${this.name} of ${e}`:this.name;if(this._incomingLink==null)throw new A.Er(`No incoming link for input port ${i}`);let a=this._incomingLink.read();if(!this._spec.accepts(a))throw new A.qw(`Can't receive ${a} at port ${i}: ${this._spec}`);return this._message=a}static get DEFAULT_NAME(){return ul}}class Mo{constructor(e,i){this._class=e,this._name=String(i),this._type=z.Nothing,this._messageConstraint=void 0}expects(e){return s.A.assert(this._type==z.Nothing),s.A.assert(e!=z.Nothing),this._type=e,this}satisfying(e){return s.A.assert(this._type!=z.Nothing,"You must first declare what type of message this port expects"),s.A.assert(this._messageConstraint===void 0),s.A.assert(typeof e=="function"),this._messageConstraint=e,this}build(e){let i=new pl(this._type,this._messageConstraint);return Reflect.construct(this._class,[this._name,i,e])}}function de(C=vr.DEFAULT_NAME){return new Mo(vr,C)}function fe(C=Pr.DEFAULT_NAME){return new Mo(Pr,C)}let fl=()=>Math.random().toString(16).substr(2),ml=()=>Object.create(null),Il=()=>Object.create(null);function _l(C){return C.reduce((e,i)=>(e[i.name]=i,e),ml())}function yl(C){return C.reduce((e,i)=>(e[i.name]=i,e),Il())}let Bo=!1;class Ee{constructor(e=fl(),i=0,a=[]){this._name=String(e),this._tex=new Array(i).fill(null);let l=a.map(I=>I.build(this)),p=l.filter(I=>I.isInputPort()),h=l.filter(I=>I.isOutputPort());if(this._inputPorts=_l(p),this._outputPorts=yl(h),this._name.length==0)throw new A.qw(`Invalid name "${this._name}" for node ${this.fullName}`);if(a.length==0)throw new A.qw(`No ports have been found in node ${this.fullName}`)}get name(){return this._name}get fullName(){return`${this.constructor.name}[${this.name}]`}input(e=vr.DEFAULT_NAME){if(e in this._inputPorts)return this._inputPorts[e];throw new A.qw(`Can't find input port ${e} in node ${this.fullName}`)}output(e=Pr.DEFAULT_NAME){if(e in this._outputPorts)return this._outputPorts[e];throw new A.qw(`Can't find output port ${e} in node ${this.fullName}`)}execute(e){let i;for(i in this._outputPorts)this._outputPorts[i].clearMessage();for(i in this._inputPorts)this._inputPorts[i].pullMessage(this.fullName);let a=this._run(e);return typeof a>"u"?void this._finishExecution(e):a.then(()=>this._finishExecution(e))}_finishExecution(e){for(let i in this._outputPorts)s.A.assert(this._outputPorts[i].hasMessage(),`Did you forget to write data to the output port ${i} of ${this.fullName}?`);if(d.w.logging==="diagnostic"){s.A.log(`%c ${this.fullName} `,"font-size:12pt;font-weight:bold;color:white;background:blue");for(let i in this._inputPorts)s.A.log(`%c-> ${i}:`,"font-size:10pt;font-weight:bold",this._inputPorts[i].inspect(e));for(let i in this._outputPorts)s.A.log(`%c<- ${i}:`,"font-size:10pt;font-weight:bold",this._outputPorts[i].inspect(e))}}_run(e){throw new A.aQ}init(e){e.subscribe(this._allocateWorkTextures,this,e),this._allocateWorkTextures(e)}release(e){this._deallocateWorkTextures(e),e.unsubscribe(this._allocateWorkTextures,this)}clearPorts(){let e;for(e in this._inputPorts)this._inputPorts[e].clearMessage();for(e in this._outputPorts)this._outputPorts[e].clearMessage()}inputNodes(){let e=[];for(let i in this._inputPorts){let a=this._inputPorts[i];a.incomingLink!=null&&e.push(a.incomingLink.node)}return e}isSource(){return!1}isSink(){return!1}_allocateWorkTextures(e){for(let i=0;i<this._tex.length;i++)this._tex[i]=e.texturePool.allocate()}_deallocateWorkTextures(e){for(let i=this._tex.length-1;i>=0;i--)this._tex[i]=e.texturePool.free(this._tex[i])}_visualize(e,i){let a=e.renderToCanvas(i);Bo||(document.body.appendChild(a),Bo=!0)}}class Dn extends Ee{constructor(e=void 0,i=void 0,a=void 0){super(e,i,a),s.A.assert(Object.keys(this._inputPorts).length==0)}isSource(){return!0}}class br extends Ee{constructor(e=void 0,i=void 0,a=void 0){super(e,i,a),s.A.assert(Object.keys(this._outputPorts).length==0)}export(){throw new A.aQ}isSink(){return!0}}let Sl=-1;class El{constructor(e,i){let a=i<E.MATCH_MAX_DISTANCE;return this._index=a?e|0:Sl,this._distance=a?+i:Number.POSITIVE_INFINITY,Object.freeze(this)}get index(){return this._index}get distance(){return this._distance}toString(){return`SpeedyKeypointMatch(${this.index},${this.distance})`}}class li{constructor(e,i,a=0,l=0,p=0,h=null){this._position=new ci(+e,+i),this._lod=+a,this._rotation=+l,this._score=+p,this._descriptor=h}toString(){return`SpeedyKeypoint(${this.x},${this.y})`}get position(){return this._position}get x(){return this._position.x}set x(e){this._position.x=+e}get y(){return this._position.y}set y(e){this._position.y=+e}get lod(){return this._lod}get scale(){return Math.pow(2,this._lod)}get rotation(){return this._rotation}get score(){return this._score}get descriptor(){return this._descriptor}}class xl extends li{constructor(e,i,a=0,l=0,p=0,h=null,I=new Ve(0,0)){super(e,i,a,l,p,h),this._flow=I}get flow(){return this._flow}}class Cl extends li{constructor(e,i,a=0,l=0,p=0,h=null,I=[]){super(e,i,a,l,p,h),this._matches=I}get matches(){return this._matches}}let Lt=null,No=0;class qt{constructor(){this._nodes=[],this._sequence=[],this._busy=!1}node(e){for(let i=0,a=this._nodes.length;i<a;i++)if(this._nodes[i].name===e)return this._nodes[i];return null}init(...e){if(this._nodes.length>0)throw new A.Er("The pipeline has already been initialized");if(e.length==0)throw new A.qw("Can't initialize the pipeline. Please specify its nodes");No++==0&&(s.A.assert(!Lt,"Duplicate SpeedyGPU instance"),Lt=new nl);for(let i=0;i<e.length;i++){let a=e[i];this._nodes.includes(a)||this._nodes.push(a)}this._sequence=qt._tsort(this._nodes),qt._validateSequence(this._sequence);for(let i=0;i<this._sequence.length;i++)this._sequence[i].init(Lt);return this}release(){if(this._nodes.length==0)throw new A.Er("The pipeline has already been released or has never been initialized");for(let e=this._sequence.length-1;e>=0;e--)this._sequence[e].release(Lt);return this._sequence.length=0,this._nodes.length=0,--No==0&&(Lt=Lt.release()),null}run(){if(s.A.assert(this._sequence.length>0,"The pipeline has not been initialized or has been released"),this._busy)return new c.i((a,l)=>{setTimeout(()=>this.run().then(a,l),0)});this._busy=!0;let e=this._sequence.filter(a=>a.isSink()),i=qt._createOutputTemplate(e);return d.w.logging==="diagnostic"&&s.A.log("%c RUNNING PIPELINE ","background:red;color:white;font-size:28pt;font-weight:bold"),qt._runSequence(this._sequence).then(()=>c.i.all(e.map(a=>a.export().turbocharge())).then(a=>a.reduce((l,p,h)=>(l[e[h].name]=p,l),i))).finally(()=>{for(let a=this._sequence.length-1;a>=0;a--)this._sequence[a].clearPorts();this._busy=!1,d.w.logging==="diagnostic"&&(s.A.log(`%c PIPELINE OUTPUT 
`,"background:green;color:white;font-size:16pt;font-weight:bold"),Object.keys(i).forEach(a=>{s.A.log("%c"+a+":","font-size:10pt;font-weight:bold",i[a])}))}).turbocharge()}get _gpu(){return Lt}static _runSequence(e,i=0,a=e.length){for(;i<a;i++){let l=e[i].execute(Lt);if(Lt.gl.flush(),typeof l<"u")return l.then(()=>qt._runSequence(e,i+1,a))}return c.i.resolve()}static _tsort(e){let i=qt._outlinks(e),a=e.map(I=>[I,!1]),l=new Set,p=new Array(e.length),h=p.length;for(;a.length>0;){let[I,P]=a.pop();if(P)p[--h]=I;else if(!l.has(I)){let v=i.get(I);if(l.add(I),a.push([I,!0]),a.push(...v.map(T=>[T,!1])),v.some(T=>l.has(T)&&!p.includes(T)))throw new A.Er("Pipeline networks cannot have cycles!")}}return p}static _outlinks(e){let i=new Map;for(let a=0;a<e.length;a++)i.set(e[a],[]);for(let a=0;a<e.length;a++){let l=e[a],p=l.inputNodes();for(let h=0;h<p.length;h++){let I=p[h],P=i.get(I);if(!P)throw new A.Er(`Can't initialize the pipeline. Missing node: ${I.fullName}. Did you forget to add it to the initialization list?`);P.includes(l)||P.push(l)}}return i}static _createOutputTemplate(e=[]){let i=Object.create(null);for(let a=e.length-1;a>=0;a--)i[e[a].name]=null;return i}static _validateSequence(e){if(e.length==0)throw new A.Er("Pipeline doesn't have nodes");if(e[0].isSource()){if(!e.find(i=>i.isSink()))throw new A.Er("Pipeline doesn't have a sink")}else throw new A.Er("Pipeline doesn't have a source")}}let Pl=2;class vl extends Dn{constructor(e=void 0){super(e,Pl,[fe().expects(z.Image)]),this._media=null,this._textureIndex=0}get media(){return this._media}set media(e){if(e!==null&&!(e instanceof an))throw new A.qw(`Not a SpeedyMedia: ${e}`);this._media=e}_run(e){if(this._media==null)throw new A.Er(`Did you forget to set the media of ${this.fullName}?`);this._textureIndex=(this._textureIndex+1)%this._tex.length;let i=this._tex[this._textureIndex];e.upload(this._media._source,i),this.output().swrite(i,this._media._format)}}let bl="bitmap";class wl extends br{constructor(e="image"){super(e,0,[de().expects(z.Image)]),this._mediaType=bl,this._bitmap=null,this._data=null,this._format=Ae.f5.RGBA,this._textureReader=new x(1)}get mediaType(){return this._mediaType}set mediaType(e){if(e!="bitmap"&&e!="data")throw new A.qw(`Invalid mediaType for ${this.fullName}: "${e}"`);this._mediaType=e}init(e){super.init(e),this._textureReader.init(e)}release(e){this._textureReader.release(e),super.release(e)}export(){let e=this._mediaType!="data"?this._bitmap:this._data;return s.A.assert(e!=null),an.load(e,{format:this._format},!1)}_run(e){let{image:i,format:a}=this.input().read();return this._mediaType!="data"?new c.i(l=>{let p=e.renderToCanvas(i);createImageBitmap(p,0,p.height-i.height,i.width,i.height).then(h=>{this._bitmap=h,this._format=a,this._data=null,l()})}):this._textureReader.readPixelsAsync(i,0,0,i.width,i.height,!1).then(l=>{let p=new Uint8ClampedArray(l.buffer);this._data=new ImageData(p,i.width,i.height),this._format=a,this._bitmap=null})}}let wr=["in0","in1"];class Tl extends Ee{constructor(e=void 0){super(e,0,[...wr.map(i=>de(i).expects(z.Image)),fe().expects(z.Image)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=wr.length)throw new A.qw(`Invalid port: ${e}`);this._port=e|0}_run(e){let i=this.input(wr[this._port]).read();this.output().write(i)}}class Ml extends Ee{constructor(e=void 0){super(e,2,[de().expects(z.Image),fe().expects(z.Image)]),this._pageIndex=0,this._initialized=!1,this._previousFormat=Ae.f5.RGBA,this._frozen=!1}get frozen(){return this._frozen}set frozen(e){this._frozen=!!e}release(e){this._initialized=!1,super.release(e)}_run(e){let{image:i,format:a}=this.input().read(),l=this._previousFormat,p=this._tex,h=p[1-this._pageIndex],I=p[this._pageIndex];if(i.hasMipmaps())throw new A.EM(`${this.fullName} can't bufferize a pyramid`);if((!this._frozen||!this._initialized)&&(this._previousFormat=a,h.resize(i.width,i.height),i.copyTo(h),this._pageIndex=1-this._pageIndex),!this._initialized){this._initialized=!0,this.output().swrite(h,a);return}this.output().swrite(I,l)}}let Tr=E.PYRAMID_MAX_LEVELS,Mr=2*Tr;class Bl extends Ee{constructor(e=void 0){super(e,Mr+1,[de().expects(z.Image),fe().expects(z.Image)])}_run(e){let{image:i,format:a}=this.input().read(),l=this._tex[0],p=e.programs.pyramids,h=i.width,I=i.height,P=1+Math.floor(Math.log2(Math.max(h,I))),v=new Array(Mr+1);for(let N=Mr;N>=1;N--)v[N-1]=this._tex[N];v[0].resize(h,I),i.copyTo(v[0]);let T=Math.min(P,Tr);for(let N=1;N<T;N++){let k=Math.max(1,h>>>1),K=Math.max(1,I>>>1),H=N-1+Tr;p.smoothX.outputs(h,I,v[H])(v[N-1]),p.smoothY.outputs(h,I,v[N-1])(v[H]),p.downsample2.outputs(k,K,v[N])(v[N-1]),e.gl.flush(),h=k,I=K}l.resize(i.width,i.height),l.clear(),i.copyTo(l),l.generateMipmaps(v.slice(0,T)),this.output().swrite(l,a)}}class Nl extends Ee{constructor(e=void 0){super(e,1,[de("in0").expects(z.Image),de("in1").expects(z.Image),fe().expects(z.Image)]),this._alpha=.5,this._beta=.5,this._gamma=0}get alpha(){return this._alpha}set alpha(e){this._alpha=+e}get beta(){return this._beta}set beta(e){this._beta=+e}get gamma(){return this._gamma}set gamma(e){this._gamma=+e}_run(e){let i=this.input("in0").read(),a=this.input("in1").read(),l=i.image,p=a.image,h=i.format,I=a.format,P=Math.max(l.width,p.width),v=Math.max(l.height,p.height),T=this._alpha,N=this._beta,k=this._gamma,K=this._tex[0];if(h!=I)throw new A.EM("Can't mix images of different formats");e.programs.transforms.additiveMix.outputs(P,v,K),e.programs.transforms.additiveMix(l,p,T,N,k),this.output().swrite(K,h)}}class Ro extends Ee{constructor(e=void 0){super(e,1,[de().expects(z.Image)]),this._format=Ae.f5.RGBA,this._initialized=!1}get image(){if(!this._initialized)throw new A.Er(`Portal error: ${this.fullName} holds no data`);return this._tex[0]}get format(){if(!this._initialized)throw new A.Er(`Portal error: ${this.fullName} holds no data`);return this._format}init(e){super.init(e),this._tex[0].resize(1,1).clear(),this._format=Ae.f5.RGBA,this._initialized=!0}release(e){this._initialized=!1,super.release(e)}_run(e){let{image:i,format:a}=this.input().read(),l=this._tex[0];if(i.hasMipmaps())throw new A.EM(`${this.fullName} can't store a pyramid`);this._format=a,l.resize(i.width,i.height),i.copyTo(l)}}class Rl extends Dn{constructor(e=void 0){super(e,0,[fe().expects(z.Image)]),this._source=null}get source(){return this._source}set source(e){if(e!==null&&!(e instanceof Ro))throw new A.qw(`Incompatible source for ${this.fullName}`);this._source=e}_run(e){if(this._source==null)throw new A.Er(`${this.fullName} has no source`);this.output().swrite(this._source.image,this._source.format)}}class Dl extends Se.Q{static Source(e=void 0){return new Rl(e)}static Sink(e=void 0){return new Ro(e)}}class kl extends Se.Q{static Source(e=void 0){return new vl(e)}static Sink(e=void 0){return new wl(e)}static Multiplexer(e=void 0){return new Tl(e)}static Buffer(e=void 0){return new Ml(e)}static Pyramid(e=void 0){return new Bl(e)}static Mixer(e=void 0){return new Nl(e)}static get Portal(){return Dl}}class Ql extends Ee{constructor(e=void 0){super(e,1,[de().expects(z.Image),fe().expects(z.Image)])}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._tex[0],I=e.programs.filters;I.rgb2grey.outputs(l,p,h),I.rgb2grey(i),this.output().swrite(h,Ae.f5.GREY)}}let di=Object.freeze({3:[.27901008925473514,.44197982149052983,.27901008925473514],5:[.06135959781344021,.2447701955296099,.3877404133138998,.2447701955296099,.06135959781344021],7:[.03873542500847274,.11308485700794121,.2150068609928349,.26634571398150225,.2150068609928349,.11308485700794121,.03873542500847274],9:[.028532262603370988,.067234535494912,.12400932997922749,.17904386461741617,.20236001461014655,.17904386461741617,.12400932997922749,.067234535494912,.028532262603370988],11:[.022656882730580346,.04610857898527292,.08012661469398517,.11890414969751599,.15067709325491124,.16305336127546846,.15067709325491124,.11890414969751599,.08012661469398517,.04610857898527292,.022656882730580346],13:[.018815730430644363,.03447396964662016,.05657737457255748,.08317258170844948,.10952340502389682,.12918787500405662,.13649812722755,.12918787500405662,.10952340502389682,.08317258170844948,.05657737457255748,.03447396964662016,.018815730430644363],15:[.016100340991695383,.027272329212157102,.042598338587449644,.06135478775568558,.08148767614129326,.09979838342934616,.11270444144735056,.11736740487004466,.11270444144735056,.09979838342934616,.08148767614129326,.06135478775568558,.042598338587449644,.027272329212157102,.016100340991695383]}),Br=new Ve(0,0),Ll=Object.freeze({3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"}),Kl=Object.freeze({3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"});class Ol extends Ee{constructor(e=void 0){super(e,2,[de().expects(z.Image),fe().expects(z.Image)]),this._kernelSize=new rt(5,5),this._sigma=Br,this._kernel={x:di[this._kernelSize.width],y:di[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){s.A.assert(e instanceof rt);let i=e.width,a=e.height;if(i<3||a<3||i>15||a>15||i%2==0||a%2==0)throw new A.EM(`Unsupported kernel size: ${i}x${a}`);this._kernelSize=e,this._updateKernel()}get sigma(){return this._sigma}set sigma(e){s.A.assert(e instanceof Ve,"Sigma must be a SpeedyVector2"),s.A.assert(e.x>=0&&e.y>=0),this._sigma=e,this._updateKernel()}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._kernel.x,I=this._kernel.y,P=Ll[this._kernelSize.width],v=Kl[this._kernelSize.height],T=this._tex[0],N=this._tex[1];e.programs.filters[P].outputs(l,p,T)(i,h),e.programs.filters[v].outputs(l,p,N)(T,I),this.output().swrite(N,a)}_updateKernel(){this._sigma.x==Br.x?this._kernel.x=di[this._kernelSize.width]:this._kernel.x=s.A.gaussianKernel(this._sigma.x,this._kernelSize.width,!0),this._sigma.y==Br.y?this._kernel.y=di[this._kernelSize.height]:this._kernel.y=s.A.gaussianKernel(this._sigma.y,this._kernelSize.height,!0)}}let Ai=Object.freeze({3:new Array(3).fill(1/3),5:new Array(5).fill(1/5),7:new Array(7).fill(1/7),9:new Array(9).fill(1/9),11:new Array(11).fill(1/11),13:new Array(13).fill(1/13),15:new Array(15).fill(1/15)}),zl=Object.freeze({3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"}),Fl=Object.freeze({3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"});class Ul extends Ee{constructor(e=void 0){super(e,2,[de().expects(z.Image),fe().expects(z.Image)]),this._kernelSize=new rt(5,5),this._kernel={x:Ai[this._kernelSize.width],y:Ai[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){s.A.assert(e instanceof rt);let i=e.width,a=e.height;if(i<3||a<3||i>15||a>15||i%2==0||a%2==0)throw new A.EM(`Unsupported kernel size: ${i}x${a}`);this._kernelSize=e,this._kernel.x=Ai[this._kernelSize.width],this._kernel.y=Ai[this._kernelSize.height]}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._kernel.x,I=this._kernel.y,P=zl[this._kernelSize.width],v=Fl[this._kernelSize.height],T=this._tex[0],N=this._tex[1];e.programs.filters[P].outputs(l,p,T)(i,h),e.programs.filters[v].outputs(l,p,N)(T,I),this.output().swrite(N,a)}}let Xl={3:"median3",5:"median5",7:"median7"};class Gl extends Ee{constructor(e=void 0){super(e,1,[de().expects(z.Image).satisfying(i=>i.format===Ae.f5.GREY),fe().expects(z.Image)]),this._kernelSize=new rt(5,5)}get kernelSize(){return this._kernelSize}set kernelSize(e){s.A.assert(e instanceof rt);let i=e.width;if(i==3||i==5||i==7){if(e.width!=e.height)throw new A.EM("Use a square kernel")}else throw new A.EM("Supported kernel sizes: 3x3, 5x5, 7x7");this._kernelSize=e}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._kernelSize.width,I=Xl[h],P=this._tex[0];e.programs.filters[I].outputs(l,p,P)(i),this.output().swrite(P,a)}}let Hl={3:"convolution3",5:"convolution5",7:"convolution7"};class ql extends Ee{constructor(e=void 0){super(e,1,[de().expects(z.Image),fe().expects(z.Image)]),this._kernel=Qt.SpeedyMatrix.Create(3,3,[0,0,0,0,1,0,0,0,0])}get kernel(){return this._kernel}set kernel(e){if(e.rows!=e.columns)throw new A.EM("Use a square kernel");if(!(e.rows==3||e.rows==5||e.rows==7))throw new A.EM("Invalid kernel size. Supported sizes: 3x3, 5x5, 7x7");this._kernel=e}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._tex[0],I=this._kernel.rows,P=Hl[I],v=this._kernel.read();e.programs.filters[P].outputs(l,p,h)(i,v),this.output().swrite(h,a)}}class Yl extends Ee{constructor(e=void 0){super(e,3,[de().expects(z.Image).satisfying(i=>i.format===Ae.f5.RGBA||i.format===Ae.f5.GREY),fe().expects(z.Image)]),this._gain=.5,this._offset=.5,this._decay=0,this._quality="medium"}get gain(){return this._gain}set gain(e){this._gain=+e}get offset(){return this._offset}set offset(e){this._offset=+e}get decay(){return this._decay}set decay(e){this._decay=Math.max(0,Math.min(+e,1))}get quality(){return this._quality}set quality(e){if(e==="high"||e==="medium"||e==="low")this._quality=e;else throw new A.qw(`Invalid quality level for the Nightvision filter: "${e}"`)}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._gain,I=this._offset,P=this._decay,v=this._quality,T=e.programs.filters,N=this._tex[0],k=this._tex[1],K=this._tex[2];v=="medium"?(T.illuminationMapX.outputs(l,p,N),T.illuminationMapY.outputs(l,p,k),T.illuminationMapX(i),T.illuminationMapY(N)):v=="high"?(T.illuminationMapHiX.outputs(l,p,N),T.illuminationMapHiY.outputs(l,p,k),T.illuminationMapHiX(i),T.illuminationMapHiY(N)):v=="low"&&(T.illuminationMapLoX.outputs(l,p,N),T.illuminationMapLoY.outputs(l,p,k),T.illuminationMapLoX(i),T.illuminationMapLoY(N)),a===Ae.f5.GREY?(T.nightvisionGreyscale.outputs(l,p,K),T.nightvisionGreyscale(i,k,h,I,P)):a===Ae.f5.RGBA&&(T.nightvision.outputs(l,p,K),T.nightvision(i,k,h,I,P)),this.output().swrite(K,a)}}class Wl extends Ee{constructor(e=void 0){super(e,4,[de().expects(z.Image).satisfying(i=>i.format===Ae.f5.GREY),fe().expects(z.Image)]),this._minValue=0,this._maxValue=255}get minValue(){return this._minValue}set minValue(e){this._minValue=Math.max(0,Math.min(+e,255))}get maxValue(){return this._maxValue}set maxValue(e){this._maxValue=Math.max(0,Math.min(+e,255))}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._tex[3],I=this._minValue,P=this._maxValue;I>P&&(I=P=(I+P)/2);let v=this._scanMinMax(e,i,Ae.kQ.GREEN);e.programs.filters.normalizeGreyscale.outputs(l,p,h),e.programs.filters.normalizeGreyscale(v,I,P),this.output().swrite(h,a)}_scanMinMax(e,i,a){let l=this._tex,p=e.programs.utils,h=i.width,I=i.height,P=Math.ceil(Math.log2(Math.max(h,I)))|0;s.A.assert(Ae.kg[a]!==void 0),p.copyComponents.outputs(h,I,l[2]),p.scanMinMax2D.outputs(h,I,l[0],l[1]);let v=p.copyComponents(i,i,Ae.kQ.ALL,Ae.kg[a]);for(let T=0;T<P;T++)v=p.scanMinMax2D(v,T);return v}}class Vl extends Se.Q{static Greyscale(e=void 0){return new Ql(e)}static GaussianBlur(e=void 0){return new Ol(e)}static SimpleBlur(e=void 0){return new Ul(e)}static MedianBlur(e=void 0){return new Gl(e)}static Convolution(e=void 0){return new ql(e)}static Nightvision(e=void 0){return new Yl(e)}static Normalize(e=void 0){return new Wl(e)}}let Jl=[0,0,0,0,0,0,0,0,1];class jl extends Ee{constructor(e=void 0){super(e,1,[de().expects(z.Image),fe().expects(z.Image)]),this._transform=Qt.SpeedyMatrix.Create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(!(e.rows==3&&e.columns==3))throw new A.qw(`Not a 3x3 transformation matrix: ${e}`);this._transform=e}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._tex[0],I=this._transform.read(),P=this._inverse3(I),v=!Number.isNaN(P[0]);e.programs.transforms.warpPerspective.outputs(l,p,h),e.programs.transforms.warpPerspective(i,v?P:Jl),this.output().swrite(h,a)}_inverse3(e,i=1e-6){let a=e[0],l=e[1],p=e[2],h=e[3],I=e[4],P=e[5],v=e[6],T=e[7],N=e[8],k=N*I-P*T,K=N*h-P*v,H=T*h-I*v,W=a*k-l*K+p*H;if(Math.abs(W)<i)e.fill(Number.NaN,0,9);else{let re=1/W;e[0]=k*re,e[1]=-(N*l-p*T)*re,e[2]=(P*l-p*I)*re,e[3]=-K*re,e[4]=(N*a-p*v)*re,e[5]=-(P*a-p*h)*re,e[6]=H*re,e[7]=-(T*a-l*v)*re,e[8]=(I*a-l*h)*re}return e}}class Zl extends Ee{constructor(e=void 0){super(e,1,[de().expects(z.Image),fe().expects(z.Image)]),this._size=new rt(0,0),this._scale=new Ve(1,1),this._method="bilinear"}get size(){return this._size}set size(e){this._size=e}get scale(){return this._scale}set scale(e){this._scale=e}get method(){return this._method}set method(e){if(e!=="nearest"&&e!=="bilinear")throw new A.qw(`Invalid method method: "${e}"`);this._method=e}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._tex[0],I=this._method,P=this._size.width||Math.max(1,this._scale.x*l),v=this._size.height||Math.max(1,this._scale.y*p);I=="bilinear"?e.programs.transforms.resizeBilinear.outputs(P,v,h)(i):I=="nearest"&&e.programs.transforms.resizeNearest.outputs(P,v,h)(i),this.output().swrite(h,a)}}class $l extends Se.Q{static Resize(e=void 0){return new Zl(e)}static PerspectiveWarp(e=void 0){return new jl(e)}}let ed=E.MAX_ENCODER_CAPACITY,td=E.DEFAULT_ENCODER_CAPACITY,nd=1.4142135623730951,id=2,Nr=0,Do=4,rd=2;class ke extends Ee{constructor(e=void 0,i=0,a=void 0){super(e,i+Nr,a),this._capacity=td,this._oldWrapS=0,this._tex16=new Array(id).fill(null)}init(e){super.init(e),this._oldWrapS=this._setupSpecialTexture(e.gl.TEXTURE_WRAP_S,e.gl.REPEAT),this._allocateTex16(e),e.subscribe(this._allocateTex16,this,e)}release(e){e.unsubscribe(this._allocateTex16,this),this._deallocateTex16(e),this._setupSpecialTexture(e.gl.TEXTURE_WRAP_S,this._oldWrapS),super.release(e)}_setupSpecialTexture(e,i){if(Nr==0)return;let a=this._tex[this._tex.length-1],l=a.gl;l.bindTexture(l.TEXTURE_2D,a.glTexture);let p=l.getTexParameter(l.TEXTURE_2D,e);return l.texParameteri(l.TEXTURE_2D,e,i),l.bindTexture(l.TEXTURE_2D,null),p}get capacity(){return this._capacity}set capacity(e){this._capacity=Math.min(Math.max(0,e|0),ed)}_encodeKeypoints(e,i,a,l=0,p=0){let h=this._capacity,I=ke.encoderLength(h,l,p),P=1<<(Math.ceil(Math.log2(i.width*i.height))>>>1),v=Math.ceil(i.width*i.height/P),T=Math.max(P,v),N=e.programs.keypoints;N.initLookupTable.outputs(P,v,this._tex16[1]),N.sortLookupTable.outputs(P,v,this._tex16[0],this._tex16[1]),N.encodeKeypoints.outputs(I,I,a);let k=N.initLookupTable(i);for(let K=1;K<T;K*=2)k=N.sortLookupTable(k,K,P,v);return N.encodeKeypoints(i,k,P,l,p,I,h)}_encodeKeypointsOLD(e,i,a,l=0,p=0){let h=this._capacity,I=ke.encoderLength(h,l,p),P=i.width,v=i.height,T=[P,v],N=this._tex.slice(this._tex.length-Nr),k=e.programs.keypoints,K=N.pop();k.encodeKeypointSkipOffsets.outputs(P,v,N[0]),k.encodeKeypointLongSkipOffsets.outputs(P,v,N[1],N[0]),k.encodeKeypointPositions.outputs(I,I,N[2],N[3]),k.encodeKeypointProperties.outputs(I,I,a),i=e.programs.utils.copy.outputs(P,v,K)(i);let H=k.encodeKeypointSkipOffsets(i,T);for(let re=0;re<rd;re++)H=k.encodeKeypointLongSkipOffsets(H,T);let W=N[3].clear();for(let re=0;re<Do;re++)W=k.encodeKeypointPositions(H,T,re,Do,h,W,l,p,I);return k.encodeKeypointProperties(i,W,l,p,I)}_encodeZeroKeypoints(e,i,a=0,l=0){let h=ke.encoderLength(0,a,l),I=e.programs.keypoints;return I.encodeNullKeypoints.outputs(h,h,i),I.encodeNullKeypoints()}_allocateTex16(e){let i=e.gl;for(let a=0;a<this._tex16.length;a++)this._tex16[a]=new M(i,1,1,i.RGBA_INTEGER,i.RGBA16UI,i.UNSIGNED_SHORT,i.NEAREST,i.CLAMP_TO_EDGE)}_deallocateTex16(e){for(let i=0;i<this._tex16.length;i++)this._tex16[i]=this._tex16[i].release()}static encoderLength(e,i,a){let l=Math.ceil((E.MIN_KEYPOINT_SIZE+i+a)/4),p=e*l;return Math.max(E.MIN_ENCODER_LENGTH,Math.ceil(Math.sqrt(p)))}static encoderCapacity(e,i,a){let l=Math.ceil((E.MIN_KEYPOINT_SIZE+e+i)/4),p=a*a;return Math.floor(p/l)}}class ko extends ke{constructor(e=void 0,i=void 0,a=void 0){super(e,i,a),this._levels=1,this._scaleFactor=nd}get levels(){return this._levels}set levels(e){this._levels=Math.max(1,e|0)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.max(1,Math.min(+e,2))}}let od=16384,Rr=1024,sd=Float32Array.BYTES_PER_ELEMENT*4;class pi extends Dn{constructor(e=void 0){super(e,2,[fe().expects(z.Keypoints)]),this._keypoints=[],this._buffer=pi._createUploadBuffer(Rr),this._capacity=E.DEFAULT_ENCODER_CAPACITY}get keypoints(){return this._keypoints}set keypoints(e){if(!Array.isArray(e))throw new A.qw("Not an array of keypoints");this._keypoints=e}get capacity(){return this._capacity}set capacity(e){this._capacity=Math.min(Math.max(0,e|0),E.MAX_ENCODER_CAPACITY)}_run(e){let l=this._keypoints,p=this._capacity,h=Math.min(l.length,p),I=Math.max(1,Math.ceil(h/Rr)),P=this._buffer,v=e.programs.keypoints.uploadKeypoints,T=ke.encoderLength(p,0,0);v.outputs(T,T,this._tex[0],this._tex[1]);let N=0,k=v.clear();for(let K=0;K<I;K++){let H=Math.min(Rr,h-N),W=N+H;v.setUBO("KeypointBuffer",pi._fillUploadBuffer(P,l,N,W)),k=v(k,N,W,0,0,T),N=W}this.output().swrite(k,0,0,T)}static _createUploadBuffer(e){let i=new ArrayBuffer(sd*e);return s.A.assert(i.byteLength<=od),new Float32Array(i)}static _fillUploadBuffer(e,i,a,l){let p=l-a;for(let h=0;h<p;h++){let I=i[a+h],P=I.position!==void 0,v=h*4;e[v]=+(P?I.position.x:I.x)||0,e[v+1]=+(P?I.position.y:I.y)||0,e[v+2]=+I.lod||0,e[v+3]=+I.score||0}return e}}class Dr{constructor(e){return this._data=e,Object.freeze(this)}get data(){return this._data}get size(){return this._data.byteLength}toString(){return`SpeedyKeypointDescriptor(${this._data.join(",")})`}}let ad=C=>C>1?1<<Math.ceil(Math.log2(C)):1,Qo=new Uint8Array([]);class kr extends br{constructor(e="keypoints",i=0,a=[]){super(e,i+2,a),this._keypoints=[],this._textureReader=new x,this._page=0,this._turbo=!1,this._includeDiscarded=!1}get turbo(){return this._turbo}set turbo(e){this._turbo=!!e}get includeDiscarded(){return this._includeDiscarded}set includeDiscarded(e){this._includeDiscarded=!!e}init(e){super.init(e),this._textureReader.init(e)}release(e){this._textureReader.release(e),super.release(e)}export(){return c.i.resolve(this._keypoints)}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read();return this._download(e,i,a,l,p)}_download(e,i,a,l,p){let h=this._turbo,I=ad(p),P=Math.ceil(p*p/I),v=this._tex[this._tex.length-1-this._page];return e.programs.utils.copyKeypoints.outputs(I,P,v)(i),this._page=1-this._page,this._textureReader.readPixelsAsync(v,0,0,v.width,v.height,h).then(T=>{this._keypoints=this._decode(T,a,l,I,P)})}_decode(e,i,a,l,p){let h=E.MIN_KEYPOINT_SIZE+i+a,I=E.LOG2_PYRAMID_MAX_SCALE,P=E.PYRAMID_MAX_LEVELS,v=Math.PI/255,T=[],N=this._includeDiscarded,k=Qo,K=Qo,H,W,re,Ne,Qe,xe,Ce,Je;if(i%4!=0||a%4!=0)throw new A.qw(`Invalid descriptorSize (${i}) / extraSize (${a})`);let je=l*p*4,at=e.byteLength;at!=je&&s.A.warning(`Expected ${je} bytes when decoding a set of keypoints, found ${at}`),i+a>0&&(e=new Uint8Array(e));for(let ue=0;ue<at&&(H=e[ue+1]<<8|e[ue],W=e[ue+3]<<8|e[ue+2],re=e[ue+5]<<8|e[ue+4],Ne=e[ue+7]<<8|e[ue+6],!(H==65535&&W==65535));ue+=h){if(H+W+re+Ne==0){N&&T.push(null);continue}if(a>0&&(K=e.subarray(8+ue,8+ue+a),K.byteLength<a)){s.A.warning(`KeypointSink: expected ${a} extra bytes when decoding the ${ue/h}-th keypoint, found ${K.byteLength} instead`);continue}if(i>0&&(k=e.subarray(8+ue+a,8+ue+a+i),k.byteLength<i)){s.A.warning(`KeypointSink: expected ${i} descriptor bytes when decoding the ${ue/h}-th keypoint, found ${k.byteLength} instead`);continue}H/=E.FIX_RESOLUTION,W/=E.FIX_RESOLUTION,Qe=e[ue+4]<255?-I+(I+P)*e[ue+4]/255:0,xe=(2*e[ue+5]-255)*v,Ce=s.A.decodeFloat16(Ne),Je=this._createKeypoint(H,W,Qe,xe,Ce,k,K),T.push(Je)}return T}_createKeypoint(e,i,a,l,p,h,I){throw new A.aQ}_allocateExtra(e,i,a,l,p,h,I){s.A.assert(p===0),s.A.assert(h===l&&I>0&&I%4===0);let P=a.width,T=ke.encoderCapacity(l,p,P),N=ke.encoderLength(T,h,I);return e.programs.keypoints.allocateExtra.outputs(N,N,i)(a,l,p,P,h,I,N)}}class cd extends kr{constructor(e="keypoints"){super(e,0,[de().expects(z.Keypoints)])}_createKeypoint(e,i,a,l,p,h,I){let v=h.byteLength>0?new Dr(h):null;return new li(e,i,a,l,p,v)}}class ld extends kr{constructor(e="keypoints"){super(e,2,[de().expects(z.Keypoints).satisfying(i=>i.extraSize==0),de("flow").expects(z.Vector2)])}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read(),{vectors:h}=this.input("flow").read(),I=a,P=4,v=this._allocateExtra(e,this._tex[0],i,a,l,I,P),T=v.width,N=e.programs.keypoints.transferToExtra.outputs(T,T,this._tex[1])(h,h.width,v,I,P,T);return this._download(e,N,I,P,T)}_createKeypoint(e,i,a,l,p,h,I){let P=h.byteLength,v=I.byteLength,T=P>0?new Dr(h):null,N=s.A.decodeFloat16(I[1]<<8|I[0]),k=s.A.decodeFloat16(I[3]<<8|I[2]),K=new Ve(N,k);return new xl(e,i,a,l,p,T,K)}}class dd extends kr{constructor(e="keypoints"){super(e,2,[de().expects(z.Keypoints).satisfying(i=>i.extraSize==0),de("matches").expects(z.KeypointMatches)])}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read(),{encodedMatches:h,matchesPerKeypoint:I}=this.input("matches").read(),P=a,v=I*4,T=this._allocateExtra(e,this._tex[0],i,a,l,P,v),N=T.width,k=e.programs.keypoints.transferToExtra.outputs(N,N,this._tex[1])(h,h.width,T,P,v,N);return this._download(e,k,P,v,N)}_createKeypoint(e,i,a,l,p,h,I){let P=h.byteLength,v=I.byteLength,T=P>0?new Dr(h):null,N=v/4,k=new Array(N);for(let K=0;K<N;K++){let H=K*4,W=I[H]|I[H+1]<<8|I[H+2]<<16|I[H+3]<<24,re=new El(W&E.MATCH_INDEX_MASK,W>>>E.MATCH_INDEX_BITS);k[K]=re}return new Cl(e,i,a,l,p,T,k)}}let Ad=5,Lo=E.MAX_ENCODER_CAPACITY;class pd extends Ee{constructor(e=void 0){super(e,4,[de().expects(z.Keypoints),fe().expects(z.Keypoints)]),this._size=Lo}get size(){return this._size}set size(e){this._size=Math.max(0,Math.min(e|0,Lo))}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read(),h=e.programs.keypoints,I=this._size,P=this._tex,v=this._tex[3],T=ke.encoderCapacity(a,l,p),N=1<<Ad,k=Math.ceil(T/N),K=N*k,H=Math.min(T,I),W=ke.encoderLength(H,a,l);h.sortCreatePermutation.outputs(N,k,P[0]);let re=h.sortCreatePermutation(i,a,l,p),Ne=Math.ceil(Math.log2(K));h.sortMergePermutation.outputs(N,k,P[1],P[2]);for(let Qe=1;Qe<=Ne;Qe++){let xe=1<<Qe,Ce=Qe<<1;re=h.sortMergePermutation(re,xe,Ce)}h.sortApplyPermutation.outputs(W,W,v),h.sortApplyPermutation(re,H,i,a,l),this.output().swrite(v,a,l,W)}}class ud extends Ee{constructor(e=void 0){super(e,5,[de().expects(z.Keypoints),fe().expects(z.Keypoints)]),this._imageSize=new rt(0,0),this._borderSize=new Ve(0,0)}get imageSize(){return this._imageSize}set imageSize(e){this._imageSize=e}get borderSize(){return this._borderSize}set borderSize(e){this._borderSize=e}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read(),h=e.programs.keypoints,I=this._imageSize,P=this._borderSize,v=I.width,T=I.height,N=P.x,k=P.x,K=P.y,H=P.y,W=this._tex;if(v==0||T==0)throw new A.Er("BorderClipper: did you forget to set the image size?");let re=ke.encoderCapacity(a,l,p),Ne=Math.max(1,Math.ceil(Math.sqrt(re)));h.clipBorder.outputs(p,p,W[0]),h.mixKeypointsInit.outputs(Ne,Ne,W[1]),h.mixKeypointsSort.outputs(Ne,Ne,W[2],W[3]),h.mixKeypointsApply.outputs(p,p,W[4]);let Qe=h.clipBorder(v,T,K,k,H,N,i,a,l,p),xe=h.mixKeypointsInit(Qe,a,l,p,re);for(let Ce=1;Ce<re;Ce*=2)xe=h.mixKeypointsSort(xe,Ce);Qe=h.mixKeypointsApply(xe,Qe,a,l,p),this.output().swrite(Qe,a,l,p)}}class hd extends Ee{constructor(e=void 0){super(e,2,[de().expects(z.Keypoints),fe().expects(z.Keypoints)]),this._pageIndex=0,this._initialized=!1,this._previousDescriptorSize=0,this._previousExtraSize=0,this._previousEncoderLength=0,this._frozen=!1}get frozen(){return this._frozen}set frozen(e){this._frozen=!!e}release(e){this._initialized=!1,super.release(e)}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read(),h=this._previousDescriptorSize,I=this._previousExtraSize,P=this._previousEncoderLength,v=this._tex,T=v[1-this._pageIndex],N=v[this._pageIndex];if((!this._frozen||!this._initialized)&&(this._previousDescriptorSize=a,this._previousExtraSize=l,this._previousEncoderLength=p,T.resize(p,p),i.copyTo(T),this._pageIndex=1-this._pageIndex),!this._initialized){this._initialized=!0,this.output().swrite(T,a,l,p);return}this.output().swrite(N,h,I,P)}}class gd extends Ee{constructor(e=void 0){super(e,5,[de("in0").expects(z.Keypoints),de("in1").expects(z.Keypoints),fe().expects(z.Keypoints)])}_run(e){let i=this.input("in0").read(),a=this.input("in1").read(),l=i.descriptorSize,p=i.extraSize,h=e.programs.keypoints,I=this._tex;if(!(i.descriptorSize===a.descriptorSize&&i.extraSize===i.extraSize))throw new A.Er("Can't merge two sets of keypoints that have different formats");let P=ke.encoderCapacity(i.descriptorSize,i.extraSize,i.encoderLength),v=ke.encoderCapacity(a.descriptorSize,a.extraSize,a.encoderLength),T=P+v,N=ke.encoderLength(T,l,p),k=Math.max(1,Math.ceil(Math.sqrt(T)));h.mixKeypointsPreInit.outputs(N,N,I[0]),h.mixKeypointsInit.outputs(k,k,I[1]),h.mixKeypointsSort.outputs(k,k,I[2],I[3]),h.mixKeypointsApply.outputs(N,N,I[4]);let K=h.mixKeypointsPreInit(i.encodedKeypoints,a.encodedKeypoints,i.encoderLength,a.encoderLength,P,v,l,p,N),H=h.mixKeypointsInit(K,l,p,N,T);for(let W=1;W<T;W*=2)H=h.mixKeypointsSort(H,W);K=h.mixKeypointsApply(H,K,l,p,N),this.output().swrite(K,l,p,N)}}class fd extends Ee{constructor(e=void 0){super(e,6,[de().expects(z.Keypoints),fe().expects(z.Keypoints)]),this._maxKeypoints=Number.NaN}get maxKeypoints(){return this._maxKeypoints}set maxKeypoints(e){Number.isNaN(e)?this._maxKeypoints=Number.NaN:this._maxKeypoints=Math.max(0,e|0)}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read(),h=ke.encoderCapacity(a,l,p),I=this._maxKeypoints,P=e.programs.keypoints.shuffle.definedConstant("PERMUTATION_MAXLEN"),v=Math.min(P,h),T=this._generatePermutation(v,P);i=e.programs.keypoints.shuffle.setUBO("Permutation",T).outputs(p,p,this._tex[0])(i,a,l,p),e.programs.keypoints.mixKeypointsInit.outputs(p,p,this._tex[1]),e.programs.keypoints.mixKeypointsSort.outputs(p,p,this._tex[2],this._tex[3]),e.programs.keypoints.mixKeypointsApply.outputs(p,p,this._tex[4]);let N=e.programs.keypoints.mixKeypointsInit(i,a,l,p,h);for(let k=1;k<h;k*=2)N=e.programs.keypoints.mixKeypointsSort(N,k);if(i=e.programs.keypoints.mixKeypointsApply(N,i,a,l,p),!Number.isNaN(I)&&I<h){let k=ke.encoderLength(I,a,l);i=e.programs.keypoints.clip.outputs(k,k,this._tex[5])(i,a,l,p,I),p=k}this.output().swrite(i,a,l,p)}_generatePermutation(e,i=e){let a=new Int32Array(i),l=a.subarray(0,e).fill(-1),p=s.A.shuffle(s.A.range(e));for(let h=0,I=0;h<e;h++)if(l[h]<0){do l[h]=p[I++];while(l[h]<h);l[l[h]]=h}return a}}let Qr=["in0","in1"];class md extends Ee{constructor(e=void 0){super(e,0,[...Qr.map(i=>de(i).expects(z.Keypoints)),fe().expects(z.Keypoints)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=Qr.length)throw new A.qw(`Invalid port: ${e}`);this._port=e|0}_run(e){let i=this.input(Qr[this._port]).read();this.output().write(i)}}class Id extends Ee{constructor(e=void 0){super(e,1,[de().expects(z.Keypoints),fe().expects(z.Keypoints)]),this._transform=Qt.SpeedyMatrix.Create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(!(e.rows==3&&e.columns==3))throw new A.qw(`Not a 3x3 transformation matrix: ${e}`);this._transform=e}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read(),h=this._tex[0],I=this._transform.read();e.programs.keypoints.applyHomography.outputs(i.width,i.height,h)(I,i,a,l,p),this.output().swrite(h,a,l,p)}}let Ko=Object.freeze({quadratic1d:"subpixelQuadratic1d",taylor2d:"subpixelTaylor2d","bicubic-upsample":"subpixelBicubic","bilinear-upsample":"subpixelBilinear"});class _d extends Ee{constructor(e=void 0){super(e,2,[de("image").expects(z.Image).satisfying(i=>i.format===Ae.f5.GREY),de("keypoints").expects(z.Keypoints),fe().expects(z.Keypoints),fe("displacements").expects(z.Vector2)]),this._method="quadratic1d",this._maxIterations=6,this._epsilon=.1}get method(){return this._method}set method(e){if(!Object.prototype.hasOwnProperty.call(Ko,e))throw new A.qw(`Invalid method: "${e}"`);this._method=e}get maxIterations(){return this._maxIterations}set maxIterations(e){this._maxIterations=Math.max(0,+e)}get epsilon(){return this._epsilon}set epsilon(e){this._epsilon=Math.max(0,+e)}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input("keypoints").read(),{image:h,format:I}=this.input("image").read(),P=this._tex,v=Ko[this._method],T=this._maxIterations,N=this._epsilon,k=ke.encoderCapacity(a,l,p),K=Math.max(1,Math.ceil(Math.sqrt(k))),H=e.programs.keypoints[v].outputs(K,K,P[0])(h,i,a,l,p,T,N),W=e.programs.keypoints.transferFlow.outputs(p,p,P[1])(H,i,a,l,p);this.output().swrite(W,a,l,p),this.output("displacements").swrite(H)}}let yd=20;class Sd extends ko{constructor(e=void 0){super(e,5,[de().expects(z.Image).satisfying(i=>i.format===Ae.f5.GREY),fe().expects(z.Keypoints)]),this._threshold=yd}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,Math.min(e|0,255))}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._tex,I=this._capacity,P=this._threshold,v=Math.log2(this.scaleFactor),T=this.levels;if(!(T==1||i.hasMipmaps()))throw new A.Er(`Expected a pyramid in ${this.fullName}`);if(I==0){let W=this._encodeZeroKeypoints(e,h[4]),re=W.width;this.output().swrite(W,0,0,re);return}e.programs.keypoints.fast9_16.outputs(l,p,h[0],h[1]),e.programs.keypoints.nonmaxSpace.outputs(l,p,h[2]);let N=h[1].clear(),k=Math.max(1,Math.min(T,E.PYRAMID_MAX_LEVELS/v|0));for(let W=v*(k-1);k-- >0;W-=v)N=e.programs.keypoints.fast9_16(N,i,W,P);N=e.programs.keypoints.nonmaxSpace(N),T>1&&(N=e.programs.keypoints.nonmaxScaleSimple.outputs(l,p,h[1])(N,i,v));let K=this._encodeKeypoints(e,N,h[3]),H=K.width;T>1&&(K=e.programs.keypoints.refineScaleFAST916.outputs(H,H,h[4])(i,v,K,0,0,H,P)),this.output().swrite(K,0,0,H)}}let Ed=Object.freeze({1:"harris1",3:"harris3",5:"harris5",7:"harris7"});class xd extends ko{constructor(e=void 0){super(e,6,[de().expects(z.Image).satisfying(i=>i.format===Ae.f5.GREY),fe().expects(z.Keypoints)]),this._windowSize=new rt(3,3),this._quality=.1}get quality(){return this._quality}set quality(e){this._quality=Math.max(0,Math.min(+e,1))}get windowSize(){return this._windowSize}set windowSize(e){let i=e.width;if(!(i==e.height&&(i==1||i==3||i==5||i==7)))throw new A.qw(`Invalid window: ${e}. Acceptable sizes: 1x1, 3x3, 5x5, 7x7`);this._windowSize=e}_run(e){let{image:i,format:a}=this.input().read(),l=i.width,p=i.height,h=this._capacity,I=this._quality,P=this._windowSize.width,v=this.levels,T=Math.log2(this.scaleFactor),N=v>1?this.scaleFactor:1,k=e.programs.keypoints[Ed[P]],K=this._tex;if(!(v==1||i.hasMipmaps()))throw new A.Er(`Expected a pyramid in ${this.fullName}`);if(h==0){let xe=this._encodeZeroKeypoints(e,K[5]),Ce=xe.width;this.output().swrite(xe,0,0,Ce);return}k.outputs(l,p,K[0],K[1]),e.programs.utils.sobelDerivatives.outputs(l,p,K[2]),e.programs.keypoints.nonmaxSpace.outputs(l,p,K[3]);let H=K[1].clear(),W=Math.max(1,Math.min(v,E.PYRAMID_MAX_LEVELS/T|0));for(let xe=T*(W-1);W-- >0;xe-=T){let Ce=s.A.gaussianKernel(N*(1+xe),P),Je=e.programs.utils.sobelDerivatives(i,xe);H=k(H,i,Je,xe,T,Ce),H=e.programs.keypoints.nonmaxSpace(H)}if(v>1){let xe=e.programs.keypoints.laplacian.outputs(l,p,K[0])(H,i,T,0);H=e.programs.keypoints.nonmaxScale.outputs(l,p,K[2])(H,i,xe,T)}e.programs.keypoints.harrisScoreFindMax.outputs(l,p,K[0],K[1]),W=Math.ceil(Math.log2(Math.max(l,p)));let re=H;for(let xe=0;xe<W;xe++)re=e.programs.keypoints.harrisScoreFindMax(re,xe);H=e.programs.keypoints.harrisScoreCutoff.outputs(l,p,re==K[0]?K[1]:K[0])(H,re,I);let Ne=this._encodeKeypoints(e,H,K[4]),Qe=Ne.width;v>1&&(Ne=e.programs.keypoints.refineScaleLoG.outputs(Qe,Qe,K[5])(i,T,Ne,0,0,Qe)),this.output().swrite(Ne,0,0,Qe)}}class Cd extends Ee{constructor(e=void 0,i=0,a=void 0){super(e,i+1,a)}_allocateDescriptors(e,i,a,l,p,h){s.A.assert(i>=0&&a>=0),s.A.assert(l>=0&&l%4===0&&p===a);let I=h.width,v=ke.encoderCapacity(i,a,I),T=ke.encoderLength(v,l,p),N=this._tex[this._tex.length-1];return e.programs.keypoints.allocateDescriptors.outputs(T,T,N)(h,i,a,I,l,p,T)}}let Oo=32;class Pd extends Cd{constructor(e=void 0){super(e,3,[de("image").expects(z.Image).satisfying(i=>i.format===Ae.f5.GREY),de("keypoints").expects(z.Keypoints),fe().expects(z.Keypoints)])}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input("keypoints").read(),h=this.input("image").read().image,I=this._tex,P=this._tex[2],v=ke.encoderCapacity(a,l,p),T=Math.max(1,Math.ceil(Math.sqrt(v))),N=e.programs.keypoints.orbOrientation.outputs(T,T,I[0])(h,i,a,l,p),k=e.programs.keypoints.transferOrientation.outputs(p,p,I[1])(N,i,a,l,p),K=this._allocateDescriptors(e,a,l,Oo,l,k),H=K.width,W=e.programs.keypoints.orbDescriptor.outputs(H,H,P)(h,K,l,H);this.output().swrite(W,Oo,l,H)}}let vd=new rt(11,11),bd=Math.min(3,E.PYRAMID_MAX_LEVELS),wd=30,Td=1e-4,Md=.01,Lr={3:"lk3",5:"lk5",7:"lk7",9:"lk9",11:"lk11",13:"lk13",15:"lk15",17:"lk17",19:"lk19",21:"lk21"};class Bd extends Ee{constructor(e=void 0){super(e,3,[de("previousImage").expects(z.Image).satisfying(i=>i.format===Ae.f5.GREY),de("nextImage").expects(z.Image).satisfying(i=>i.format===Ae.f5.GREY),de("previousKeypoints").expects(z.Keypoints),fe().expects(z.Keypoints),fe("flow").expects(z.Vector2)]),this._windowSize=vd,this._levels=bd,this._discardThreshold=Td,this._numberOfIterations=wd,this._epsilon=Md}get windowSize(){return this._windowSize}set windowSize(e){if(e.width!=e.height)throw new A.EM(`LK: window ${this._windowSize.toString()} is not square!`);if(!Object.prototype.hasOwnProperty.call(Lr,e.width)){let i=Object.keys(Lr).sort((a,l)=>a-l).map(a=>a+"x"+a).join(", ");throw new A.EM(`LK: window of size ${this._windowSize.toString()} is not supported! Supported sizes: ${i}`)}this._windowSize=e}get levels(){return this._levels}set levels(e){s.A.assert(e>=1&&e<=E.PYRAMID_MAX_LEVELS),this._levels=e|0}get discardThreshold(){return this._discardThreshold}set discardThreshold(e){s.A.assert(e>=0),this._discardThreshold=+e}get numberOfIterations(){return this._numberOfIterations}set numberOfIterations(e){s.A.assert(e>=1),this._numberOfIterations=e|0}get epsilon(){return this._epsilon}set epsilon(e){s.A.assert(e>=0),this._epsilon=+e}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input("previousKeypoints").read(),h=this.input("previousImage").read().image,I=this.input("nextImage").read().image,P=i,v=this._levels,N=this._windowSize.width,k=this._numberOfIterations,K=this._discardThreshold,H=this._epsilon,W=e.programs.keypoints,re=this._tex;if(v==1||h.hasMipmaps()&&I.hasMipmaps()){if(h.width!==I.width||h.height!==I.height)throw new A.Er("LK: can't use input images of different size")}else throw new A.Er("LK: a pyramid is required if levels > 1");let Ne=W[Lr[N]],Qe=ke.encoderCapacity(a,l,p),xe=Math.max(1,Math.ceil(Math.sqrt(Qe)));Ne.outputs(xe,xe,re[0],re[1]);let Ce=Ne.clear();for(let je=v-1;je>=0;je--)Ce=Ne(Ce,P,I,h,je,v,k,K,H,a,l,p);W.transferFlow.outputs(p,p,re[2]);let Je=W.transferFlow(Ce,P,a,l,p);this.output().swrite(Je,a,l,p),this.output("flow").swrite(Ce)}}class Nd extends Dn{constructor(e=void 0){super(e,2,[fe().expects(z.LSHTables)]),this._keypoints=[],this._keypointsCopy=[],this._numberOfTables=Rn,this._hashSize=Sr,this._lsh=null}get keypoints(){return this._keypoints}set keypoints(e){if(!Array.isArray(e)||e.find(i=>!(i instanceof li)))throw new A.qw("Static LSH tables: an invalid set of keypoints has been provided");this._keypoints!==e&&(this._keypoints=e,this._keypointsCopy=e.slice(0),this._lsh=null)}get numberOfTables(){return this._numberOfTables}set numberOfTables(e){if(!kt.includes(e))throw new A.qw(`Invalid number of tables: ${e}. Acceptable values: ${kt.join(", ")}`);e!==this._numberOfTables&&(this._numberOfTables=e|0,this._lsh=null)}get hashSize(){return this._hashSize}set hashSize(e){if(!gt.includes(e))throw new A.qw(`Invalid hash size: ${e}. Acceptable values: ${gt.join(", ")}`);e!==this._hashSize&&(this._hashSize=e|0,this._lsh=null)}_run(e){this._lsh==null&&(this._lsh=this._train()),this.output().swrite(this._lsh)}_train(){let e=this._keypointsCopy,i=this._numberOfTables,a=this._hashSize;if(e.find(I=>I.descriptor==null))throw new A.Er("Static LSH tables: can't train the model with no keypoint descriptors!");let l=e.map(I=>I.descriptor.data),p=this._tex[0],h=this._tex[1];return new Fa(p,h,l,i,a)}}let Rd=1,Dd="default",zo={fastest:0,default:1,demanding:2},ui=(C=>Er.reduce((e,i)=>(e[i]=C(i),e),{}))(C=>(e=>gt.reduce((i,a)=>(i[a]=e(a),i),{}))(e=>(i=>[0,1,2].reduce((a,l)=>(a[l]=i(l),a),{}))(i=>`lshKnn${C}h${e}lv${i}`)));class kd extends Ee{constructor(e=void 0){super(e,6,[de("keypoints").expects(z.Keypoints).satisfying(i=>i.descriptorSize>0),de("lsh").expects(z.LSHTables),fe().expects(z.KeypointMatches)]),this._k=Rd,this._quality=Dd}get k(){return this._k}set k(e){this._k=Math.max(1,e|0)}get quality(){return this._quality}set quality(e){if(!Object.prototype.hasOwnProperty.call(zo,e))throw new A.qw(`Invalid quality level: "${e}"`);this._quality=e}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input("keypoints").read(),h=this.input("lsh").read().lsh,I=e.programs.keypoints,P=h.tables,v=h.descriptorDB,T=P.width,N=v.width,k=h.tableCount,K=h.hashSize,H=h.bucketCapacity,W=h.bucketsPerTable,re=h.sequences,Ne=this._tex[0],Qe=this._tex[1],xe=this._tex[2],Ce=this._tex[3],Je=this._tex[4],je=this._tex[5],at=zo[this._quality],ue=this._k;if(a!==h.descriptorSize)throw new A.qw(`Can't match different types of descriptors in ${this.fullName}`);s.A.assert(ui[a]!=null),s.A.assert(ui[a][K]!=null),s.A.assert(ui[a][K][at]!=null);let ct=ke.encoderCapacity(a,l,p),Yt=Math.max(1,Math.ceil(Math.sqrt(ct*ue))),Et=je;I.lshKnnTransfer.outputs(Yt,Yt,Je,je);let Kt=Math.max(1,Math.ceil(Math.sqrt(ct)));I.lshKnnInitCandidates.outputs(Kt,Kt,Ne),I.lshKnnInitFilters.outputs(Kt,Kt,Ce);let gi=I[ui[a][K][at]];gi.outputs(Kt,Kt,Qe,xe),gi.setUBO("LSHSequences",re),Et.clear(),I.lshKnnInitFilters();for(let kn=0;kn<ue;kn++){let Wt=I.lshKnnInitCandidates();for(let ln=0;ln<k;ln++)Wt=gi(Wt,Ce,Kt,P,v,ln,H,W,T,N,i,a,l,p),e.gl.flush();Wt.copyTo(Ce),Et=I.lshKnnTransfer(Et,Wt,ue,kn)}this.output().swrite(Et,ue)}}let Fo={32:"bfMatcher32",64:"bfMatcher64"};class Qd extends Ee{constructor(e=void 0){super(e,6,[de("keypoints").expects(z.Keypoints).satisfying(i=>i.descriptorSize>0),de("database").expects(z.Keypoints).satisfying(i=>i.descriptorSize>0),fe().expects(z.KeypointMatches)]),this._matchesPerKeypoint=1}get k(){return this._matchesPerKeypoint}set k(e){this._matchesPerKeypoint=Math.max(1,e|0)}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input("keypoints").read(),h=this.input("database").read(),I=this._tex[0],P=this._tex[1],v=this._tex[2],T=this._tex[3],N=this._tex[4],k=this._tex[5],K=this._matchesPerKeypoint,H=e.programs.keypoints;if(a!==h.descriptorSize)throw new A.qw(`Incompatible descriptors in ${this.fullName}`);if(!Object.prototype.hasOwnProperty.call(Fo,a))throw new A.EM(`Unsupported descriptor size (${a}) in ${this.fullName}`);let W=H[Fo[a]],re=ke.encoderCapacity(a,l,p),Ne=ke.encoderCapacity(h.descriptorSize,h.extraSize,h.encoderLength),Qe=W.definedConstant("NUMBER_OF_KEYPOINTS_PER_PASS"),xe=Math.ceil(Ne/Qe),Ce=Math.max(1,Math.ceil(Math.sqrt(re))),Je=Math.max(1,Math.ceil(Math.sqrt(re*K)));H.bfMatcherTransfer.outputs(Je,Je,N,k),H.bfMatcherInitCandidates.outputs(Ce,Ce,v),H.bfMatcherInitFilters.outputs(Ce,Ce,T),W.outputs(Ce,Ce,I,P);let je=k.clear(),at=H.bfMatcherInitFilters();for(let ue=0;ue<K;ue++){let ct=H.bfMatcherInitCandidates();for(let Yt=0;Yt<xe;Yt++)ct=W(ct,at,Ce,h.encodedKeypoints,h.descriptorSize,h.extraSize,h.encoderLength,i,a,l,p,Yt),e.gl.flush();K>1&&ct.copyTo(at),je=H.bfMatcherTransfer(je,ct,K,ue)}this.output().swrite(je,K)}}class Ld extends Ee{constructor(e=void 0){super(e,1,[de("in").expects(z.Keypoints),de("reference").expects(z.Keypoints),fe().expects(z.Keypoints)]),this._threshold=E.MAX_TEXTURE_LENGTH+1}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,+e)}_run(e){let i=this.input("in").read(),a=this.input("reference").read(),l=this._threshold;if(i.descriptorSize!=a.descriptorSize||i.extraSize!=a.extraSize)throw new A.Er("The distance filter requires two compatible shapes of keypoint streams");let p=this._tex[0],h=Math.max(i.encoderLength,a.encoderLength),I=i.descriptorSize,P=i.extraSize;e.programs.keypoints.distanceFilter.outputs(h,h,p)(i.encodedKeypoints,i.encoderLength,a.encodedKeypoints,a.encoderLength,I,P,h,l),this.output().swrite(p,I,P,h)}}let Uo={32:"hammingDistanceFilter32",64:"hammingDistanceFilter64"};class Kd extends Ee{constructor(e=void 0){super(e,1,[de("in").expects(z.Keypoints).satisfying(i=>i.descriptorSize>0),de("reference").expects(z.Keypoints).satisfying(i=>i.descriptorSize>0),fe().expects(z.Keypoints)]),this._threshold=E.MAX_DESCRIPTOR_SIZE*8}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,e|0)}_run(e){let i=this.input("in").read(),a=this.input("reference").read(),l=this._threshold;if(i.descriptorSize!=a.descriptorSize||i.extraSize!=a.extraSize)throw new A.Er("The Hamming distance filter requires two compatible shapes of keypoint streams");if(!Object.prototype.hasOwnProperty.call(Uo,i.descriptorSize))throw new A.EM(`Hamming distance filter - invalid descriptor size: ${i.descriptorSize}`);let p=this._tex[0],h=Math.max(i.encoderLength,a.encoderLength),I=i.descriptorSize,P=i.extraSize,v=Uo[i.descriptorSize];e.programs.keypoints[v].outputs(h,h,p)(i.encodedKeypoints,i.encoderLength,a.encodedKeypoints,a.encoderLength,I,P,h,l),this.output().swrite(p,I,P,h)}}class Xo extends Ee{constructor(e=void 0){super(e,1,[de().expects(z.Keypoints)]),this._descriptorSize=0,this._extraSize=0,this._encoderLength=0,this._initialized=!1}get encodedKeypoints(){if(!this._initialized)throw new A.Er(`Portal error: ${this.fullName} holds no data`);return this._tex[0]}get descriptorSize(){if(!this._initialized)throw new A.Er(`Portal error: ${this.fullName} holds no data`);return this._descriptorSize}get extraSize(){if(!this._initialized)throw new A.Er(`Portal error: ${this.fullName} holds no data`);return this._extraSize}get encoderLength(){if(!this._initialized)throw new A.Er(`Portal error: ${this.fullName} holds no data`);return this._encoderLength}init(e){super.init(e);let i=ke.encoderLength(0,0,0);this._tex[0].resize(i,i).clearToColor(1,1,1,1),this._descriptorSize=this._extraSize=0,this._encoderLength=i,this._initialized=!0}release(e){this._initialized=!1,super.release(e)}_run(e){let{encodedKeypoints:i,descriptorSize:a,extraSize:l,encoderLength:p}=this.input().read(),h=this._tex[0];h.resize(i.width,i.height),i.copyTo(h),this._descriptorSize=a,this._extraSize=l,this._encoderLength=p}}class Od extends Dn{constructor(e=void 0){super(e,0,[fe().expects(z.Keypoints)]),this._source=null}get source(){return this._source}set source(e){if(e!==null&&!(e instanceof Xo))throw new A.qw(`Incompatible source for ${this.fullName}`);this._source=e}_run(e){if(this._source==null)throw new A.Er(`${this.fullName} has no source`);this.output().swrite(this._source.encodedKeypoints,this._source.descriptorSize,this._source.extraSize,this._source.encoderLength)}}class zd extends Se.Q{static FAST(e=void 0){return new Sd(e)}static Harris(e=void 0){return new xd(e)}}class Fd extends Se.Q{static ORB(e=void 0){return new Pd(e)}}class Ud extends Se.Q{static LK(e=void 0){return new Bd(e)}}class Xd extends Se.Q{static StaticLSHTables(e=void 0){return new Nd(e)}static LSHKNN(e=void 0){return new kd(e)}static BFKNN(e=void 0){return new Qd(e)}}class Gd extends Se.Q{static Source(e=void 0){return new Od(e)}static Sink(e=void 0){return new Xo(e)}}class Hd extends Se.Q{static get Detector(){return zd}static get Descriptor(){return Fd}static get Tracker(){return Ud}static get Matcher(){return Xd}static get Portal(){return Gd}static Source(e=void 0){return new pi(e)}static Sink(e=void 0){return new cd(e)}static SinkOfTrackedKeypoints(e=void 0){return new ld(e)}static SinkOfMatchedKeypoints(e=void 0){return new dd(e)}static Clipper(e=void 0){return new pd(e)}static BorderClipper(e=void 0){return new ud(e)}static Buffer(e=void 0){return new hd(e)}static Mixer(e=void 0){return new gd(e)}static Shuffler(e=void 0){return new fd(e)}static Multiplexer(e=void 0){return new md(e)}static Transformer(e=void 0){return new Id(e)}static SubpixelRefiner(e=void 0){return new _d(e)}static DistanceFilter(e=void 0){return new Ld(e)}static HammingDistanceFilter(e=void 0){return new Kd(e)}}let Go=C=>C>1?1<<Math.ceil(Math.log2(C)):1;class Kr extends br{constructor(e="vec2"){super(e,2,[de().expects(z.Vector2)]),this._vectors=[],this._textureReader=new x,this._page=0,this._turbo=!1}get turbo(){return this._turbo}set turbo(e){this._turbo=!!e}init(e){super.init(e),this._textureReader.init(e)}release(e){this._textureReader.release(e),super.release(e)}export(){return c.i.resolve(this._vectors)}_run(e){let{vectors:i}=this.input().read(),a=this._turbo,l=i.width,p=Go(l),h=Go(Math.ceil(l*l/p)),I=this._tex[this._page];return e.programs.utils.copy2DVectors.outputs(p,h,I)(i),this._page=1-this._page,this._textureReader.readPixelsAsync(I,0,0,I.width,I.height,a).then(P=>{this._vectors=Kr._decode(P,p,h)})}static _decode(e,i,a){let p=[],h=0,I=0,P=0,v=0,T=i*a*4,N=Math.min(e.length,T);for(let k=0;k<N&&(I=e[k+1]<<8|e[k],h=e[k+3]<<8|e[k+2],!(I==65535&&h==65535));k+=4)I==65280&&h==65280||(P=s.A.decodeFloat16(I),v=s.A.decodeFloat16(h),p.push(new Ve(P,v)));return p}}class qd extends Function{constructor(){return super("...args","return this._create(...args)"),this.bind(this)}_create(e,i){return new Ve(e,i)}Sink(e=void 0){return new Kr(e)}}let Yd=500,hi=null;class Or{constructor(){if(this._fps=60,this._frames=0,this._updateInterval=Yd,this._lastUpdate=performance.now(),this._boundUpdate=this._update.bind(this),hi!==null)throw new A.Er("Can't have multiple instances of FPSCounter");this._boundUpdate()}static get instance(){return hi===null&&(hi=new Or),hi}get fps(){return this._fps}_update(){let e=performance.now(),i=e-this._lastUpdate;i>=this._updateInterval&&(this._fps=Math.round(this._frames/(i*.001)),this._frames=0,this._lastUpdate=e),this._frames++,requestAnimationFrame(this._boundUpdate)}}let Wd=new rl,Vd=new qd;class zr{static get version(){return"0.9.1"}static isSupported(){return typeof WebAssembly<"u"&&typeof WebGL2RenderingContext<"u"&&r.c.instance.gl!=null}static get Settings(){return d.w}static get Vector2(){return Vd}static Point2(e,i){return new ci(e,i)}static Size(e,i){return new rt(e,i)}static get Matrix(){return Wd}static get Promise(){return c.i}static Pipeline(){return new qt}static get Image(){return kl}static get Filter(){return Vl}static get Transform(){return $l}static get Keypoint(){return Hd}static load(e,i={}){return an.load(e,i)}static camera(e=640,i=360){let a=typeof e=="object"?e:{audio:!1,video:{width:e|0,height:i|0}};return s.A.requestCameraStream(a).then(l=>an.load(l))}static get Platform(){return il}static get fps(){return Or.instance.fps}}Object.freeze(zr),s.A.log(`Speedy Vision version ${zr.version}. GPU-accelerated Computer Vision for JavaScript by Alexandre Martins. https://github.com/alemart/speedy-vision`),E.LITTLE_ENDIAN||s.A.warning("Running on a big-endian machine")})(),o=o.default,o})())});var lt,Z,Pe,dt,Ot,_i,yi,xt,ft,Qn,Si,Le=ce(()=>{"use strict";lt=class extends Error{constructor(n="",o=null){super(n);this.cause=o}toString(){let n=this.cause?`
-> `+this.cause.toString():"";return this.message!=""?this.name+": "+this.message+n:this.name+n}},Z=class extends lt{get name(){return"IllegalArgumentError"}},Pe=class extends lt{get name(){return"IllegalOperationError"}},dt=class extends lt{get name(){return"NotSupportedError"}},Ot=class extends lt{get name(){return"AccessDeniedError"}},_i=class extends lt{get name(){return"TimeoutError"}},yi=class extends lt{get name(){return"AssertionError"}},xt=class extends lt{get name(){return"NumericalError"}},ft=class extends lt{get name(){return"TrackingError"}},Qn=class extends lt{get name(){return"DetectionError"}},Si=class extends lt{get name(){return"TrainingError"}}});function Zo(y,t){let n=nA(y),o=0,r=0;if(Number.isNaN(n))throw new Z("Invalid resolution: "+y);if(t<=0)throw new Z("Invalid aspect ratio: "+t);return t>=1?(r=n,o=Math.floor(r*t),o+=o%2):(o=n,r=Math.floor(o/t),r+=r%2),jo.default.Size(o,r)}function nA(y){if(Jo.hasOwnProperty(y))return Jo[y];if(y.endsWith("p")){let t=y[0];if(t>="1"&&t<="9")return parseInt(y)}return Number.NaN}var jo,Jo,$o=ce(()=>{"use strict";jo=Re(be(),1);Le();Jo={xs:120,"xs+":144,sm:240,"sm+":288,md:320,"md+":360,lg:480,"lg+":600,xl:720,"xl+":900,xxl:1080}});var Ln,X,Fe=ce(()=>{"use strict";Ln=Re(be(),1);Le();$o();X=class y{static log(t,...n){console.log("[encantar-js]",t,...n)}static warning(t,...n){console.warn("[encantar-js]",t,...n)}static error(t,...n){console.error("[encantar-js]",t,...n)}static assert(t,n=""){if(!t)throw new yi(n)}static range(t){if((t|=0)<0)throw new Z;return Array.from({length:t},(n,o)=>o)}static shuffle(t){for(let n=t.length-1;n>=1;n--){let o=Math.floor(Math.random()*(n+1)),r=t[n];t[n]=t[o],t[o]=r}return t}static wait(t){return new Ln.default.Promise(n=>{setTimeout(n,t)})}static runInSequence(t){return t.reduce((n,o)=>n.then(()=>o),Ln.default.Promise.resolve())}static resolution(t,n){return Zo(t,n)}static isIOS(){return/(iOS|iPhone|iPad|iPod)/i.test(navigator.platform)?!0:/Mac/i.test(navigator.platform)&&navigator.maxTouchPoints!==void 0?navigator.maxTouchPoints>2:!1}static isWebKit(){return!!(/Apple/.test(navigator.vendor)||/AppleWebKit\/.* Version\//.test(navigator.userAgent)||/(CriOS\/|FxiOS\/|EdgiOS\/)/.test(navigator.userAgent))}static deviceInfo(){return"Device info: "+JSON.stringify({isIOS:y.isIOS(),isWebKit:y.isWebKit(),renderer:Ln.default.Platform.renderer,vendor:Ln.default.Platform.vendor,screen:[screen.width,screen.height].join("x"),platform:[navigator.platform,navigator.vendor].join("; "),userAgent:navigator.userAgent,userAgentData:navigator.userAgentData||null},null,2)}}});var Jt,jt,Kn=ce(()=>{"use strict";Jt=class extends Event{constructor(t){super(t)}get type(){return super.type}},jt=class{constructor(){this._delegate=new EventTarget}addEventListener(t,n){this._delegate.addEventListener(t,n)}removeEventListener(t,n){this._delegate.removeEventListener(t,n)}dispatchEvent(t){return this._delegate.dispatchEvent(t)}}});var On,es=ce(()=>{"use strict";On=class{constructor(){this._timeOfLastUpdate=this._now(),this._partialCycleCount=0,this._cyclesPerSecond=0}update(){let t=this._now();++this._partialCycleCount,t>=this._timeOfLastUpdate+1e3*.5&&(this._cyclesPerSecond=this._partialCycleCount/.5,this._partialCycleCount=0,this._timeOfLastUpdate=t)}reset(){this._timeOfLastUpdate=this._now(),this._partialCycleCount=0,this._cyclesPerSecond=0}get cyclesPerSecond(){return this._cyclesPerSecond}_now(){return performance.now()}}});var ts,ns,is,Ei,Ct,Pt,vt,At,Ze,$e,pt,ut,bt,xi,rs,iA,os,ss,as,cs,ls,yn,Sn,En,xn,ds,zt,wt,rA,Ci,As,ps,us,hs,gs,fs,ms,Ft=ce(()=>{"use strict";ts=.0234375,ns=8,is=15,Ei=!0,Ct=.3,Pt=.5,vt=0,At="low",Ze=9,$e=2,pt=5,ut=1,bt="bilinear-upsample",xi=4,rs=.6,iA=1024*.0125*.5|0,os=iA/(1024/2),ss=.8,as=1,cs=8,ls=4,yn=200,Sn=2048,En=.005,xn=!1,ds=.15,zt=ds*1.2,wt=1-2*ds,rA=1024*.0125|0,Ci=rA/(1024/2),As=15,ps=.7,us=20,hs=.3,gs=1,fs=6,ms=1.33});var Pi,Ur,Is=ce(()=>{"use strict";Ft();Pi=class{constructor(){this._visible=!1,this._imageTrackerGizmos=new Ur}get visible(){return this._visible}set visible(t){this._visible=t}_render(t,n){if(this._visible)for(let o=0;o<n.length;o++){let r=n[o];if(r.is("image-tracker")){let s=r._output;this._imageTrackerGizmos.render(t,s)}}}},Ur=class{render(t,n){let r=t._backgroundCanvas.getContext("2d",{alpha:!1});if(!r)return;let s=t._realSize,d=n.keypointsNIS,c=n.polylineNDC,u=n.camera;d!==void 0&&this._splitAndRenderKeypointsNIS(r,d,s),c!==void 0&&this._renderPolylineNDC(r,c,s),u!==void 0&&this._renderAxes(r,u,s)}_splitAndRenderKeypointsNIS(t,n,o,r=1){if(n.length==0)return;if(!Object.prototype.hasOwnProperty.call(n[0],"_matches")){this._renderKeypointsNIS(t,n,o,"#f00",r);return}let s=[],d=[];for(let c=0;c<n.length;c++){let u=n[c];this._isGoodMatch(u)?s.push(u):d.push(u)}this._renderKeypointsNIS(t,d,o,"#f00",r),this._renderKeypointsNIS(t,s,o,"#0f0",r)}_isGoodMatch(t){let o=t.matches.length;return o>1?t.matches[0].index>=0&&t.matches[1].index>=0&&t.matches[0].distance<=.7*t.matches[1].distance:o==1?t.matches[0].index>=0:!1}_renderKeypointsNIS(t,n,o,r="red",s=1){let d=o.width/1024,c=o.height/1024;t.beginPath();for(let u=n.length-1;u>=0;u--){let g=n[u],f=g.x*d+.5|0,b=g.y*c+.5|0,A=s*g.scale+.5|0;t.rect(f-A,b-A,2*A,2*A)}t.strokeStyle=r,t.lineWidth=1,t.stroke()}_renderPolylineNDC(t,n,o,r="#0f0",s=2){let d=n.length,c=o.width,u=o.height;if(d!=0){t.beginPath(),t.moveTo((n[d-1].x*.5+.5)*c,(n[d-1].y*-.5+.5)*u);for(let g=0;g<d;g++)t.lineTo((n[g].x*.5+.5)*c,(n[g].y*-.5+.5)*u);t.strokeStyle=r,t.lineWidth=s,t.stroke()}}_renderAxes(t,n,o,r=4){let u=["#f00","#0f0","#00f"],g=1,f=o.width,b=o.height,A=1/(n.imageSize.width/2),_=-1/(n.imageSize.height/2),m=n.matrix.read(),x=g,E=[m[9],m[10],m[11]],w=[x*m[0]+m[9],x*m[1]+m[10],x*m[2]+m[11]],M=[x*m[3]+m[9],x*m[4]+m[10],x*m[5]+m[11]],S=[x*m[6]+m[9],x*m[7]+m[10],x*m[8]+m[11]],D=[w,M,S],B=E[0]/E[2],Q=E[1]/E[2];for(let U=0;U<3;U++){let O=D[U],R=O[0]/O[2],F=O[1]/O[2];t.beginPath(),t.moveTo((B*A*.5+.5)*f,(Q*_*.5+.5)*b),t.lineTo((R*A*.5+.5)*f,(F*_*.5+.5)*b),t.strokeStyle=u[U],t.lineWidth=r,t.stroke()}}}});var vi,_s=ce(()=>{"use strict";vi=class{constructor(t,n){this._session=t,this._results=n}get session(){return this._session}get results(){return this._results[Symbol.iterator]()}}});var Zt,bi=ce(()=>{"use strict";Zt=class{of(t){return this.tracker.is(t)}}});var wi,ys=ce(()=>{"use strict";wi=class{constructor(){this._scale=1;this._time=0;this._unscaledTime=0;this._delta=0;this._firstUpdate=0;this._lastUpdate=Number.POSITIVE_INFINITY}_update(t){if(t<this._lastUpdate){this._firstUpdate=this._lastUpdate=t;return}this._delta=(t-this._lastUpdate)*this._scale,this._time+=this._delta,this._unscaledTime=t-this._firstUpdate,this._lastUpdate=t}get elapsed(){return this._time*.001}get delta(){return this._delta*.001}get scale(){return this._scale}set scale(t){this._scale=Math.max(0,+t)}get unscaled(){return this._unscaledTime*.001}}});function xs(y,...t){Xr.unshift(y),Ss.unshift(t),window.postMessage(Es,"*")}var Xr,Ss,Es,Cs=ce(()=>{"use strict";Xr=[],Ss=[],Es="asap"+Math.random().toString(36).substr(1);window.addEventListener("message",y=>{if(y.source!==window||y.data!==Es||(y.stopPropagation(),Xr.length==0))return;let t=Xr.pop(),n=Ss.pop();t.apply(void 0,n)},!0)});var ot,Gr,dn,Hr,$t,An,qr=ce(()=>{"use strict";ot=Re(be(),1);zn();Fe();Kn();Le();Pn();es();Is();_s();bi();ys();Cs();Gr=class extends Jt{},dn={mode:"immersive",trackers:[],sources:[],viewport:null,stats:!1,gizmos:!1},Hr=class extends Zt{constructor(t){super(),this.tracker=t,this.trackables=[]}},$t=class $t extends jt{constructor(t,n,o,r,s){if(super(),this._mode=n,this._trackers=[],this._sources=t,this._updateStats=new On,this._renderStats=new On,this._active=!0,this._frameReady=!0,this._rafQueue=[],this._time=new wi,this._gizmos=new Pi,this._gizmos.visible=s,n!="immersive"&&n!="inline")throw new Z(`Invalid session mode "${n}"`);this._primarySource=this._findPrimarySource(t),this._viewport=o,this._primarySource!==null?this._viewport._init(()=>this._primarySource._internalMedia.size,n,r):this._viewport._init(()=>X.resolution("sm",window.innerWidth/window.innerHeight),n,r),$t._count++,X.log(`The ${this._mode} session is now active!`)}static isSupported(){if(/(Mac|iOS|iPhone|iPad|iPod)/i.test(navigator.platform)){let t=/(iPhone|iPad|iPod).* (CPU[\s\w]* OS|CPU iPhone|iOS) ([\d\._]+)/.exec(navigator.userAgent),n=/(AppleWebKit)\/.* (Version)\/([\d\.]+)/.exec(navigator.userAgent),o=n||t;if(o!==null){let r=o[3]||"0.0",[s,d]=r.split(/[\._]/).map(c=>parseInt(c)|0);if(s<15||s==15&&d<2)return X.error(`${o===n?"Safari":"iOS"} version ${r} is not supported! User agent: ${navigator.userAgent}`),!1}else X.warning(`Unrecognized user agent: ${navigator.userAgent}`)}return ot.default.isSupported()}static instantiate(t=dn){let{mode:n=dn.mode,sources:o=dn.sources,trackers:r=dn.trackers,viewport:s=dn.viewport,stats:d=dn.stats,gizmos:c=dn.gizmos}=t;return X.log(`Starting a new ${n} session...`),ot.default.Promise.resolve().then(()=>{if(!$t.isSupported())throw new dt("You need a browser/device compatible with WebGL2 and WebAssembly in order to experience Augmented Reality with encantar.js");if(n!=="inline"&&$t.count>0)throw new Pe("Can't start multiple sessions, except in inline mode");if(!/^\d+\.\d+(\.\d+)*$/.test(st.version)&&!["localhost","127.0.0.1","[::1]","","encantar.dev","alemart.github.io"].includes(location.hostname)&&!(location.hostname.startsWith("192.168.")||location.hostname.startsWith("10.")||/^172\.(1[6-9]|2[0-9]|3[01])\./.test(location.hostname))){let g="This is a development build (unstable). Do not use it in production. Get a stable release at encantar.dev";if(X.warning(g),!confirm(g+`

Are you sure you want to continue?`))throw new Ot("Aborted")}return ot.default.Matrix.ready()}).then(()=>{for(let u=o.length-1;u>=0;u--)if(o.indexOf(o[u])<u)throw new Z("Found repeated sources of data");return ot.default.Promise.all(o.map(u=>u._init()))}).then(()=>{if(!s)throw new Z("Can't create a session without a viewport");return new $t(o,n,s,d,c)}).then(u=>{r.length==0&&X.warning("No trackers have been attached to the session!");for(let g=r.length-1;g>=0;g--)if(r.indexOf(r[g])<g)throw new Z("Found repeated trackers");return ot.default.Promise.all(r.map(g=>u._attachTracker(g))).then(()=>u)}).then(u=>(u._startMainLoop(),u)).catch(u=>{throw X.error(`Can't start session: ${u.message}`),u})}static get count(){return this._count}end(){return this._active?(X.log("Shutting down the session..."),this._active=!1,X.wait(100).then(()=>ot.default.Promise.all(this._trackers.map(t=>t._release()))).then(()=>ot.default.Promise.all(this._sources.map(t=>t._release()))).then(()=>{this._sources.length=0,this._trackers.length=0,this._updateStats.reset(),this._renderStats.reset(),this._viewport._release(),$t._count--;let t=new Gr("end");this.dispatchEvent(t),X.log("Session ended.")})):ot.default.Promise.resolve()}requestAnimationFrame(t){let n=Symbol("raf-handle");return this._active&&this._rafQueue.push([n,t]),n}cancelAnimationFrame(t){for(let n=this._rafQueue.length-1;n>=0;n--)if(this._rafQueue[n][0]===t){this._rafQueue.splice(n,1);break}}get mode(){return this._mode}get ended(){return!this._active}get time(){return this._time}get gizmos(){return this._gizmos}get viewport(){return this._viewport}get trackers(){return this._trackers[Symbol.iterator]()}get sources(){return this._sources[Symbol.iterator]()}_startMainLoop(){this._setupUpdateLoop(),this._setupRenderLoop(),X.log("The main loop has been started!")}_findPrimarySource(t){for(let n=0;n<t.length;n++){let o=t[n];if(o._is("video-source"))return o}for(let n=0;n<t.length;n++){let o=t[n];if(o._is("canvas-source"))return o}return X.warning("No primary source of data was found!"),null}_attachTracker(t){return this._trackers.indexOf(t)>=0?ot.default.Promise.reject(new Z("Duplicate tracker attached to the session")):this._active?(this._trackers.push(t),t._init(this)):ot.default.Promise.reject(new Pe("Inactive session"))}_renderBackground(){let n=this._viewport._backgroundCanvas.getContext("2d",{alpha:!1});if(n){if(n.imageSmoothingEnabled=!1,this._primarySource!==null){let o=this._primarySource._internalMedia;this._renderMedia(n,o,!0)}for(let o=0;o<this._trackers.length;o++){let r=this._trackers[o]._output.image;r!==void 0&&this._renderMedia(n,r,!1)}this._gizmos._render(this._viewport,this._trackers)}}_renderMedia(t,n,o){let r=t.canvas,s=o?r.width:n.width,d=o?r.height:n.height;if(n.type!="data"){let c=n.source;t.drawImage(c,0,0,s,d)}else{let c=n.source;t.putImageData(c,0,0,0,0,s,d)}}_setupUpdateLoop(){let t=()=>{if(this._active)Ye.powerPreference=="high-performance"?xs(o):window.requestAnimationFrame(o);else return},n=()=>{this._update().then(t).turbocharge()};function o(){Ye.powerPreference=="low-power"?window.requestAnimationFrame(n):n()}window.requestAnimationFrame(n)}_update(){return this._active?ot.default.Promise.all(this._trackers.map(t=>t._update().turbocharge())).then(()=>{this._updateStats.update(),this._frameReady=!0}).catch(t=>{X.error("Tracking error: "+t.toString(),t);let n=t.cause;if(t.name=="GLError")throw alert(t.message),alert(X.deviceInfo()),t;if(typeof n=="object"&&n.name=="GLError")throw alert(t.message),alert(n.message),alert(X.deviceInfo()),t}):(this._updateStats.reset(),ot.default.Promise.resolve())}_setupRenderLoop(){let t=!1,n=!1,o=r=>{let s=Ye.powerPreference=="low-power",d=Ye.powerPreference=="high-performance";this._time._update(r),(!s||!(t=!t))&&this._render(r),this._active&&window.requestAnimationFrame(o)};window.requestAnimationFrame(o)}_render(t,n=!1){if(this._active)if(this._frameReady){let o=this._trackers.map(c=>c._output.exports||new Hr(c)),r=new vi(this,o),s=this._rafQueue.slice(0);this._rafQueue.length=0,n||this._renderBackground();for(let c=0;c<s.length;c++)s[c][1].call(void 0,t,r);this._renderStats.update(),this._frameReady=!1,this._viewport.hud._statsPanel.update(t,this._sources,this._trackers,this._viewport,this._updateStats.cyclesPerSecond,this._renderStats.cyclesPerSecond)}else this._renderStats.update();else this._renderStats.reset()}};$t._count=0;An=$t});var Yr,Ye,Pn=ce(()=>{"use strict";Yr=Re(be(),1);qr();Le();Fe();Ye=class{static get powerPreference(){return this._powerPreference}static set powerPreference(t){if(An.count>0)throw new Pe("Can't change the powerPreference while there are active sessions going on");if(!(t=="low-power"||t=="default"||t=="high-performance"))throw new Z(`Invalid powerPreference: "${t}"`);t=="high-performance"?Yr.default.Settings.gpuPollingMode="asap":Yr.default.Settings.gpuPollingMode="raf",this._powerPreference=t,X.log(`Changed the powerPreference to "${this._powerPreference}"`)}};Ye._powerPreference="default"});var Ti,Ps=ce(()=>{"use strict";Ti=class{constructor(t,n){this._referenceImage=Object.assign({},t),this._media=n,this._referenceImage.name===void 0&&(this._referenceImage.name=this._generateUniqueName()),this._aspectRatio=n.width/n.height}get name(){return this._referenceImage.name}set name(t){this._referenceImage.name=t}get image(){return this._referenceImage.image}get media(){return this._media}get aspectRatio(){return this._aspectRatio}_generateUniqueName(){return"target-"+Math.random().toString(16).substr(2)}}});var Mi,oA,Bi,vs=ce(()=>{"use strict";Mi=Re(be(),1);Ps();Fe();Le();oA=100,Bi=class{constructor(){this._capacity=oA,this._entries=new Map,this._locked=!1}get count(){return this._entries.size}get capacity(){return this._capacity}set capacity(t){let n=Math.max(0,t|0);if(this.count>n)throw new Z(`Can't set the capacity of the database to ${n}: it currently stores ${this.count} entries`);this._capacity=n}[Symbol.iterator](){return this._entries.values()}add(t){return this._preloadMany(t).then(n=>{n.forEach(o=>{this._addOne(o)})})}_addOne(t){let n=t.name;if(this._locked)throw new Pe(`Can't add reference image "${n}" to the database: it's locked`);if(this.count>=this.capacity)throw new Pe(`Can't add reference image "${n}" to the database: the capacity of ${this.capacity} images has been exceeded.`);if(!(t.image instanceof HTMLImageElement)&&!(t.image instanceof ImageBitmap)&&!(t.image instanceof ImageData))throw new Z(`Can't add reference image "${n}" to the database: invalid image`);if(this._entries.has(n))throw new Z(`Can't add reference image "${n}" to the database: found duplicated name`);X.log(`Adding reference image "${n}" to the database...`),this._entries.set(n,t)}_lock(){this._locked=!0}_find(t){return this._entries.get(t)||null}_preloadOne(t){return t.name!==void 0?X.log(`Loading reference image "${t.name}"...`):X.log("Loading reference image..."),t.image?Mi.default.load(t.image).then(n=>new Ti(t,n)):Mi.default.Promise.reject(new Z("The reference image was not provided!"))}_preloadMany(t){let n=t.length;X.log(`Loading ${n} reference image${n!=1?"s":""}...`);let o=t.map(r=>this._preloadOne(r));return Mi.default.Promise.all(o)}}});var bs,tt,pn=ce(()=>{"use strict";bs=Re(be(),1);Le();tt=class{constructor(t,n){this._name=t,this._imageTracker=n,this._pipeline=this._createPipeline(),this._pipelineReleased=!1}get name(){return this._name}get screenSize(){let t=this._pipeline.node("screen");if(!t)throw new Pe;return t.size}init(){}release(){return this._pipelineReleased||(this._pipeline.release(),this._pipelineReleased=!0),null}update(t,n){let o=this._pipeline.node("source"),r=this._pipeline.node("screen");if(!o||!r)throw new Pe;return o.media=t,r.size=n,this._beforeUpdate().then(()=>this._gpuUpdate()).then(s=>this._afterUpdate(s))}onEnterState(t){}onLeaveState(){}_beforeUpdate(){return bs.default.Promise.resolve()}_gpuUpdate(){return this._pipeline.run()}}});var we,Ni,ws=ce(()=>{"use strict";we=Re(be(),1);pn();Ft();Fe();Ni=class extends tt{constructor(t){super("initial",t)}_beforeUpdate(){return this._pipeline.node("source").media.size.area()<this.screenSize.area()&&X.warning("The resolution of the tracker is larger than the resolution of the video. This is inefficient."),we.default.Promise.resolve()}_afterUpdate(t){return we.default.Promise.resolve({nextState:"training",trackerOutput:{}})}onLeaveState(){this._pipeline.release(),this._pipelineReleased=!0}_createPipeline(){let t=we.default.Pipeline(),n=we.default.Image.Source("source"),o=we.default.Transform.Resize("screen"),r=we.default.Filter.Greyscale(),s=we.default.Transform.PerspectiveWarp(),d=we.default.Filter.Nightvision(),c=we.default.Image.Multiplexer(),u=we.default.Keypoint.Detector.Harris(),g=we.default.Keypoint.Descriptor.ORB(),f=we.default.Filter.GaussianBlur(),b=we.default.Keypoint.Clipper(),A=we.default.Keypoint.BorderClipper(),_=we.default.Filter.GaussianBlur(),m=we.default.Keypoint.SubpixelRefiner(),x=we.default.Keypoint.Matcher.BFKNN(),E=we.default.Keypoint.Transformer(),w=we.default.Keypoint.Portal.Sink(),M=we.default.Keypoint.Portal.Source(),S=we.default.Keypoint.Multiplexer(),D=we.default.Keypoint.Buffer(),B=we.default.Keypoint.Multiplexer(),Q=we.default.Keypoint.SinkOfMatchedKeypoints();return n.media=null,o.size=we.default.Size(0,0),s.transform=we.default.Matrix.Eye(3),d.quality=At,m.method=bt,A.imageSize=we.default.Size(100,100),A.borderSize=we.default.Vector2(0,0),x.k=1,E.transform=we.default.Matrix.Eye(3),M.source=w,S.port=0,B.port=0,D.frozen=!1,Q.turbo=!1,n.output().connectTo(o.input()),o.output().connectTo(r.input()),r.output().connectTo(s.input()),s.output().connectTo(c.input("in0")),s.output().connectTo(d.input()),d.output().connectTo(c.input("in1")),c.output().connectTo(f.input()),c.output().connectTo(u.input()),u.output().connectTo(A.input()),A.output().connectTo(b.input()),s.output().connectTo(_.input()),_.output().connectTo(m.input("image")),b.output().connectTo(m.input("keypoints")),f.output().connectTo(g.input("image")),m.output().connectTo(g.input("keypoints")),g.output().connectTo(S.input("in0")),B.output().connectTo(S.input("in1")),S.output().connectTo(x.input("database")),g.output().connectTo(x.input("keypoints")),M.output().connectTo(B.input("in0")),D.output().connectTo(B.input("in1")),M.output().connectTo(D.input()),g.output().connectTo(w.input()),g.output().connectTo(E.input()),E.output().connectTo(Q.input()),x.output().connectTo(Q.input("matches")),t.init(n,o,r,s,d,c,f,u,m,b,A,_,g,M,S,x,D,B,E,Q,w),t}}});function uA(y,t,n){if(y.rows!=2||t.rows!=2||y.columns!=t.columns)throw new Z("Bad input");if(n.rows!=3||n.columns!=3)throw new Z("Bad intrinsics");let o=y.columns;if(o<4)throw new Z("solvePlanarPnP requires at least 4 points");o>Ut&&(o=Ut);let r=n.read(),s=r[0],d=r[4],c=r[6],u=r[7];un[0]=1/s,un[4]=1/d,un[6]=-c/s,un[7]=-u/d,un[8]=1;let g=Us(s),f=y.read(),b=t.read();for(let L=0,J=0;L<o;L++,J+=2){let ye=Ts[L],ie=Ms[L];ye[0]=f[J],ye[1]=f[J+1],ye[2]=1,ie[0]=b[J],ie[1]=b[J+1],ie[2]=1}for(let L=0;L<o;L++)hn(Tt[L],un,Ts[L]),qn(Tt[L],Tt[L],g);for(let L=0;L<o;L++)hn(mt[L],un,Ms[L]),jr(mt[L],mt[L]);It[0]=It[1]=It[2]=0;for(let L=0;L<o;L++){let J=Tt[L];It[0]+=J[0],It[1]+=J[1],It[2]+=J[2]}It[0]/=o,It[1]/=o,It[2]/=o;for(let L=0;L<o;L++)nn(Bs[L],Tt[L],It);if(cA){let L=mA(Tt,mt,o);if(Number.isNaN(L[0]))return Oi;let J=zi(L,mt[0]);for(let ye=0;ye<o;ye++)en[ye]=J/zi(L,mt[ye])}else{en[0]=1;for(let L=3;L<o;L+=3){let ye=L-2,ie=L-1,Ie=Fs(Tt,mt,o,0,ye,ie,L);if(Number.isNaN(Ie[0]))return Oi;en[ye]=Ie[0],en[ie]=Ie[1],en[L]=Ie[2],L+3>=o&&(L-=2)}}_t[0]=_t[1]=_t[2]=0;for(let L=0;L<o;L++){let J=mt[L],ye=en[L];_t[0]+=ye*J[0],_t[1]+=ye*J[1],_t[2]+=ye*J[2]}_t[0]/=o,_t[1]/=o,_t[2]/=o;for(let L=0;L<o;L++)qn(Ri,mt[L],en[L]),nn(Ri,Ri,_t),jr(Ns[L],Ri);let A=0,_=0,m=0,x=0,E=0,w=0;for(let L=0;L<o;L++){let J=Bs[L],ye=Ns[L];A+=ye[0]*J[0],_+=ye[1]*J[1],m+=ye[0]*J[1],x+=ye[1]*J[0],E+=ye[2]*J[0],w+=ye[2]*J[1]}let M=A*A,S=_*_,D=m*m,B=x*x,Q=E*E,U=w*w,O=M*(S+U)+D*(B+Q)+B*U+S*Q-2*(A*m*(x*_+E*w)+x*_*E*w),R=Math.sqrt(M+D+B+S+Q+U+2*Math.sqrt(O));if(Mt[0]=A-_-R,Mt[1]=m+x,Mt[2]=E,Mt[3]=m+x,Mt[4]=-A+_-R,Mt[5]=w,Mt[6]=E,Mt[7]=w,Mt[8]=-(A+_+R),Di[0]=-w,Di[1]=E,Di[2]=m-x,hn(Fn,$r(lA,Mt),Di),Number.isNaN(Fn[0]))return Oi;let F=Fn[0],q=Fn[1],j=Fn[2],V=1,te=Math.sqrt(F*F+q*q+j*j+V*V);Un[0]=F/te,Un[1]=q/te,Un[2]=j/te,Un[3]=V/te;let ge=fA(Tt,o,0),Be=en[ge],Oe=zi(mt[ge],mt[0]),qe=Xs(Tt[ge],Tt[0])/(Be*(Be-2*Oe)+1),le=Math.sqrt(qe);EA(Wr,Un),qn(Rs,_t,le),nn(Ds,Rs,hn(dA,Wr,It));for(let L=0;L<9;L++)Vr[L]=Wr[L];for(let L=0;L<3;L++)Vr[9+L]=Ds[L];return et.default.Matrix(3,4,Vr)}function hA(y,t,n,o={}){let r=Object.assign({},Ks,o),s=r.numberOfHypotheses,d=r.reprojectionError,c=r.acceptablePercentageOfInliers,u=r.mask,g=y.columns;if(g<4)throw new Z("solvePlanarPnP requires at least 4 points");let f=yt(n.read()),b=Zr(0),A=new Array(g);A.fill(0);let _=y.read(),m=t.read(),x=X.range(g),E=new Array(2*4),w=new Array(2*4),M=et.default.Matrix.Zeros(2,4),S=et.default.Matrix.Zeros(2,4),D=Number.POSITIVE_INFINITY,B=Oi;for(let Q=0;Q<s;Q++){X.shuffle(x),IA(M,S,E,w,_,m,x);let U=uA(M,S,n);b.set(U.read());let O=zs(f,b),R=gA(O,_,m,d,A),F=0;for(let V=0;V<g;V++)F+=A[V];let q=U,j=R;if(!(j>D)&&(D=j,B=q,F/g>=c))break}return u?.setToSync(et.default.Matrix(1,g,A)),B}function Os(y,t,n,o={}){let r=y.columns,s=Object.assign({},pA,o),d=Math.max(0,Math.min(s.refinementQuality,1)),c=s.reprojectionError,u=s.mask;if(r<4)return et.default.Promise.reject(new Z("find6DofHomography() requires at least 4 points"));if(y.columns!=t.columns||y.rows!=2||t.rows!=2)return et.default.Promise.reject(new Z("Bad input"));if(n.columns!=3||n.rows!=3)return et.default.Promise.reject(new Z("Bad intrinsics"));let g=hA(y,t,n,o),f=yt(n.read()),b=Zr(g.read()),A=zs(f,b),_=Array.from(A),m=et.default.Matrix(3,3,_);if(d==0||Number.isNaN(_[0]))return et.default.Promise.resolve(m);let x=y,E=t,w=et.default.Matrix.Zeros(2,r);return et.default.Matrix.applyPerspectiveTransform(w,x,m).then(M=>et.default.Matrix.findHomography(et.default.Matrix.Zeros(3),M,E,{method:"pransac",numberOfHypotheses:Math.ceil(512*d),bundleSize:Math.ceil(128*d),reprojectionError:c,mask:u})).then(M=>M.setTo(M.times(m)))}function zs(y,t){let n=y[0],o=y[4],r=y[6],s=y[7],d=Us(n);tn[0]=d/n,tn[5]=d/o,tn[10]=d,tn[12]=-r*d/n,tn[13]=-s*d/o,tn[14]=d,tn[15]=1,hn(Nt,t,tn),Rt[0]=Nt[0],Rt[1]=Nt[1],Rt[2]=Nt[2],Rt[3]=Nt[3],Rt[4]=Nt[4],Rt[5]=Nt[5],Rt[6]=Nt[9],Rt[7]=Nt[10],Rt[8]=Nt[11],hn(Ki,y,Rt);let c=1/Ki[8];for(let u=0;u<9;u++)Ki[u]*=c;return Ki}function gA(y,t,n,o=3,r=[]){let[s,d,c,u,g,f,b,A,_]=y,[m,x,E,w,M,S,D,B,Q]=$r(AA,y),U=t.length/2,O=o*o,R=0;if(r.length=U,r.fill(0),Number.isNaN(s*m))return Number.POSITIVE_INFINITY;for(let F=0,q=0;F<U;F++,q+=2){let j=t[q+0],V=t[q+1],te=1,ge=n[q+0],Be=n[q+1],Oe=1,Xe=s*j+u*V+b*te,qe=d*j+g*V+A*te,le=c*j+f*V+_*te,L=Xe/le,J=qe/le,ye=ge/Oe,ie=Be/Oe,Ie=L-ye,We=J-ie,se=Ie*Ie+We*We,Y=m*ge+w*Be+D*Oe,ae=x*ge+M*Be+B*Oe,ne=E*ge+S*Be+Q*Oe,$=Y/ne,ee=ae/ne,_e=j/te,ve=V/te,pe=$-_e,Se=ee-ve,Ge=pe*pe+Se*Se;R+=se+Ge,r[F]=+(se<O&&Ge<O)}return R/U}function fA(y,t,n=0){let o=y[n];if(t>y.length)throw new Z;let r=0,s=0;for(let d=0;d<t;d++){let c=Xs(o,y[d]);c>r&&(r=c,s=d)}return s}function mA(y,t,n){if(y.length<4||t.length<4||y.length!=t.length||n>y.length)throw new Z;let o=0,r=Math.floor((n-1)/3),s=Math.floor((n-1)*2/3),d=n-1,c=Fs(y,t,n,o,r,s,d);if(Number.isNaN(c[0]))return Ke(Number.NaN);let u=t[o],g=t[r],f=t[s];return qn(Qi,g,c[0]),nn(Qi,Qi,u),qn(Li,f,c[1]),nn(Li,Li,u),jr(Jr,SA(Jr,Qi,Li)),Jr}function Fs(y,t,n,o,r,s,d){if(y.length<4||t.length<4||y.length!=t.length||n>y.length)throw new Z;if(Math.min(o,r,s,d)<0||Math.max(o,r,s,d)>=n)throw new Z;let c=y[o],u=y[r],g=y[s],f=y[d],b=t[o],A=t[r],_=t[s],m=t[d];nn(Xn,u,c),nn(Gn,g,c),nn(Hn,f,c);let x=Xn[0]*Gn[1]-Xn[1]*Gn[0];if(Math.abs(x)<Ls)return Ke(Number.NaN);let E=(Gn[1]*Hn[0]-Gn[0]*Hn[1])/x,w=(Xn[0]*Hn[1]-Xn[1]*Hn[0])/x,M=E+w-1;return ki[0]=M*b[0],ki[1]=M*b[1],ki[2]=M*b[2],Bt[0]=E*A[0],Bt[1]=E*A[1],Bt[2]=E*A[2],Bt[3]=w*_[0],Bt[4]=w*_[1],Bt[5]=w*_[2],Bt[6]=-m[0],Bt[7]=-m[1],Bt[8]=-m[2],$r(ks,Bt),hn(Qs,ks,ki),Qs}function Us(y,t=aA,n=sA){let r=y/20;return t/n*r}function IA(y,t,n,o,r,s,d){X.assert(d.length>=4&&n.length==4*2&&o.length==4*2&&y.rows==2&&y.columns==4&&t.rows==2&&t.columns==4);for(let u=0;u<4;u++){let g=d[u];for(let f=0;f<2;f++)n[u*2+f]=r[g*2+f],o[u*2+f]=s[g*2+f]}y.data.set(n),t.data.set(o)}function vn(y,t=y,n=0){if(typeof y=="object")return vn(y._rows,y._cols,y);let o=typeof n=="object";if(o&&n.length!=y*t)throw new Z;let r=o?new Float64Array(n):new Float64Array(y*t);return r._rows=y,r._cols=t,typeof n=="number"&&r.fill(n),r}function yt(y){return vn(3,3,y)}function _A(y){return vn(4,4,y)}function Zr(y){return vn(3,4,y)}function Ke(y){return vn(3,1,y)}function yA(y){return vn(4,1,y)}function nn(y,t,n){let o=t._rows,r=t._cols,s=n._rows,d=n._cols,c=y._rows,u=y._cols;if(o!=s||r!=d||o!=c||r!=u)throw new Z;for(let g=0;g<y.length;g++)y[g]=t[g]-n[g];return y}function hn(y,t,n){let o=t._rows,r=t._cols,s=n._rows,d=n._cols,c=y._rows,u=y._cols;if(c!=o||u!=d||r!=s)throw new Z;y.fill(0);for(let g=0;g<u;g++)for(let f=0;f<o;f++)for(let b=0;b<r;b++)y[g*c+f]+=t[b*o+f]*n[g*s+b];return y}function qn(y,t,n){if(t._rows!=y._rows||t._cols!=y._cols)throw new Z;for(let o=0;o<y.length;o++)y[o]=t[o]*n;return y}function $r(y,t){if(t._rows!=y._rows||t._cols!=y._cols)throw new Z;let n=t[4]*t[8]-t[7]*t[5],o=t[3]*t[8]-t[6]*t[5],r=t[3]*t[7]-t[6]*t[4],s=t[1]*t[8]-t[7]*t[2],d=t[0]*t[8]-t[6]*t[2],c=t[0]*t[7]-t[6]*t[1],u=t[1]*t[5]-t[4]*t[2],g=t[0]*t[5]-t[3]*t[2],f=t[0]*t[4]-t[3]*t[1],b=t[0]*n-t[1]*o+t[2]*r;if(Math.abs(b)<Ls)return y.fill(Number.NaN);let A=1/b;return y[0]=n*A,y[1]=-s*A,y[2]=u*A,y[3]=-o*A,y[4]=d*A,y[5]=-g*A,y[6]=r*A,y[7]=-c*A,y[8]=f*A,y}function jr(y,t){let n=zi(t,t),o=Math.sqrt(n);return y[0]=t[0]/o,y[1]=t[1]/o,y[2]=t[2]/o,y}function Xs(y,t){let n=y[0]-t[0],o=y[1]-t[1],r=y[2]-t[2];return n*n+o*o+r*r}function zi(y,t){return y[0]*t[0]+y[1]*t[1]+y[2]*t[2]}function SA(y,t,n){return y[0]=t[1]*n[2]-t[2]*n[1],y[1]=t[2]*n[0]-t[0]*n[2],y[2]=t[0]*n[1]-t[1]*n[0],y}function EA(y,t){let n=t[0],o=t[1],r=t[2],s=t[3],d=2*n*n,c=2*o*o,u=2*r*r,g=2*n*o,f=2*n*r,b=2*o*r,A=2*s*n,_=2*s*o,m=2*s*r;return y[0]=1-(c+u),y[1]=g+m,y[2]=f-_,y[3]=g-m,y[4]=1-(d+u),y[5]=b+A,y[6]=f+_,y[7]=b-A,y[8]=1-(d+c),y}var et,sA,aA,cA,Ls,Ut,Oi,un,Ts,Ms,Tt,mt,Bs,Ns,en,It,_t,Ri,Mt,lA,Di,Fn,Wr,Un,dA,Rs,Ds,Vr,Xn,Gn,Hn,ki,Bt,ks,Qs,Qi,Li,Jr,Ki,AA,Nt,Rt,tn,Ks,pA,Gs=ce(()=>{"use strict";et=Re(be(),1);Fe();Le();sA=5*.001,aA=20*.01,cA=!1,Ls=1e-8,Ut=1024,Oi=et.default.Matrix(3,4,new Array(12).fill(Number.NaN)),un=yt(0),Ts=Array.from({length:Ut},()=>Ke(0)),Ms=Array.from({length:Ut},()=>Ke(0)),Tt=Array.from({length:Ut},()=>Ke(0)),mt=Array.from({length:Ut},()=>Ke(0)),Bs=Array.from({length:Ut},()=>Ke(0)),Ns=Array.from({length:Ut},()=>Ke(0)),en=new Array(Ut).fill(0),It=Ke(0),_t=Ke(0),Ri=Ke(0),Mt=yt(0),lA=yt(0),Di=Ke(0),Fn=Ke(0),Wr=yt(0),Un=yA(0),dA=Ke(0),Rs=Ke(0),Ds=Ke(0),Vr=new Array(12).fill(0),Xn=Ke(0),Gn=Ke(0),Hn=Ke(0),ki=Ke(0),Bt=yt(0),ks=yt(0),Qs=Ke(0),Qi=Ke(0),Li=Ke(0),Jr=Ke(0),Ki=yt(0),AA=yt(0),Nt=Zr(0),Rt=yt(0),tn=_A(0),Ks={numberOfHypotheses:100,reprojectionError:3,acceptablePercentageOfInliers:Number.POSITIVE_INFINITY,mask:null},pA=Object.assign({},Ks,{refinementQuality:1})});var ze,oe,bn=ce(()=>{"use strict";ze=Re(be(),1);Fe();Le();Ft();Gs();oe=class{static rasterToNIS(t){let n=1024/t.width,o=1024/t.height;return ze.default.Matrix(3,3,[n,0,0,0,o,0,0,0,1])}static rasterToNDC(t){let n=t.width,o=t.height;return ze.default.Matrix(3,3,[2/n,0,0,0,-2/o,0,-1,1,1])}static NDCToRaster(t){let n=t.width,o=t.height;return ze.default.Matrix(3,3,[n/2,0,0,0,-o/2,0,n/2,o/2,1])}static scaleNDC(t,n=t){return ze.default.Matrix(3,3,[t,0,0,0,n,0,0,0,1])}static bestFitScaleNDC(t,n=1){return t>=1?this.scaleNDC(n,n/t):this.scaleNDC(n*t,n)}static inverseBestFitScaleNDC(t,n=1){return t>=1?this.scaleNDC(1/n,t/n):this.scaleNDC(1/(n*t),1/n)}static bestFitAspectRatioNDC(t,n){let o=t.width/t.height;return n.aspectRatio/o}static compilePairsOfKeypointsNDC(t){let n=t.length;if(n==0)throw new Z;let o=2/1024,r=new Array(2*2*n);for(let s=0,d=0,c=2*n;s<n;s++,d+=2,c+=2){let u=t[s][0],g=t[s][1];r[d]=u.x*o-1,r[d+1]=1-u.y*o,r[c]=g.x*o-1,r[c+1]=1-g.y*o}return ze.default.Matrix(2,2*n,r)}static interpolateHomographies(t,n,o,r=0,s=0,d=0){let c=new Array(4),u=new Array(8),g=[-1,1,1,1,1,-1,-1,-1],f=t.read(),b=n.read();for(let S=0,D=0;S<4;S++,D+=2){let B=g[D],Q=g[D+1],U=f[0]*B+f[3]*Q+f[6],O=f[1]*B+f[4]*Q+f[7],R=f[2]*B+f[5]*Q+f[8],F=b[0]*B+b[3]*Q+b[6],q=b[1]*B+b[4]*Q+b[7],j=b[2]*B+b[5]*Q+b[8],V=F/j-U/R,te=q/j-O/R;c[S]=V*V+te*te}let A=0,_=0,m=0,x=1,E=Math.max(c[0],c[1],c[2],c[3]),w=Math.min(c[0],c[1],c[2],c[3]);if(E<1e-5)return ze.default.Promise.resolve(ze.default.Matrix(n));for(let S=0,D=0;S<4;S++,D+=2){let B=g[D],Q=g[D+1],U=f[0]*B+f[3]*Q+f[6],O=f[1]*B+f[4]*Q+f[7],R=f[2]*B+f[5]*Q+f[8],F=b[0]*B+b[3]*Q+b[6],q=b[1]*B+b[4]*Q+b[7],j=b[2]*B+b[5]*Q+b[8],V=U/R,te=O/R,ge=F/j,Be=q/j;if(c[S]==w){A=ge-V,_=Be-te;let J=V*ge+te*Be,ye=V*Be-te*ge,ie=V*V+te*te,Ie=ge*ge+Be*Be,We=Math.sqrt(ie*Ie);m=ye/We,x=J/We}let Oe=o*Math.pow(2,-r),Xe=1-Math.sqrt(c[S]/E),le=(o-Oe)*Xe+Oe,L=1-le;u[D]=V*L+ge*le,u[D+1]=te*L+Be*le}let M=1-d;for(let S=0;S<8;S+=2){let D=u[S],B=u[S+1];u[S]=D*M+(D*x-B*m)*d,u[S+1]=B*M+(D*m+B*x)*d}for(let S=0;S<8;S+=2)u[S]+=A*s,u[S+1]+=_*s;return ze.default.Matrix.perspective(ze.default.Matrix.Zeros(3),ze.default.Matrix(2,4,g),ze.default.Matrix(2,4,u))}static find6DoFHomographyNDC(t,n,o){let r=n.columns/2;if(r<4)return ze.default.Promise.reject(new Z("Too few data points to compute a perspective warp"));let s=n.block(0,1,0,r-1),d=n.block(0,1,r,2*r-1),c=o.mask||ze.default.Matrix.Zeros(1,r);return Os(s,d,t,Object.assign({mask:c},o)).then(u=>{let g=u.at(0,0);if(Number.isNaN(g))throw new xt("Can't compute a perspective warp: bad keypoints");let f=0,b=c.read();for(let _=0;_<r;_++)f+=b[_];let A=f/r;return[u,A]})}static findPerspectiveWarpNDC(t,n){let o=t.columns/2;if(o<4)return ze.default.Promise.reject(new Z("Too few data points to compute a perspective warp"));let r=t.block(0,1,0,o-1),s=t.block(0,1,o,2*o-1),d=n.mask||ze.default.Matrix.Zeros(1,o);return ze.default.Matrix.findHomography(ze.default.Matrix.Zeros(3),r,s,Object.assign({mask:d},n)).then(c=>{let u=c.at(0,0);if(Number.isNaN(u))throw new xt("Can't compute a perspective warp: bad keypoints");let g=0,f=d.read();for(let A=0;A<o;A++)g+=f[A];let b=g/o;return[c,b]})}static findAffineWarpNDC(t,n){let o=t.columns/2;if(o<3)return ze.default.Promise.reject(new Z("Too few data points to compute an affine warp"));let r=ze.default.Matrix.Eye(3),s=t.block(0,1,0,o-1),d=t.block(0,1,o,2*o-1),c=n.mask||ze.default.Matrix.Zeros(1,o);return ze.default.Matrix.findAffineTransform(r.block(0,1,0,2),s,d,Object.assign({mask:c},n)).then(u=>{let g=r.at(0,0);if(Number.isNaN(g))throw new xt("Can't compute an affine warp: bad keypoints");let f=0,b=c.read();for(let _=0;_<o;_++)f+=b[_];let A=f/o;return[r,A]})}static findPolylineNDC(t){let n=t.read(),o=[-1,1,-1,-1,1,-1,1,1],r=new Array(4);for(let s=0,d=0;s<4;s++,d+=2){let c=o[d],u=o[d+1],g=n[0]*c+n[3]*u+n[6],f=n[1]*c+n[4]*u+n[7],b=n[2]*c+n[5]*u+n[8];r[s]=ze.default.Point2(g/b,f/b)}return r}static refineMatchingPairs(t){let n=t.length,o=new Array(n);for(let c=0;c<n;c++)o[c]=t[c][1];let r=this._distributeKeypoints(o),s=r.length,d=new Array(s);for(let c=0;c<s;c++)d[c]=t[r[c]];return d}static _distributeKeypoints(t){let n=As,o=n*n,r=t.length,s=new Array(2*r);for(let g=0,f=0;g<r;g++,f+=2)s[f]=t[g].x,s[f+1]=t[g].y;this._normalizePoints(s);let d=new Array(o).fill(-1);for(let g=0,f=0;g<r;g++,f+=2){let b=Math.floor(s[f]*n),_=Math.floor(s[f+1]*n)*n+b;d[_]<0&&(d[_]=g)}let c=0,u=new Array(o);for(let g=0;g<o;g++)d[g]>=0&&(u[c++]=d[g]);return u.length=c,u}static _normalizePoints(t){X.assert(t.length%2==0);let n=t.length/2;if(n==0)return t;let o=Number.POSITIVE_INFINITY,r=Number.NEGATIVE_INFINITY,s=Number.POSITIVE_INFINITY,d=Number.NEGATIVE_INFINITY;for(let g=0,f=0;g<n;g++,f+=2){let b=t[f],A=t[f+1];o=b<o?b:o,s=A<s?A:s,r=b>r?b:r,d=A>d?A:d}let c=r-o+1,u=d-s+1;for(let g=0,f=0;g<n;g++,f+=2)t[f]=(t[f]-o)/c,t[f+1]=(t[f+1]-s)/u;return t}}});var De,Fi,Hs=ce(()=>{"use strict";De=Re(be(),1);bn();pn();Fe();Le();Ft();Fi=class extends tt{constructor(n){super("training",n);this._currentImageIndex=0;this._trainingMap={keypoints:[],referenceImageIndex:[],referenceImages:[]}}onEnterState(n){let o=this._imageTracker.database;if(o.count==0)throw new Si("Can't train the Image Tracker: the Reference Image Database is empty");this._currentImageIndex=0,this._trainingMap.keypoints.length=0,this._trainingMap.referenceImageIndex.length=0,this._trainingMap.referenceImages.length=0,X.log(`Image Tracker: training using ${o.count} reference image${o.count!=1?"s":""}`),o._lock();for(let r of o)this._trainingMap.referenceImages.push(r)}onLeaveState(){this._pipeline.release(),this._pipelineReleased=!0}_beforeUpdate(){let n=this._pipeline.node("source"),o=this._pipeline.node("screen"),r=this._pipeline.node("keypointScaler"),s=this._trainingMap.referenceImages[this._currentImageIndex];n.media=s.media;let d=this._imageTracker.resolution,c=.8,u=s.aspectRatio;return o.size=X.resolution(d,u),o.size.width=Math.round(o.size.width*c),o.size.height=Math.round(o.size.height*c),r.transform=oe.rasterToNIS(o.size),X.log(`Image Tracker: training using reference image "${s.name}" at ${o.size.width}x${o.size.height}...`),De.default.Promise.resolve()}_afterUpdate(n){let o=this._trainingMap.referenceImages[this._currentImageIndex],r=n.keypoints,s=n.image;X.log(`Image Tracker: found ${r.length} keypoints in reference image "${o.name}"`);let d={keypointsNIS:s!==void 0?r:void 0,image:s};for(let c=0;c<r.length;c++)this._trainingMap.keypoints.push(r[c]),this._trainingMap.referenceImageIndex.push(this._currentImageIndex);return++this._currentImageIndex,this._currentImageIndex<this._trainingMap.referenceImages.length?De.default.Promise.resolve({nextState:"training",trackerOutput:d}):De.default.Promise.resolve({nextState:"scanning",trackerOutput:d,nextStateSettings:{database:this._trainingMap.keypoints}})}_createPipeline(){let n=De.default.Pipeline(),o=De.default.Image.Source("source"),r=De.default.Transform.Resize("screen"),s=De.default.Filter.Greyscale(),d=De.default.Filter.GaussianBlur(),c=De.default.Filter.Nightvision(),u=De.default.Image.Multiplexer("nightvisionMux"),g=De.default.Image.Pyramid(),f=De.default.Keypoint.Detector.FAST("fast"),b=De.default.Keypoint.Descriptor.ORB(),A=De.default.Keypoint.SubpixelRefiner(),_=De.default.Image.Pyramid(),m=De.default.Filter.GaussianBlur(),x=De.default.Keypoint.Clipper(),E=De.default.Keypoint.Transformer("keypointScaler"),w=De.default.Keypoint.Sink("keypoints");return o.media=null,r.size=De.default.Size(0,0),d.kernelSize=De.default.Size(Ze,Ze),d.sigma=De.default.Vector2($e,$e),c.gain=Ct,c.offset=Pt,c.decay=vt,c.quality=At,u.port=Ei?1:0,f.levels=4,f.scaleFactor=1.19,f.threshold=60,f.capacity=8192,A.method=bt,m.kernelSize=De.default.Size(pt,pt),m.sigma=De.default.Vector2(ut,ut),x.size=1024,E.transform=De.default.Matrix.Eye(3),w.turbo=!1,o.output().connectTo(r.input()),r.output().connectTo(s.input()),s.output().connectTo(u.input("in0")),s.output().connectTo(c.input()),c.output().connectTo(u.input("in1")),u.output().connectTo(g.input()),g.output().connectTo(f.input()),f.output().connectTo(x.input()),s.output().connectTo(m.input()),m.output().connectTo(_.input()),x.output().connectTo(A.input("keypoints")),_.output().connectTo(A.input("image")),s.output().connectTo(d.input()),d.output().connectTo(b.input("image")),A.output().connectTo(b.input("keypoints")),b.output().connectTo(E.input()),E.output().connectTo(w.input()),n.init(o,r,s,c,u,g,f,d,b,x,m,_,A,E,w),n}referenceImageOfKeypoint(n){let o=this.referenceImageIndexOfKeypoint(n);return o<0?null:this._trainingMap.referenceImages[o]}referenceImageIndexOfKeypoint(n){let o=this._trainingMap.referenceImageIndex.length;if(n<0||n>=o)return-1;let r=this._trainingMap.referenceImageIndex[n];return r<0||r>=this._trainingMap.referenceImages.length?-1:r}referenceKeypoint(n){return n<0||n>=this._trainingMap.keypoints.length?null:this._trainingMap.keypoints[n]}}});var Te,io,wA,Ui,Ys=ce(()=>{"use strict";Te=Re(be(),1);bn();pn();Fe();Le();Ft();io=0,wA=1,Ui=class extends tt{constructor(t){super("scanning",t),this._counter=0,this._bestScore=0,this._bestHomography=Te.default.Matrix.Eye(3)}onEnterState(t){let n=this._pipeline.node("imagePortalMux"),o=this._pipeline.node("lshTables"),r=t.database;this._counter=0,this._bestScore=0,n.port=io,r!==void 0&&(o.keypoints=r)}_beforeUpdate(){let t=this._pipeline.node("keypointScaler"),n=this.screenSize;return t.transform=oe.rasterToNIS(n),Te.default.Promise.resolve()}_afterUpdate(t){let n=this._pipeline.node("imagePortalMux"),o=t.keypoints,r=t.image,s={keypointsNIS:o,polylineNDC:[],image:r};n.port=wA;let d=this._selectGoodMatches(o);if(d.length<20)return this._counter=0,this._bestScore=0,Te.default.Promise.resolve({nextState:"scanning",trackerOutput:s});let c=this._findMatchingPairs(d),u=oe.compilePairsOfKeypointsNDC(c);return this._findHomographyNDC(u).then(([g,f])=>{f>=this._bestScore&&this._counter<29&&(this._bestScore=f,this._bestHomography=g,n.port=io);let b=oe.findPolylineNDC(g);if(s.polylineNDC.push(...b),++this._counter<30)return{nextState:"scanning",trackerOutput:s};let A=this._pipeline.node("imagePortalSink"),_=this._imageTracker._referenceImageOfKeypoint(d[0].matches[0].index);if(!_)throw new Qn("Can't track an unknown reference image");return{nextState:"pre-tracking-a",nextStateSettings:{homography:this._bestHomography,snapshot:A,referenceImage:_},trackerOutput:s}}).catch(g=>(X.warning(`Error when scanning: ${g.toString()}`),{nextState:"scanning",trackerOutput:s}))}_selectGoodMatches(t){let n=Object.create(null);for(let r=t.length-1;r>=0;r--){let s=t[r];if(s.matches[0].index>=0&&s.matches[1].index>=0){let d=s.matches[0].distance,c=s.matches[1].distance;if(d<=.7*c){let u=this._imageTracker._referenceImageIndexOfKeypoint(s.matches[0].index);u>=0&&(Object.prototype.hasOwnProperty.call(n,u)||(n[u]=[]),n[u].push(s))}}}let o=[];for(let r in n)n[r].length>o.length&&(o=n[r]);return o}_findHomographyNDC(t){return oe.findPerspectiveWarpNDC(t,{method:"pransac",reprojectionError:ts,numberOfHypotheses:512*2,bundleSize:128})}_findMatchingPairs(t){let n=new Array(t.length);for(let o=t.length-1;o>=0;o--){let r=t[o],s=this._imageTracker._referenceKeypoint(r.matches[0].index);if(s==null)throw new Qn(`Invalid keypoint match index: ${r.matches[0].index} from ${r.toString()}`);n[o]=[s,r]}return n}_createPipeline(){let t=Te.default.Pipeline(),n=Te.default.Image.Source("source"),o=Te.default.Transform.Resize("screen"),r=Te.default.Filter.Greyscale(),s=Te.default.Filter.GaussianBlur(),d=Te.default.Filter.Nightvision(),c=Te.default.Image.Multiplexer("nightvisionMux"),u=Te.default.Image.Pyramid(),g=Te.default.Keypoint.Detector.FAST(),f=Te.default.Keypoint.Descriptor.ORB(),b=Te.default.Keypoint.Clipper(),A=Te.default.Keypoint.Matcher.StaticLSHTables("lshTables"),_=Te.default.Keypoint.Matcher.LSHKNN(),m=Te.default.Keypoint.Transformer("keypointScaler"),x=Te.default.Keypoint.SinkOfMatchedKeypoints("keypoints"),E=Te.default.Image.Portal.Sink("imagePortalSink"),w=Te.default.Image.Portal.Source("imagePortalSource"),M=Te.default.Image.Multiplexer("imagePortalMux"),S=Te.default.Image.Buffer(),D=Te.default.Transform.Resize();return n.media=null,o.size=Te.default.Size(0,0),s.kernelSize=Te.default.Size(Ze,Ze),s.sigma=Te.default.Vector2($e,$e),d.gain=Ct,d.offset=Pt,d.decay=vt,d.quality=At,c.port=Ei?1:0,g.levels=4,g.scaleFactor=1.19,g.threshold=60,g.capacity=2048,b.size=512,A.keypoints=[],A.numberOfTables=ns,A.hashSize=is,_.k=2,_.quality="default",w.source=E,M.port=io,D.size=Te.default.Size(0,0),D.scale=Te.default.Vector2(1,1),m.transform=Te.default.Matrix.Eye(3),x.turbo=!0,n.output().connectTo(o.input()),o.output().connectTo(r.input()),r.output().connectTo(s.input()),r.output().connectTo(c.input("in0")),r.output().connectTo(d.input()),d.output().connectTo(c.input("in1")),c.output().connectTo(u.input()),u.output().connectTo(g.input()),g.output().connectTo(b.input()),s.output().connectTo(f.input("image")),b.output().connectTo(f.input("keypoints")),f.output().connectTo(_.input("keypoints")),A.output().connectTo(_.input("lsh")),b.output().connectTo(m.input()),m.output().connectTo(x.input()),_.output().connectTo(x.input("matches")),n.output().connectTo(S.input()),S.output().connectTo(M.input("in0")),w.output().connectTo(D.input()),D.output().connectTo(M.input("in1")),M.output().connectTo(E.input()),t.init(n,o,r,s,d,c,u,g,f,b,A,_,m,x,E,w,M,S,D),t}}});var Me,Xi,Ws=ce(()=>{"use strict";Me=Re(be(),1);bn();pn();Fe();Ft();Xi=class extends tt{constructor(t){super("pre-tracking-a",t),this._homography=Me.default.Matrix.Eye(3),this._referenceImage=null,this._snapshot=null}onEnterState(t){let n=t.homography,o=t.referenceImage,r=t.snapshot;this._homography=n,this._referenceImage=o,this._snapshot=r}_beforeUpdate(){let t=this.screenSize,n=this._pipeline.node("source"),o=this._pipeline.node("imageRectifier"),r=this._pipeline.node("keypointScaler"),s=this._pipeline.node("borderClipper");n.media=this._referenceImage.media,s.imageSize=t,s.borderSize=Me.default.Vector2(t.width*zt,t.height*zt),r.transform=oe.rasterToNIS(t);let d=wt,c=oe.bestFitAspectRatioNDC(t,this._referenceImage),u=oe.bestFitScaleNDC(c,d),g=oe.NDCToRaster(t),f=oe.rasterToNDC(t);return o.transform.setTo(g.times(u).times(f)).then(()=>{})}_afterUpdate(t){let n=this._referenceImage,o=this._pipeline.node("keypointPortalSink"),r=t.keypoints,s=t.image,d={keypointsNIS:s!==void 0?r:void 0,image:s};return r.length<xi?(X.warning(`Can't pre-track "${n.name}" in ${this.name}!`),Me.default.Promise.resolve({nextState:"scanning",trackerOutput:d})):Me.default.Promise.resolve({nextState:"pre-tracking-b",trackerOutput:d,nextStateSettings:{referenceKeypointPortalSink:o,referenceImage:this._referenceImage,snapshot:this._snapshot,homography:this._homography}})}_createPipeline(){let t=Me.default.Pipeline(),n=Me.default.Image.Source("source"),o=Me.default.Transform.Resize("screen"),r=Me.default.Filter.Greyscale(),s=Me.default.Transform.PerspectiveWarp("imageRectifier"),d=Me.default.Filter.Nightvision(),c=Me.default.Image.Multiplexer(),u=Me.default.Keypoint.Detector.Harris(),g=Me.default.Keypoint.Descriptor.ORB(),f=Me.default.Filter.GaussianBlur(),b=Me.default.Keypoint.Clipper(),A=Me.default.Keypoint.BorderClipper("borderClipper"),_=Me.default.Filter.GaussianBlur(),m=Me.default.Keypoint.SubpixelRefiner(),x=Me.default.Keypoint.Transformer("keypointScaler"),E=Me.default.Keypoint.Portal.Sink("keypointPortalSink"),w=Me.default.Keypoint.Sink("keypoints");return n.media=null,s.transform=Me.default.Matrix.Eye(3),o.size=Me.default.Size(0,0),d.gain=Ct,d.offset=Pt,d.decay=vt,d.quality=At,c.port=xn?1:0,f.kernelSize=Me.default.Size(Ze,Ze),f.sigma=Me.default.Vector2($e,$e),_.kernelSize=Me.default.Size(pt,pt),_.sigma=Me.default.Vector2(ut,ut),u.quality=En,u.capacity=Sn,m.method=bt,b.size=yn,A.imageSize=o.size,A.borderSize=Me.default.Vector2(0,0),x.transform=Me.default.Matrix.Eye(3),w.turbo=!1,n.output().connectTo(o.input()),o.output().connectTo(r.input()),r.output().connectTo(s.input()),s.output().connectTo(c.input("in0")),s.output().connectTo(d.input()),d.output().connectTo(c.input("in1")),c.output().connectTo(u.input()),u.output().connectTo(A.input()),A.output().connectTo(b.input()),s.output().connectTo(_.input()),_.output().connectTo(m.input("image")),b.output().connectTo(m.input("keypoints")),c.output().connectTo(f.input()),f.output().connectTo(g.input("image")),m.output().connectTo(g.input("keypoints")),g.output().connectTo(x.input()),x.output().connectTo(w.input()),x.output().connectTo(E.input()),t.init(n,o,r,s,d,c,u,A,b,_,m,f,g,x,w,E),t}}});var me,Vs,TA,Gi,Js=ce(()=>{"use strict";me=Re(be(),1);bn();pn();Fe();Le();Ft();Vs=0,TA=1,Gi=class extends tt{constructor(t){super("pre-tracking-b",t),this._homography=me.default.Matrix.Eye(3),this._referenceImage=null,this._snapshot=null,this._referenceKeypointPortalSink=null,this._iterations=0}onEnterState(t){let n=t.homography,o=t.referenceImage,r=t.snapshot,s=t.referenceKeypointPortalSink,d=this._pipeline.node("sourceMux"),c=this._pipeline.node("sourceBuffer");this._homography=n,this._referenceImage=o,this._snapshot=r,this._referenceKeypointPortalSink=s,this._iterations=0,d.port=Vs,c.frozen=!1}_beforeUpdate(){let t=this.screenSize,n=this._pipeline.node("imageRectifier"),o=this._pipeline.node("keypointScaler"),r=this._pipeline.node("borderClipper"),s=this._pipeline.node("imagePortalSource"),d=this._pipeline.node("referenceKeypointPortalSource");s.source=this._snapshot,d.source=this._referenceKeypointPortalSink,r.imageSize=t,r.borderSize=me.default.Vector2(t.width*zt,t.height*zt),o.transform=oe.rasterToNIS(t);let c=wt,u=oe.bestFitAspectRatioNDC(t,this._referenceImage),g=oe.bestFitScaleNDC(u,c),f=this._homography.inverse(),b=oe.NDCToRaster(t),A=oe.rasterToNDC(t);return n.transform.setTo(b.times(g.times(f)).times(A)).then(()=>{})}_afterUpdate(t){let n=this._referenceImage,o=t.referenceKeypoints,r=t.keypoints,s=t.image,d=this._pipeline.node("keypointPortalSink"),c=this._pipeline.node("sourceMux"),u=this._pipeline.node("sourceBuffer"),g={keypointsNIS:s!==void 0?r:void 0,image:s};return me.default.Promise.resolve().then(()=>{let f=this._findMatchingPairs(o,r);if(f.length<xi)throw new ft("Not enough data points");let b=oe.compilePairsOfKeypointsNDC(f);return this._findMotionNDC(b)}).then(f=>(c.port=TA,u.frozen=!0,oe.interpolateHomographies(this._homography,me.default.Matrix(f.times(this._homography)),ss,as))).then(f=>this._homography.setTo(f)).then(f=>({nextState:++this._iterations<cs?"pre-tracking-b":"tracking",trackerOutput:g,nextStateSettings:{templateKeypoints:r,templateKeypointPortalSink:d,referenceImage:this._referenceImage,homography:this._homography,initialScreenSize:this.screenSize}})).catch(f=>(X.warning(`Can't pre-track "${n.name}" in ${this.name}! ${f.toString()}`),{nextState:"scanning",trackerOutput:g}))}_findMotionNDC(t){return oe.findPerspectiveWarpNDC(t,{method:"pransac",reprojectionError:os,numberOfHypotheses:512,bundleSize:128,mask:void 0}).then(([n,o])=>{let r=wt,s=oe.bestFitAspectRatioNDC(this.screenSize,this._referenceImage),d=oe.bestFitScaleNDC(s,r),u=oe.inverseBestFitScaleNDC(s,r).times(n).times(d),g=this._homography,f=g.inverse();return g.times(u).times(f)})}_findMatchingPairs(t,n){let o=[];for(let r=0;r<n.length;r++){let s=n[r];if(s.matches[0].index>=0&&s.matches[1].index>=0){let d=s.matches[0].distance,c=s.matches[1].distance;if(d<=rs*c){let u=t[s.matches[0].index];o.push([u,s])}}}return o}_createPipeline(){let t=me.default.Pipeline(),n=me.default.Image.Source("source"),o=me.default.Image.Portal.Source("imagePortalSource"),r=me.default.Image.Multiplexer("sourceMux"),s=me.default.Image.Buffer("sourceBuffer"),d=me.default.Keypoint.Portal.Source("referenceKeypointPortalSource"),c=me.default.Transform.Resize("screen"),u=me.default.Filter.Greyscale(),g=me.default.Transform.PerspectiveWarp("imageRectifier"),f=me.default.Filter.Nightvision(),b=me.default.Image.Multiplexer(),A=me.default.Keypoint.Detector.Harris(),_=me.default.Keypoint.Descriptor.ORB(),m=me.default.Filter.GaussianBlur(),x=me.default.Keypoint.Clipper(),E=me.default.Keypoint.BorderClipper("borderClipper"),w=me.default.Filter.GaussianBlur(),M=me.default.Keypoint.SubpixelRefiner(),S=me.default.Keypoint.Matcher.BFKNN(),D=me.default.Keypoint.Transformer("keypointScaler"),B=me.default.Keypoint.SinkOfMatchedKeypoints("keypoints"),Q=me.default.Keypoint.Portal.Sink("keypointPortalSink"),U=me.default.Keypoint.Sink("referenceKeypoints");return n.media=null,o.source=null,r.port=Vs,s.frozen=!1,d.source=null,g.transform=me.default.Matrix.Eye(3),c.size=me.default.Size(0,0),f.gain=Ct,f.offset=Pt,f.decay=vt,f.quality=At,b.port=xn?1:0,m.kernelSize=me.default.Size(Ze,Ze),m.sigma=me.default.Vector2($e,$e),w.kernelSize=me.default.Size(pt,pt),w.sigma=me.default.Vector2(ut,ut),A.quality=En,A.capacity=Sn,M.method=bt,x.size=yn,E.imageSize=c.size,E.borderSize=me.default.Vector2(0,0),S.k=2,D.transform=me.default.Matrix.Eye(3),B.turbo=!1,o.output().connectTo(r.input("in0")),n.output().connectTo(s.input()),s.output().connectTo(r.input("in1")),r.output().connectTo(c.input()),c.output().connectTo(u.input()),u.output().connectTo(g.input()),g.output().connectTo(b.input("in0")),g.output().connectTo(f.input()),f.output().connectTo(b.input("in1")),b.output().connectTo(A.input()),A.output().connectTo(E.input()),E.output().connectTo(x.input()),g.output().connectTo(w.input()),w.output().connectTo(M.input("image")),x.output().connectTo(M.input("keypoints")),b.output().connectTo(m.input()),m.output().connectTo(_.input("image")),M.output().connectTo(_.input("keypoints")),_.output().connectTo(S.input("keypoints")),d.output().connectTo(S.input("database")),_.output().connectTo(D.input()),D.output().connectTo(Q.input()),D.output().connectTo(B.input()),S.output().connectTo(B.input("matches")),d.output().connectTo(U.input()),t.init(n,o,s,r,c,d,u,g,f,b,A,E,x,w,M,m,_,S,D,B,Q,U),t}}});var Yn,js=ce(()=>{"use strict";Kn();Yn=class extends Jt{constructor(t,n){super(t),this._referenceImage=n}get referenceImage(){return this._referenceImage}}});var ro,Hi,Dt,oo=ce(()=>{"use strict";ro=Re(be(),1);Le();Hi=1e-6,Dt=class y{constructor(t=0,n=0,o=0,r=1){this._x=+t,this._y=+n,this._z=+o,this._w=+r}static Identity(){return new y(0,0,0,1)}static FromAxisAngle(t,n){if(t.dot(t)<Hi*Hi)return y.Identity();let o=Math.sin(n/2),r=Math.cos(n/2),s=t.normalized(),d=s.x*o,c=s.y*o,u=s.z*o,g=r;return new y(d,c,u,g)}get x(){return this._x}get y(){return this._y}get z(){return this._z}get w(){return this._w}length(){let t=this._x,n=this._y,o=this._z,r=this._w;return Math.sqrt(t*t+n*n+o*o+r*r)}equals(t){return this._w===t._w&&this._x===t._x&&this._y===t._y&&this._z===t._z}toString(){let t=this._x.toFixed(4),n=this._y.toFixed(4),o=this._z.toFixed(4),r=this._w.toFixed(4);return`Quaternion(${t},${n},${o},${r})`}_normalize(){let t=this.length();return t<Hi?this:(this._x/=t,this._y/=t,this._z/=t,this._w/=t,this)}_conjugate(){return this._x=-this._x,this._y=-this._y,this._z=-this._z,this}_set(t,n,o,r){return this._x=+t,this._y=+n,this._z=+o,this._w=+r,this}_copyFrom(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._w=t._w,this}_toRotationMatrix(){let t=this.length();if(t<Hi)return ro.default.Matrix.Eye(3);let n=this._x/t,o=this._y/t,r=this._z/t,s=this._w/t,d=2*n*n,c=2*o*o,u=2*r*r,g=2*n*o,f=2*n*r,b=2*o*r,A=2*s*n,_=2*s*o,m=2*s*r;return ro.default.Matrix(3,3,[1-(c+u),g+m,f-_,g-m,1-(d+u),b+A,f+_,b-A,1-(d+c)])}_fromRotationMatrix(t){if(t.rows!=3||t.columns!=3)throw new Z;let n=t.read(),o=n[0],r=n[1],s=n[2],d=n[3],c=n[4],u=n[5],g=n[6],f=n[7],b=n[8],A=1+o+c+b,_=+(u>=f)-+(u<f),m=+(g>=s)-+(g<s),x=+(r>=d)-+(r<d),E=.5*Math.sqrt(Math.max(0,A)),w=.5*Math.sqrt(Math.max(0,A-2*(c+b))),M=.5*Math.sqrt(Math.max(0,A-2*(o+b))),S=.5*Math.sqrt(Math.max(0,A-2*(o+c))),D=Math.sqrt(w*w+M*M+S*S+E*E);return this._x=w*_/D,this._y=M*m/D,this._z=S*x/D,this._w=E/D,this}_clone(){return new y(this._x,this._y,this._z,this._w)}}});var MA,Zs,Ue,Wn=ce(()=>{"use strict";MA=1e-6,Zs=null,Ue=class y{constructor(t=0,n=0,o=0){this._x=+t,this._y=+n,this._z=+o}static Zero(){return new y(0,0,0)}static get ZERO(){return Zs||(Zs=Object.freeze(y.Zero()))}get x(){return this._x}get y(){return this._y}get z(){return this._z}length(){let t=this._x,n=this._y,o=this._z;return Math.sqrt(t*t+n*n+o*o)}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z}distanceTo(t){let n=this._x-t._x,o=this._y-t._y,r=this._z-t._z;return Math.sqrt(n*n+o*o+r*r)}directionTo(t){return t._clone()._subtract(this)._normalize()}cross(t){let n=this._y*t._z-this._z*t._y,o=this._z*t._x-this._x*t._z,r=this._x*t._y-this._y*t._x;return new y(n,o,r)}normalized(){return this._clone()._normalize()}plus(t){return this._clone()._add(t)}minus(t){return this._clone()._subtract(t)}times(t){return this._clone()._scale(t)}equals(t){return this._x===t._x&&this._y===t._y&&this._z===t._z}toString(){let t=this._x.toFixed(5),n=this._y.toFixed(5),o=this._z.toFixed(5);return`Vector3(${t},${n},${o})`}_set(t,n,o){return this._x=+t,this._y=+n,this._z=+o,this}_copyFrom(t){return this._x=t._x,this._y=t._y,this._z=t._z,this}_normalize(){let t=this.length();return t<MA?this:(this._x/=t,this._y/=t,this._z/=t,this)}_add(t){return this._x+=t._x,this._y+=t._y,this._z+=t._z,this}_subtract(t){return this._x-=t._x,this._y-=t._y,this._z-=t._z,this}_scale(t){return this._x*=t,this._y*=t,this._z*=t,this}_applyRotationQuaternion(t){let n=t.x,o=t.y,r=t.z,s=t.w,d=this._x,c=this._y,u=this._z,g=n*n,f=o*o,b=r*r,A=2*n*o,_=2*n*r,m=2*o*r,x=2*s*n,E=2*s*o,w=2*s*r;return this._x=(1-2*(f+b))*d+(A-w)*c+(_+E)*u,this._y=(A+w)*d+(1-2*(g+b))*c+(m-x)*u,this._z=(_-E)*d+(m+x)*c+(1-2*(g+f))*u,this}_clone(){return new y(this._x,this._y,this._z)}}});var ea,qi,Yi,$s,BA,NA,Wi,ta=ce(()=>{"use strict";ea=Re(be(),1);Pn();oo();Wn();Le();qi=5,Yi=12,$s=Ue.Zero(),BA=Dt.Identity(),NA=new Dt(0,0,0,0),Wi=class{constructor(){this._smoothRotation=Dt.Identity(),this._smoothTranslation=Ue.Zero(),this._rotationSample=Array.from({length:Yi},()=>Dt.Identity()),this._translationSample=Array.from({length:qi},()=>Ue.Zero()),this._isEmpty=!0}reset(){this._rotationSample.forEach(t=>t._copyFrom(BA)),this._translationSample.forEach(t=>t._copyFrom($s)),this._isEmpty=!0}feed(t){let n=t.read();if(t.rows!=3||t.columns!=4)throw new Z;if(Number.isNaN(n[0]*n[9]))return!1;let o=this._rotationSample[Yi-1];for(let s=Yi-1;s>0;s--)this._rotationSample[s]=this._rotationSample[s-1];this._rotationSample[0]=o._fromRotationMatrix(t.block(0,2,0,2));let r=this._translationSample[qi-1];for(let s=qi-1;s>0;s--)this._translationSample[s]=this._translationSample[s-1];return this._translationSample[0]=r._set(n[9],n[10],n[11]),this._isEmpty&&(this._rotationSample.forEach((s,d)=>d>0&&s._copyFrom(this._rotationSample[0])),this._translationSample.forEach((s,d)=>d>0&&s._copyFrom(this._translationSample[0])),this._isEmpty=!1),!0}output(){let t=Ye.powerPreference=="low-power"?1.5:1,n=Math.ceil(qi/t),o=Math.ceil(Yi/t),r=this._smoothTranslation._copyFrom($s),s=this._smoothRotation._copyFrom(NA);for(let c=0,u=2/(n*n+n);c<n;c++){let g=this._translationSample[c],f=(n-c)*u;r._set(r.x+g.x*f,r.y+g.y*f,r.z+g.z*f)}for(let c=0;c<o;c++){let u=this._rotationSample[c],g=1/o;u.w<0&&u._set(-u.x,-u.y,-u.z,-u.w),s._set(s.x+u.x*g,s.y+u.y*g,s.z+u.z*g,s.w+u.w*g)}let d=s._toRotationMatrix().read();return d.push(r.x,r.y,r.z),ea.default.Matrix(3,4,d)}}});var He,RA,ra,DA,kA,Vn,Vi,na,ia,QA,LA,KA,OA,Jn,oa=ce(()=>{"use strict";He=Re(be(),1);Fe();ta();Le();RA=60,ra=2,DA=.017453292519943295,kA=1e-6,Vn=0,Vi=4,na=6,ia=7,QA=30,LA=15,KA=ra*.01,OA=5,Jn=class{constructor(){this._imageSize=He.default.Size(0,0),this._matrix=He.default.Matrix.Eye(3,4),this._intrinsics=[1,0,0,0,1,0,0,0,1],this._extrinsics=[1,0,0,0,1,0,0,0,1,0,0,0],this._filter=new Wi,this._flipZ=He.default.Matrix(4,4,[1,0,0,0,0,1,0,0,0,0,-1,0,0,0,0,1])}init(t,n=ra){X.log("Initializing the camera model..."),X.assert(t>0&&n>1e-5),t>=1?(this._imageSize.width=t*n,this._imageSize.height=n):(this._imageSize.width=n,this._imageSize.height=n/t),this.reset()}release(){return this.reset(),null}update(t){X.assert(t.rows==3&&t.columns==3);let n=this._convertToImageSpace(t),o=n.read(),r=o[0],s=o[3],d=o[6],c=o[1],u=o[4],g=o[7],f=o[2],b=o[5],A=o[8],_=d*(c*b-u*f)-g*(r*b-s*f)+A*(r*u-s*c);if(Math.abs(_)<kA||Number.isNaN(_))return He.default.Promise.reject(new xt("Can't update the camera model using an invalid homography matrix"));let m=this._estimatePose(n);this._filter.feed(m)&&(this._extrinsics=this._filter.output().read());let x=this._flipZ,E=He.default.Matrix(3,3,this._intrinsics),w=He.default.Matrix(3,4,this._extrinsics);return this._matrix.setToSync(E.times(w).times(x)),He.default.Promise.resolve(this._matrix)}reset(){this._resetIntrinsics(),this._resetExtrinsics()}get matrix(){return this._matrix}get imageSize(){return this._imageSize}get aspectRatio(){return this._imageSize.width/this._imageSize.height}get focalLength(){return this._intrinsics[Vn]}get fovx(){let t=this._imageSize.width/2;return 2*Math.atan(t/this._intrinsics[Vn])}get fovy(){let t=this._imageSize.height/2;return 2*Math.atan(t/this._intrinsics[Vi])}intrinsicsMatrix(){return He.default.Matrix(3,3,this._intrinsics)}computeViewMatrix(){let t=this._extrinsics;return He.default.Matrix(4,4,[t[0],t[1],-t[2],0,t[3],t[4],-t[5],0,-t[6],-t[7],+t[8],0,t[9],t[10],-t[11],1])}computeProjectionMatrix(t,n){let o=this._intrinsics[Vn],r=this._intrinsics[Vi],s=this._imageSize.width/2,d=this._imageSize.height/2,c=t*(s/o),u=t*(d/r),g=-u,f=-c;return He.default.Matrix(4,4,[2*t/(c-f),0,0,0,0,2*t/(u-g),0,0,(c+f)/(c-f),(u+g)/(u-g),-(n+t)/(n-t),-1,0,0,-2*n*t/(n-t),0])}_resetExtrinsics(){this._extrinsics.fill(0),this._extrinsics[0]=this._extrinsics[4]=this._extrinsics[8]=1,this._filter.reset()}_resetIntrinsics(){let t=Math.max(this._imageSize.width,this._imageSize.height),n=0,o=0,r=t/2/Math.tan(DA*RA/2),s=r;this._intrinsics[Vn]=r,this._intrinsics[Vi]=s,this._intrinsics[na]=n,this._intrinsics[ia]=o}_convertToImageSpace(t){let n=this._imageSize.width/2,o=this._imageSize.height/2,r=He.default.Matrix(3,3,[n,0,0,0,o,0,0,0,1]);return He.default.Matrix(r.times(t))}_normalizeHomography(t){let n=this._intrinsics[na],o=this._intrinsics[ia],r=this._intrinsics[Vn],s=this._intrinsics[Vi],d=n/r,c=o/s,u=t.read(),g=u[0]/r-d*u[2],f=u[3]/r-d*u[5],b=u[6]/r-d*u[8],A=u[1]/s-c*u[2],_=u[4]/s-c*u[5],m=u[7]/s-c*u[8],x=u[2],E=u[5],w=u[8];return He.default.Matrix(3,3,[g,A,x,f,_,E,b,m,w])}_estimatePartialPose(t){let n=t.read(),o=n[0],r=n[3],s=n[6],d=n[1],c=n[4],u=n[7],g=n[2],f=n[5],b=n[8],A=o*o+d*d+g*g,_=r*r+c*c+f*f,m=Math.sqrt(A),x=Math.sqrt(_),E=Math.max(m,x),M=(b>=0?1:-1)/E;if(Number.isNaN(M))return He.default.Matrix(3,3,new Array(9).fill(Number.NaN));let S=new Array(6);S[0]=M*o,S[1]=M*d,S[2]=M*g,S[3]=M*r,S[4]=M*c,S[5]=M*f,S=this._refineRotation(S),M=S[0]*o+S[1]*d+S[2]*g,M+=S[3]*r+S[4]*c+S[5]*f,M/=A+_;let D=new Array(3);return D[0]=M*s,D[1]=M*u,D[2]=M*b,He.default.Matrix(3,3,S.concat(D))}_refineRotation(t){let[n,o,r,s,d,c]=t,u=n*n+o*o+r*r,g=s*s+d*d+c*c,f=n*s+o*d+r*c,b=(u-g)*(u-g)+4*f*f,A=Math.sqrt(b),_=(u+g+A)/2,m=(u+g-A)/2,x=g-_-f*(1+f)/(u-_),E=Math.sqrt(x*x/(1+x*x)),w=E/x,M=g-m-f*(1+f)/(u-m),S=Math.sqrt(M*M/(1+M*M)),D=S/M,B=Math.sqrt(_),Q=Math.sqrt(m),U=E*E/B+S*S/Q,O=E*w/B+S*D/Q,R=w*w/B+D*D/Q;return[U*n+O*s,U*o+O*d,U*r+O*c,O*n+R*s,O*o+R*d,O*r+R*c]}_refineTranslation(t,n,o){let r=t.read(),s=r[0],d=r[3],c=r[6],u=r[1],g=r[4],f=r[7],b=r[2],A=r[5],_=r[8],m=n[0],x=n[3],E=n[1],w=n[4],M=n[2],S=n[5],D=OA,B=new Array(D*D),Q=new Array(D*D),U=this._imageSize.width/2,O=this._imageSize.height/2;for(let le=0,L=0;L<D;L++)for(let J=0;J<D;J++,le++)B[le]=L/(D-1)*2-1,Q[le]=J/(D-1)*2-1,B[le]*=U,Q[le]*=O;let R=B.length,F=new Array(R),q=new Array(R),j=new Array(R);for(let le=0;le<R;le++)F[le]=B[le]*s+Q[le]*d+c,q[le]=B[le]*u+Q[le]*g+f,j[le]=B[le]*b+Q[le]*A+_;let V=3*R,te=new Array(V*3),ge=new Array(V);for(let le=0,L=0;L<R;le+=3,L++)te[le]=te[le+V+1]=te[le+V+V+2]=0,te[le+V]=-(te[le+1]=j[L]),te[le+2]=-(te[le+V+V]=q[L]),te[le+V+V+1]=-(te[le+V+2]=F[L]),ge[le]=j[L]*(B[L]*E+Q[L]*w)-q[L]*(B[L]*M+Q[L]*S),ge[le+1]=-j[L]*(B[L]*m+Q[L]*x)+F[L]*(B[L]*M+Q[L]*S),ge[le+2]=q[L]*(B[L]*m+Q[L]*x)-F[L]*(B[L]*E+Q[L]*w);let Be=new Array(3*R),Oe=new Array(3),Xe=new Array(3*R),qe=new Array(3);qe[0]=o[0],qe[1]=o[1],qe[2]=o[2];for(let le=0;le<LA;le++){for(let ie=0;ie<V;ie++){Be[ie]=0;for(let Ie=0;Ie<3;Ie++)Be[ie]+=te[Ie*V+ie]*qe[Ie];Be[ie]-=ge[ie]}for(let ie=0;ie<3;ie++){Oe[ie]=0;for(let Ie=0;Ie<V;Ie++)Oe[ie]+=te[ie*V+Ie]*Be[Ie]}for(let ie=0;ie<V;ie++){Xe[ie]=0;for(let Ie=0;Ie<3;Ie++)Xe[ie]+=te[Ie*V+ie]*Oe[Ie]}let L=0;for(let ie=0;ie<3;ie++)L+=Oe[ie]*Oe[ie];if(L<KA)break;let J=0;for(let ie=0;ie<V;ie++)J+=Xe[ie]*Xe[ie];let ye=L/J;if(Number.isNaN(ye))break;for(let ie=0;ie<3;ie++)qe[ie]-=ye*Oe[ie]}return qe}_computeFullRotation(t){let n=t[0],o=t[3],r=t[1],s=t[4],d=t[2],c=t[5],u=r*c-d*s,g=d*o-n*c,f=n*s-r*o;return n*(s*f-g*c)-r*(o*f-u*c)+d*(o*g-u*s)<0&&(u=-u,g=-g,f=-f),[n,r,d,o,s,c,u,g,f]}_estimatePose(t){let n=this._normalizeHomography(t),o=He.default.Matrix.Eye(3),r=He.default.Matrix(n);for(let f=0;f<QA;f++){let b=this._estimatePartialPose(r);o.setToSync(b.times(o)),r.setToSync(r.times(b.inverse()))}let s=o.read(),d=s.slice(0,6),c=s.slice(6,9),u=this._refineTranslation(n,d,c),g=this._computeFullRotation(d);return He.default.Matrix(3,4,g.concat(u))}}});var rn,Ji=ce(()=>{"use strict";rn=class{constructor(t){this._transform=t}get transform(){return this._transform}}});var so,wn,on,ji=ce(()=>{"use strict";so=Re(be(),1);Le();Wn();oo();wn=1e-6,on=class y{constructor(t){if(t.rows!=4||t.columns!=4)throw new Z("A Transform expects a 4x4 transformation matrix");this._matrix=t,this._inverse=null,this._position=Ue.Zero(),this._orientation=Dt.Identity(),this._scale=new Ue(1,1,1),this._isDecomposed=!1,this._isPositionComputed=!1,this._right=Ue.ZERO,this._up=Ue.ZERO,this._forward=Ue.ZERO}get matrix(){return this._matrix}get inverse(){return this._inverse===null&&(this._inverse=new y(this._inverseMatrix())),this._inverse}get position(){return this._isPositionComputed||this._computePosition(),this._position}get orientation(){return this._isDecomposed||this._decompose(),this._orientation}get scale(){return this._isDecomposed||this._decompose(),this._scale}get right(){return this._right===Ue.ZERO&&(this._right=this._scaleAndRotate(new Ue(1,0,0))._normalize()),this._right}get up(){return this._up===Ue.ZERO&&(this._up=this._scaleAndRotate(new Ue(0,1,0))._normalize()),this._up}get forward(){return this._forward===Ue.ZERO&&(this._forward=this._scaleAndRotate(new Ue(0,0,-1))._normalize()),this._forward}_scaleAndRotate(t){let n=this._matrix.read(),o=Math.abs(n[15])<wn?Number.NaN:1/n[15],r=t.x,s=t.y,d=t.z,c=n[0]*r+n[4]*s+n[8]*d,u=n[1]*r+n[5]*s+n[9]*d,g=n[2]*r+n[6]*s+n[10]*d;return t._set(c*o,u*o,g*o)}_decompose(){let t=this._matrix.read(),n=Math.abs(t[15])<wn?Number.NaN:1/t[15],o=t[12]*n,r=t[13]*n,s=t[14]*n,d=t[0]*n,c=t[1]*n,u=t[2]*n,g=t[4]*n,f=t[5]*n,b=t[6]*n,A=t[8]*n,_=t[9]*n,m=t[10]*n,x=A*(c*b-f*u)+m*(d*f-g*c)-_*(d*b-g*u),E=+(x>=0)-+(x<0),w=Math.sqrt(d*d+g*g+A*A),M=Math.sqrt(c*c+f*f+_*_),S=Math.sqrt(u*u+b*b+m*m)*E;if(w<wn||M<wn||S*E<wn){this._position._set(o,r,s),this._scale._set(w,M,S),this._orientation._copyFrom(Dt.Identity()),this._isDecomposed=!0,this._isPositionComputed=!0;return}let D=1/w,B=1/M,Q=1/S,U=d*D,O=c*D,R=u*D,F=g*B,q=f*B,j=b*B,V=A*Q,te=_*Q,ge=m*Q;this._position._set(o,r,s),this._scale._set(w,M,S),this._orientation._fromRotationMatrix(so.default.Matrix(3,3,[U,O,R,F,q,j,V,te,ge])),this._isDecomposed=!0,this._isPositionComputed=!0}_computePosition(){let t=this._matrix.read(),n=Math.abs(t[15])<wn?Number.NaN:1/t[15];this._position._set(t[12]*n,t[13]*n,t[14]*n),this._isPositionComputed=!0}_inverseMatrix(){return so.default.Matrix(this._matrix.inverse())}}});var sa,Zi,aa=ce(()=>{"use strict";sa=Re(be(),1);Ji();ji();Zi=class extends rn{constructor(t){let n=t.computeViewMatrix(),o=sa.default.Matrix(n.inverse()),r=new on(o);super(r),this._viewMatrix=n}get viewMatrix(){return this._viewMatrix}}});var ca,la,zA,$i,da=ce(()=>{"use strict";ca=Re(be(),1);Le();la=.1,zA=1e4*la,$i=class{constructor(t,n=la,o=zA){if(this._near=+n,this._far=+o,this._near>=this._far)throw new Z(`View expects near < far (found near = ${this._near} and far = ${this._far})`);if(this._near<=0)throw new Z(`View expects a positive near (found ${this._near})`);this._camera=t,this._projectionMatrix=t.computeProjectionMatrix(this._near,this._far),this._inverseProjection=null}get projectionMatrix(){return this._projectionMatrix}get _projectionMatrixInverse(){return this._inverseProjection===null&&(this._inverseProjection=ca.default.Matrix(this._projectionMatrix.inverse())),this._inverseProjection}get aspect(){return this._camera.aspectRatio}get fovx(){return this._camera.fovx}get fovy(){return this._camera.fovy}get near(){return this._near}get far(){return this._far}}});var jn,Aa=ce(()=>{"use strict";jn=class{constructor(t,n){this._origin=t,this._direction=n}get origin(){return this._origin}get direction(){return this._direction}}});var er,tr,pa=ce(()=>{"use strict";er=Re(be(),1);Ji();aa();da();ji();Wn();Aa();tr=class{constructor(t){this._pose=new Zi(t),this._views=[new $i(t)]}get pose(){return this._pose}get view(){return this._views[0]}convertToViewerSpace(t){let n=t.transform.matrix,o=this._pose.viewMatrix,r=er.default.Matrix(o.times(n)),s=new on(r);return new rn(s)}raycast(t){let n=this.view._projectionMatrixInverse,o=this._pose.transform.matrix,r=er.default.Matrix(4,1,[t.x,t.y,0,1]),s=n.times(r),d=o.times(s),c=er.default.Matrix(d).read(),u=this._pose.transform.position,g=new Ue(c[0]/c[3],c[1]/c[3],c[2]/c[3])._subtract(u)._normalize();return new jn(u,g)}forwardRay(){let t=this._pose.transform.position,n=this._pose.transform.forward;return new jn(t,n)}}});var he,ua,FA,nr,ha=ce(()=>{"use strict";he=Re(be(),1);ao();bn();js();pn();Fe();oa();pa();Ji();ji();Le();Ft();Pn();ua=!0,FA=he.default.Matrix.Eye(3),nr=class extends tt{constructor(t){super("tracking",t),this._referenceImage=null,this._warpHomography=he.default.Matrix.Eye(3),this._poseHomography=he.default.Matrix.Eye(3),this._prevHomography=he.default.Matrix.Eye(3),this._templateKeypoints=[],this._initialScreenSize=he.default.Size(1,1),this._lastOutput={},this._lastPipelineOutput={keypoints:[]},this._skipCounter=0,this._counter=0,this._lostCounter=0,this._camera=new Jn,this._fixedCamera=new Jn}onEnterState(t){let n=t.homography,o=t.referenceImage,r=t.templateKeypoints,s=t.templateKeypointPortalSink,d=t.initialScreenSize,c=this._pipeline.node("keypointPortalSource");if(!o)throw new Pe("Can't track a null reference image");this._referenceImage=o,this._warpHomography.setToSync(n),this._poseHomography.setToSync(n),this._prevHomography.setToSync(n),this._templateKeypoints=r,this._initialScreenSize=he.default.Size(d.width,d.height),this._lastOutput={},this._lastPipelineOutput={keypoints:[]},this._skipCounter=0,this._counter=0,this._lostCounter=0,c.source=s;let u=d.width/d.height;this._camera.init(u),this._fixedCamera.init(u);let g=new Yn("targetfound",o);this._imageTracker.dispatchEvent(g),X.log(`Tracking image "${o.name}"...`)}onLeaveState(){X.log(`No longer tracking image "${this._referenceImage.name}"!`),this._fixedCamera.release(),this._camera.release();let t=new Yn("targetlost",this._referenceImage);this._imageTracker.dispatchEvent(t)}_beforeUpdate(){let t=this._pipeline.node("imageRectifier"),n=this._pipeline.node("borderClipper"),o=this._pipeline.node("keypointScaler"),r=this.screenSize;n.imageSize=r,n.borderSize=he.default.Vector2(r.width*zt,r.height*zt),o.transform=oe.rasterToNIS(r);let s=wt,d=oe.bestFitAspectRatioNDC(r,this._referenceImage),c=oe.bestFitScaleNDC(d,s),u=this._warpHomography.inverse(),g=oe.NDCToRaster(r),f=oe.rasterToNDC(r);return t.transform.setTo(g.times(c.times(u)).times(f)).then(()=>{})}_gpuUpdate(){if(!ua||Ye.powerPreference=="low-power")return super._gpuUpdate();if((this._skipCounter=1-this._skipCounter)==0){let n=this._lastPipelineOutput.keypoints;return this._lastPipelineOutput.keypoints=n,he.default.Promise.resolve(this._lastPipelineOutput)}return super._gpuUpdate().then(t=>(this._lastPipelineOutput=t,t))}_afterUpdate(t){let n=t.keypoints,o=t.image,r=this._referenceImage,s=this.screenSize;return he.default.Promise.resolve().then(()=>{if(!s.equals(this._initialScreenSize))throw new ft("Detected a change in screen size");let d=this._findMatchingPairs(this._templateKeypoints,n),c=oe.refineMatchingPairs(d);if(c.length<ls)throw new ft("Not enough data points to continue the tracking");let u=oe.compilePairsOfKeypointsNDC(c);return this._find6DoFPerspectiveMotionNDC(u)}).then(d=>{let u=Ye.powerPreference=="low-power"?2:1;return oe.interpolateHomographies(FA,he.default.Matrix(d),hs*u,gs)}).then(d=>(this._prevHomography.setToSync(this._warpHomography),this._warpHomography.setToSync(d.times(this._warpHomography)),oe.interpolateHomographies(this._prevHomography,this._warpHomography,fs,ms))).then(d=>{if(this._poseHomography.setToSync(d),Number.isNaN(this._poseHomography.at(0,0)))throw new xt("Bad homography");let c=oe.bestFitScaleNDC(1/r.aspectRatio),u=he.default.Matrix(this._poseHomography.times(c));return this._camera.update(u)}).then(()=>{let d=this._camera.computeViewMatrix(),c=new on(d),u=new rn(c),g=new tr(this._fixedCamera),f={pose:u,referenceImage:r,tracker:this._imageTracker},A={exports:new ir(this._imageTracker,[f],g),keypoints:n,image:o,polylineNDC:oe.findPolylineNDC(this._poseHomography),camera:this._camera};return this._lastOutput=A,this._lostCounter=0,{nextState:"tracking",trackerOutput:A}}).catch(d=>d instanceof ft&&++this._lostCounter<=us?{nextState:"tracking",trackerOutput:this._lastOutput}:(X.warning(`The target has been lost! ${d.toString()}`),{nextState:"scanning",trackerOutput:{}}))}_findAffineMotionNDC(t){return oe.findAffineWarpNDC(t,{method:"pransac",reprojectionError:Ci,numberOfHypotheses:512*2,bundleSize:128,mask:void 0}).then(([n,o])=>{let r=wt,s=oe.bestFitAspectRatioNDC(this.screenSize,this._referenceImage),d=oe.bestFitScaleNDC(s,r),u=oe.inverseBestFitScaleNDC(s,r).times(n).times(d),g=this._warpHomography,f=g.inverse();return g.times(u).times(f)}).catch(n=>{throw new ft("Can't find an affine motion",n)})}_findPerspectiveMotionNDC(t){return oe.findPerspectiveWarpNDC(t,{method:"pransac",reprojectionError:Ci,numberOfHypotheses:512*2,bundleSize:128,mask:void 0}).then(([n,o])=>{let r=wt,s=oe.bestFitAspectRatioNDC(this.screenSize,this._referenceImage),d=oe.bestFitScaleNDC(s,r),u=oe.inverseBestFitScaleNDC(s,r).times(n).times(d),g=this._poseHomography,f=g.inverse();return g.times(u).times(f)}).catch(n=>{throw new ft("Can't find a perspective motion",n)})}_find6DoFPerspectiveMotionNDC(t){let n=this._camera.intrinsicsMatrix();return oe.find6DoFHomographyNDC(n,t,{reprojectionError:Ci,numberOfHypotheses:100}).then(([o,r])=>{let s=wt,d=oe.bestFitAspectRatioNDC(this.screenSize,this._referenceImage),c=oe.bestFitScaleNDC(d,s),g=oe.inverseBestFitScaleNDC(d,s).times(o).times(c),f=this._warpHomography,b=f.inverse();return f.times(g).times(b)}).catch(o=>{throw new ft("Can't find a perspective motion",o)})}_findMatchingPairs(t,n){let o=[];for(let r=0;r<n.length;r++){let s=n[r];if(s.matches[0].index>=0&&s.matches[1].index>=0){let d=s.matches[0].distance,c=s.matches[1].distance;if(d<=ps*c){let u=t[s.matches[0].index];o.push([u,s])}}}return o}_createPipeline(){let t=he.default.Pipeline(),n=he.default.Image.Source("source"),o=he.default.Transform.Resize("screen"),r=he.default.Filter.Greyscale(),s=he.default.Transform.PerspectiveWarp("imageRectifier"),d=he.default.Filter.Nightvision(),c=he.default.Image.Multiplexer(),u=he.default.Filter.GaussianBlur(),g=he.default.Keypoint.Detector.Harris(),f=he.default.Keypoint.Descriptor.ORB(),b=he.default.Keypoint.Matcher.BFKNN(),A=he.default.Keypoint.SubpixelRefiner(),_=he.default.Filter.GaussianBlur(),m=he.default.Keypoint.BorderClipper("borderClipper"),x=he.default.Keypoint.Clipper(),E=he.default.Keypoint.Transformer("keypointScaler"),w=he.default.Keypoint.Portal.Source("keypointPortalSource"),M=he.default.Keypoint.SinkOfMatchedKeypoints("keypoints");return n.media=null,o.size=he.default.Size(0,0),s.transform=he.default.Matrix.Eye(3),d.gain=Ct,d.offset=Pt,d.decay=vt,d.quality=At,c.port=xn?1:0,u.kernelSize=he.default.Size(Ze,Ze),u.sigma=he.default.Vector2($e,$e),_.kernelSize=he.default.Size(pt,pt),_.sigma=he.default.Vector2(ut,ut),g.quality=En,g.capacity=Sn,A.method=bt,x.size=yn,m.imageSize=o.size,m.borderSize=he.default.Vector2(0,0),E.transform=he.default.Matrix.Eye(3),b.k=2,w.source=null,M.turbo=ua,n.output().connectTo(o.input()),o.output().connectTo(r.input()),r.output().connectTo(s.input()),s.output().connectTo(c.input("in0")),s.output().connectTo(d.input()),d.output().connectTo(c.input("in1")),c.output().connectTo(g.input()),g.output().connectTo(m.input()),m.output().connectTo(x.input()),s.output().connectTo(_.input()),_.output().connectTo(A.input("image")),x.output().connectTo(A.input("keypoints")),s.output().connectTo(u.input()),u.output().connectTo(f.input("image")),A.output().connectTo(f.input("keypoints")),w.output().connectTo(b.input("database")),f.output().connectTo(b.input("keypoints")),f.output().connectTo(E.input()),E.output().connectTo(M.input()),b.output().connectTo(M.input("matches")),t.init(n,o,r,s,d,c,u,g,A,m,x,_,f,b,w,E,M),t}}});var rr,ir,UA,ga,or,ao=ce(()=>{"use strict";rr=Re(be(),1);bi();Le();vs();ws();Hs();Ys();Ws();Js();ha();Fe();Kn();ir=class extends Zt{constructor(t,n,o){super(),this.tracker=t,this.trackables=n,this.viewer=o}},UA={resolution:"sm"},ga="image-tracker",or=class extends jt{constructor(t){super(),this._state={initial:new Ni(this),training:new Fi(this),scanning:new Ui(this),"pre-tracking-a":new Xi(this),"pre-tracking-b":new Gi(this),tracking:new nr(this)},this._session=null,this._source=null,this._activeStateName="initial",this._lastOutput={},this._database=new Bi,t=Object.assign({},UA,t),this._resolution=t.resolution}get type(){return ga}is(t){return t===ga}get state(){return this._activeStateName}get database(){return this._database}get resolution(){return this._resolution}set resolution(t){}get screenSize(){return this._state[this._activeStateName].screenSize}get _output(){return this._lastOutput}get _stats(){let t=this.screenSize;return`${t.width}x${t.height} ${this.state}`}_init(t){this._session=t;for(let n of t.sources)if(n._is("video-source")){this._source=n;break}else n._is("canvas-source")&&(this._source=n);if(this._source===null)throw new Pe("The image tracker requires a suitable source of data");for(let n of Object.values(this._state))n.init();return rr.default.Promise.resolve()}_release(){for(let t of Object.values(this._state))t.release();return this._session=null,rr.default.Promise.resolve()}_update(){if(this._session==null)return rr.default.Promise.reject(new Pe("Uninitialized tracker"));let t=this._source._internalMedia,n=this._computeScreenSize(),o=this._state[this._activeStateName];return o.update(t,n).then(({trackerOutput:r,nextState:s,nextStateSettings:d})=>{this._lastOutput=r,this._activeStateName!=s&&(o.onLeaveState(),this._activeStateName=s,this._state[s].onEnterState(d||{}))})}_referenceImageOfKeypoint(t){return this._state.training.referenceImageOfKeypoint(t)}_referenceImageIndexOfKeypoint(t){return this._state.training.referenceImageIndexOfKeypoint(t)}_referenceKeypoint(t){return this._state.training.referenceKeypoint(t)}_computeScreenSize(){let t=this._source._internalMedia,n=t.width/t.height;return X.resolution(this._resolution,n)}}});var XA,fa,nt,sr=ce(()=>{"use strict";XA=1e-6,fa=null,nt=class y{constructor(t=0,n=0){this._x=+t,this._y=+n}static Zero(){return new y(0,0)}static get ZERO(){return fa||(fa=Object.freeze(y.Zero()))}get x(){return this._x}get y(){return this._y}length(){let t=this._x,n=this._y;return Math.sqrt(t*t+n*n)}dot(t){return this._x*t._x+this._y*t._y}distanceTo(t){let n=this._x-t._x,o=this._y-t._y;return Math.sqrt(n*n+o*o)}directionTo(t){return t._clone()._subtract(this)._normalize()}normalized(){return this._clone()._normalize()}plus(t){return this._clone()._add(t)}minus(t){return this._clone()._subtract(t)}times(t){return this._clone()._scale(t)}equals(t){return this._x===t._x&&this._y===t._y}toString(){let t=this._x.toFixed(5),n=this._y.toFixed(5);return`Vector2(${t},${n})`}_set(t,n){return this._x=+t,this._y=+n,this}_copyFrom(t){return this._x=t._x,this._y=t._y,this}_normalize(){let t=this.length();return t<XA?this:(this._x/=t,this._y/=t,this)}_add(t){return this._x+=t._x,this._y+=t._y,this}_subtract(t){return this._x-=t._x,this._y-=t._y,this}_scale(t){return this._x*=t,this._y*=t,this}_clone(){return new y(this._x,this._y)}}});var gn,co,ma,GA,Ia,ar,_a=ce(()=>{"use strict";gn=Re(be(),1);bi();sr();Fe();Le();co=class extends Zt{constructor(t,n){super(),this.tracker=t,this.trackables=n}},ma={pointerdown:"began",pointerup:"ended",pointermove:"moved",pointercancel:"canceled",pointerleave:"ended",pointerenter:"began"},GA={space:"normalized"},Ia="pointer-tracker",ar=class{constructor(t){let n=this._buildSettings(t);this._source=null,this._viewport=null,this._space=n.space,this._activePointers=new Map,this._newPointers=new Map,this._idMap=new Map,this._nextId=1,this._previousOutput=this._generateOutput(),this._previousUpdateTime=Number.POSITIVE_INFINITY,this._wantToReset=!1,this._resetInTheNextUpdate=this._resetInTheNextUpdate.bind(this)}_buildSettings(t){let n=Object.assign({},GA,t);if(n.space!="normalized"&&n.space!="adjusted")throw new Z(`Invalid pointer space: "${n.space}"`);return n}get type(){return Ia}is(t){return t===Ia}_init(t){X.log("Initializing PointerTracker..."),this._viewport=t.viewport;for(let n of t.sources)if(n._is("pointer-source")){this._source=n;break}return this._source===null?gn.default.Promise.reject(new Pe("A PointerTracker expects a PointerSource")):(this._source._setViewport(this._viewport),document.addEventListener("visibilitychange",this._resetInTheNextUpdate),gn.default.Promise.resolve())}_release(){return this._source=null,this._viewport=null,this._activePointers.clear(),this._newPointers.clear(),this._idMap.clear(),document.removeEventListener("visibilitychange",this._resetInTheNextUpdate),gn.default.Promise.resolve()}_update(){let t=this._viewport.canvas,n=t.getBoundingClientRect(),o=this._updateTime(),r=o>1e-5?1/o:60,s=this._findInactiveTrackables();for(let c=s.length-1;c>=0;c--)this._activePointers.delete(s[c].id);this._updateAllTrackables({phase:"stationary",velocity:nt.ZERO,deltaPosition:nt.ZERO}),this._wantToReset&&(this._reset(),this._wantToReset=!1);let d;for(;(d=this._source._consume())!==null;){if(d.target!==t)return gn.default.Promise.reject(new Pe("Invalid PointerEvent target "+d.target));if(!ma.hasOwnProperty(d.type))return gn.default.Promise.reject(new Pe("Invalid PointerEvent type "+d.type));let c=this._normalizeId(d.pointerId,d.pointerType),u=this._activePointers.get(c),g=this._newPointers.get(c),f=ma[d.type];if(d.type=="pointerdown"||d.type=="pointerenter"&&d.buttons>0){if(u)continue;if(d.button!=0&&d.pointerType=="mouse")continue}else if(!u&&!g)continue;if(u){if(f=="began"&&g&&(g.phase=="ended"||g.phase=="canceled")){if(d.type=="pointerenter")continue;this._newPointers.delete(c);continue}}else if(f=="ended"||f=="canceled"){this._newPointers.delete(c);continue}if(u?.phase=="canceled")continue;switch(d.type){case"pointermove":if(d.buttons==0||g?.phase=="began")continue;break;case"pointerenter":if(d.buttons==0||u?.phase=="began"||g?.phase=="began")continue;break;case"pointercancel":this._reset(),this._newPointers.clear();continue}let b=d.pageX-(n.left+window.scrollX),A=d.pageY-(n.top+window.scrollY),_=2*b/n.width-1,m=-(2*A/n.height-1),x=new nt(_,m);if(this._space=="adjusted"){let O=this._viewport.aspectRatio;O>=1?x._set(_,m/O):x._set(_*O,m)}let E=u?x._clone()._subtract(u.position):nt.ZERO,w=u?u.initialPosition:Object.freeze(x._clone()),M=E._clone()._scale(r),S=u?u.duration+o:0,D=u?u.movementLength+E.length():0,B=u?u.movementDuration+(D>u.movementLength?o:0):0,Q=d.isPrimary,U=d.pointerType;this._newPointers.set(c,{id:c,phase:f,position:x,deltaPosition:E,initialPosition:w,velocity:M,duration:S,movementDuration:B,movementLength:D,isPrimary:Q,kind:U,tracker:this})}return this._newPointers.forEach((c,u)=>this._activePointers.set(u,c)),this._newPointers.clear(),this._advanceAllStationaryTrackables(o),this._activePointers.size==0&&this._idMap.size>0&&this._idMap.clear(),this._previousOutput=this._generateOutput(),gn.default.Promise.resolve()}get _output(){return this._previousOutput}get _stats(){let t=this._activePointers.size,n=t!=1?"s":"";return t+" pointer"+n}get space(){return this._space}_generateOutput(){let t=[];return this._activePointers.forEach(o=>t.push(o)),{exports:new co(this,this._sortTrackables(t))}}_updateAllTrackables(t){this._activePointers.forEach((n,o)=>{this._activePointers.set(o,Object.assign({},n,t))})}_advanceAllStationaryTrackables(t){this._activePointers.forEach((n,o)=>{n.phase=="stationary"&&(n.duration+=t)})}_normalizeId(t,n){return n=="mouse"?0:(this._idMap.has(t)||this._idMap.set(t,this._nextId++),this._idMap.get(t))}_reset(){for(this._updateAllTrackables({phase:"canceled",velocity:nt.ZERO,deltaPosition:nt.ZERO});this._source._consume()!==null;);}_resetInTheNextUpdate(){this._wantToReset=!0}_sortTrackables(t){if(t.length<=1||t[0].isPrimary)return t;for(let n=1;n<t.length;n++)if(t[n].isPrimary){let o=t[n];t[n]=t[0],t[0]=o;break}return t}_findInactiveTrackables(){let t=[];return this._activePointers.forEach(n=>{(n.phase=="ended"||n.phase=="canceled")&&t.push(n)}),t}_updateTime(){let t=performance.now()*.001;this._previousUpdateTime>t&&(this._previousUpdateTime=t);let n=this._previousUpdateTime;return this._previousUpdateTime=t,t-n}}});var cr,ya=ce(()=>{"use strict";ao();_a();cr=class{static Image(t={}){return new or(t)}static ImageTracker(){return this.Image()}static Pointer(t={}){return new ar(t)}}});var fn,HA,Sa,Tn,lo=ce(()=>{"use strict";fn=Re(be(),1);Fe();Le();HA="Tap on the screen to start",Sa=!1,Tn=class{constructor(t){X.assert(t instanceof HTMLVideoElement,"Expected a video element"),this._video=t,this._media=null}get video(){return this._video}_is(t){return t==="video-source"}get _internalMedia(){if(this._media==null)throw new Pe("The media of the source of data isn't loaded");return this._media}get _stats(){let t=this._media;return t!=null?`${t.width}x${t.height} video`:"uninitialized video"}_init(){return X.log("Initializing video source..."),this._prepareVideo(this._video).then(t=>(X.log("The video is prepared"),fn.default.load(t).then(n=>{X.log(`Source of data is a ${n.width}x${n.height} video`),this._media=n})))}_release(){return this._media&&this._media.release(),this._media=null,fn.default.Promise.resolve()}_prepareVideo(t){return t.setAttribute("playsinline",""),this._handleAutoPlay(t).finally(()=>(X.isWebKit()&&t.hidden&&(t.hidden=!1,t.style.setProperty("opacity","0"),t.style.setProperty("position","fixed"),t.style.setProperty("left","0"),t.style.setProperty("top","0")),t))}_handleAutoPlay(t){return t.autoplay?(t.muted||(X.warning("Videos marked with autoplay should be muted",t),t.muted=!0),this._waitUntilPlayable(t).then(n=>{let o=n.play();return o===void 0?n:new fn.default.Promise((r,s)=>{o.then(()=>r(n),d=>{if(X.error("Can't autoplay video!",d,n),d.name=="NotAllowedError")X.warning("Tip: allow manual playback"),X.isIOS()&&X.warning("Is low power mode on?"),(n.hidden||!n.controls||n.parentNode===null)&&(document.body.addEventListener("pointerdown",()=>n.play()),Sa||(alert(HA),Sa=!0));else if(d.name=="NotSupportedError"){s(new dt("Unsupported video format",d));return}r(n)})})})):fn.default.Promise.resolve(t)}_waitUntilPlayable(t){return t.readyState>=3?fn.default.Promise.resolve(t):new fn.default.Promise((r,s)=>{let d=0,c=setInterval(()=>{t.readyState>=3?(clearInterval(c),r(t)):(d+=500)>=15e3&&(clearInterval(c),s(new _i("The video took too long to load")))},500)})}}});var Ao,lr,Ea=ce(()=>{"use strict";Ao=Re(be(),1);Fe();Le();lr=class{constructor(t){X.assert(t instanceof HTMLCanvasElement,"Expected a canvas element"),this._canvas=t,this._media=null}get canvas(){return this._canvas}_is(t){return t==="canvas-source"}get _internalMedia(){if(this._media==null)throw new Pe("The media of the source of data isn't loaded");return this._media}get _stats(){let t=this._media;return t!=null?`${t.width}x${t.height} canvas`:"uninitialized canvas"}_init(){return Ao.default.load(this._canvas).then(t=>{X.log(`Source of data is a ${t.width}x${t.height} canvas`),this._media=t})}_release(){return this._media&&this._media.release(),this._media=null,Ao.default.Promise.resolve()}}});var xa,qA,dr,Ca=ce(()=>{"use strict";xa=Re(be(),1);Fe();Le();lo();qA={resolution:"360p",aspectRatio:16/9,constraints:{facingMode:"environment"}},dr=class extends Tn{constructor(t){let n=document.createElement("video");super(n),this._options=Object.assign({},qA,t)}get resolution(){return this._options.resolution}_init(){let t=this._options;if(X.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new dt("Unsupported browser: no navigator.mediaDevices.getUserMedia()");if(t.aspectRatio<1)if(t.aspectRatio>0)X.warning(`CameraSource: an aspectRatio of ${t.aspectRatio} was requested. Prefer standard landscape settings instead`);else throw new Z(`Invalid aspect ratio: ${t.aspectRatio}`);let n=X.resolution(t.resolution,t.aspectRatio),o=t.constraints,r={width:{ideal:n.width},height:{ideal:n.height}},s={audio:!1,video:Object.assign({},r,o)};return new xa.default.Promise((d,c)=>{navigator.mediaDevices.getUserMedia(s).then(u=>{let g=this.video;g.onloadedmetadata=()=>{let f=g.play(),b="Access to the webcam has been granted.";if(f===void 0){X.log(b),d();return}f.then(()=>{X.log(b),d()}).catch(A=>{c(new Pe("Webcam error!",A))})},g.setAttribute("muted",""),g.muted=!0,g.setAttribute("playsinline",""),g.playsInline=!0,g.setAttribute("autoplay",""),g.autoplay=!0,g.srcObject=u}).catch(u=>{typeof OverconstrainedError<"u"&&u instanceof OverconstrainedError?c(new dt("Unsupported camera constraints: "+JSON.stringify(s),u)):c(new Ot("Please give access to the webcam and reload the page.",u))})}).then(()=>super._init())}_release(){let t=this.video;return t.srcObject.getTracks().forEach(r=>r.stop()),t.onloadedmetadata=null,t.srcObject=null,super._release()}}});var po,Ar,Pa=ce(()=>{"use strict";po=Re(be(),1);Fe();Ar=class{constructor(){this._queue=[],this._viewport=null,this._onPointerEvent=this._onPointerEvent.bind(this),this._cancelEvent=this._cancelEvent.bind(this)}_is(t){return t==="pointer-source"}_consume(){return this._queue.shift()||null}get _stats(){return"pointer input"}_init(){return X.log("Initializing PointerSource..."),po.default.Promise.resolve()}_release(){return this._setViewport(null),po.default.Promise.resolve()}_setViewport(t){if(this._viewport!==null&&(this._viewport.hud.container.style.removeProperty("pointer-events"),this._viewport._subContainer.style.removeProperty("pointer-events"),this._viewport.container.style.removeProperty("pointer-events"),this._viewport.canvas.style.removeProperty("pointer-events"),this._removeEventListeners(this._viewport.canvas)),(this._viewport=t)!==null){this._addEventListeners(this._viewport.canvas),this._viewport.canvas.style.pointerEvents="auto",this._viewport.container.style.pointerEvents="none",this._viewport._subContainer.style.pointerEvents="none",this._viewport.hud.container.style.pointerEvents="none";for(let n of this._viewport.hud.container.children)n.style.getPropertyValue("pointer-events")==""&&(n.style.pointerEvents="auto")}}_onPointerEvent(t){this._queue.push(t),t.preventDefault()}_cancelEvent(t){t.cancelable&&t.preventDefault()}_addEventListeners(t){t.addEventListener("pointerdown",this._onPointerEvent),t.addEventListener("pointerup",this._onPointerEvent),t.addEventListener("pointermove",this._onPointerEvent),t.addEventListener("pointercancel",this._onPointerEvent),t.addEventListener("pointerleave",this._onPointerEvent),t.addEventListener("pointerenter",this._onPointerEvent),t.addEventListener("touchstart",this._cancelEvent,{passive:!1})}_removeEventListeners(t){t.removeEventListener("touchstart",this._cancelEvent),t.removeEventListener("pointerenter",this._onPointerEvent),t.removeEventListener("pointerleave",this._onPointerEvent),t.removeEventListener("pointercancel",this._onPointerEvent),t.removeEventListener("pointermove",this._onPointerEvent),t.removeEventListener("pointerup",this._onPointerEvent),t.removeEventListener("pointerdown",this._onPointerEvent)}}});var pr,va=ce(()=>{"use strict";lo();Ea();Ca();Pa();pr=class{static Video(t){return new Tn(t)}static Canvas(t){return new lr(t)}static Camera(t={}){return new dr(t)}static Pointer(){return new Ar}}});var YA,WA,VA,ur,ba=ce(()=>{"use strict";Pn();zn();YA=500,WA=Object.freeze({default:"","low-power":"&#x1F50B","high-performance":"&#x26A1"}),VA="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAQCAYAAAB3AH1ZAAAAVUlEQVRIS2NkGGDAOMD2M4w6YDQE8IbAfyBgBAJSEipIDy712MzCaTiyQdRwBC4zsDoAmy8ocQQ+vRgOIDUI8UUPMVFIUvySkhaIVTvqgNEQGPAQAABSNiARgz5LggAAAABJRU5ErkJggg==",ur=class{constructor(){this._container=this._createContainer(),this._lastUpdate=0}init(t,n){t.appendChild(this._container),this._container.hidden=!n}release(){this._container.remove()}update(t,n,o,r,s,d){t>=this._lastUpdate+YA&&(this._lastUpdate=t,this._update(n,o,r,d,s))}_update(t,n,o,r,s){let d=this._label("_ar_fps");d!==null&&(d.style.color=this._color(r),d.innerText=String(r));let c=this._label("_ar_gpu");c!==null&&(c.style.color=this._color(s),c.innerText=String(s));let u=this._label("_ar_power");u!==null&&(u.innerHTML=WA[Ye.powerPreference]);let g=this._label("_ar_in");if(g!==null){let A=t.map(_=>_._stats).join(", ");g.innerText=A}let f=this._label("_ar_out");if(f!==null){let A=n.map(_=>_._stats).join(", ");f.innerText=A}let b=this._label("_ar_view");if(b!==null){let A=o.virtualSize;b.innerText=`${A.width}x${A.height} rendering`}}_label(t){return this._container.getElementsByClassName(t).item(0)}_color(t){let n="#0f0",o="#ff0",r="#f33",s=t>=50?n:t>=30?o:r,d=t>=30?n:r;return Ye.powerPreference!="low-power"?s:d}_createContainer(){let t=document.createElement("div");return t.style.position="absolute",t.style.left=t.style.top="0px",t.style.padding="0px",t.appendChild(this._createTitle()),t.appendChild(this._createContent()),t}_createTitle(){let t=document.createElement("div"),n=document.createElement("button");return t.style.display="flex",t.style.backgroundColor="#7e56c2",t.style.color="white",t.style.fontFamily="monospace",t.style.fontSize="14px",t.style.fontWeight="bold",t.style.paddingRight="4px",t.innerText="encantar.js "+st.version,n.style.width="18px",n.style.height="18px",n.style.marginRight="4px",n.style.backgroundColor="#7e56c2",n.style.backgroundImage="url("+VA+")",n.style.backgroundRepeat="no-repeat",n.style.backgroundPosition="0 0",n.style.borderWidth="2px",n.style.borderColor="#b588fb #46346a #46346a #b588fb",t.insertBefore(n,t.firstChild),n.addEventListener("click",()=>{let o=t.parentNode,r=o&&o.querySelector("._ar_details");r&&(r.hidden=!r.hidden,n.style.backgroundPosition=r.hidden?"0 0 ":"-16px 0")}),t}_createContent(){let t=document.createElement("div"),n=document.createElement("div");t.style.backgroundColor="rgba(0,0,0,0.5)",t.style.color="white",t.style.fontFamily="monospace",t.style.fontSize="14px",t.style.padding="2px",t.style.whiteSpace="pre-line",n.classList.add("_ar_details"),n.hidden=!0;let o=(r,s)=>r.insertAdjacentHTML("beforeend",s);return o(t,'FPS: <span class="_ar_fps"></span> | '),o(t,'GPU: <span class="_ar_gpu"></span> '),o(t,'<span class="_ar_power"></span>'),o(n,'IN: <span class="_ar_in"></span><br>'),o(n,'OUT: <span class="_ar_out"></span><br>'),o(n,'VIEW: <span class="_ar_view"></span>'),t.appendChild(n),t}}});var wa,JA,Ta,Ma,hr,Ba=ce(()=>{"use strict";wa="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAbUlEQVRYR+2WOQ4AIAgE5f+PVhobDZANBZAsraAwXMoqFil+f9GBj8BW8dIiKt45at/XgShStHgvmfdekwAdIIEyAmh1Z/U5ikmABPoRsLZWtt+5DUlgHgGr6qM1Pf9XnO131L7fJEQjyOqXEzjP1YAhNmUTrgAAAABJRU5ErkJggg==",JA="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAZElEQVRYR+2WwRIAEAhE9f8fTQ5OhtkLxbzOyc5rJSvBYcH3FwTIBKpHb5d57Nqm5o0aCIBAPgLDxSunq69APT8RCBdwezTLHjglDAEQgEC+QZR2EqqbjprHRgSB9wjwHX9LoAHP1YAhXF4Z/QAAAABJRU5ErkJggg==",Ta=64,Ma=24,hr=class{constructor(t){this._viewport=t,this._button=this._createButton(),this._handleFullscreenEvent=this._handleFullscreenEvent.bind(this)}init(t,n){t.appendChild(this._button),this._button.hidden=!n,this._viewport.addEventListener("fullscreenchange",this._handleFullscreenEvent)}release(){this._viewport.removeEventListener("fullscreenchange",this._handleFullscreenEvent),this._button.remove()}_createButton(){let t=document.createElement("button");t.style.position="absolute",t.style.bottom=Ma+"px",t.style.right=Ma+"px",t.style.width=Ta+"px",t.style.height=Ta+"px",t.style.opacity="0.5",t.style.cursor="pointer",t.style.outline="none",t.style["-webkit-tap-highlight-color"]="transparent",t.draggable=!1,t.style.backgroundColor="transparent",t.style.backgroundImage="url("+wa+")",t.style.backgroundSize="cover",t.style.imageRendering="pixelated",t.style.borderColor="white",t.style.borderStyle="solid",t.style.borderWidth="2px",t.style.borderRadius="8px";let n=()=>{t.style.backgroundColor="#ffd500",t.style.borderColor="#ffd500",t.style.opacity="1.0"},o=()=>{t.style.backgroundColor="transparent",t.style.borderColor="white",t.style.opacity="0.5"};return t.addEventListener("pointerdown",n),t.addEventListener("pointerup",o),t.addEventListener("pointerleave",o),t.addEventListener("click",()=>{this._viewport.fullscreen?this._viewport.exitFullscreen():this._viewport.requestFullscreen().catch(r=>{alert("Can't enable the fullscreen mode. "+r.toString())})}),t}_handleFullscreenEvent(t){let n=this._viewport.fullscreen?JA:wa;this._button.style.backgroundImage="url("+n+")"}}});var jA,ZA,$A,ep,tp,np,ip,Na,rp,gr,Ra=ce(()=>{"use strict";jA="Purchase your copy of encantar.js!",ZA=`encantar.js is an open, fast, easy-to-use, and broadly compatible Augmented Reality solution that works in any modern browser and web server. It has no vendor lock-in, DRM, artificial scarcity, or gatekeeping. Your projects are yours to keep and deploy.

Bringing open Augmented Reality to you isn't free of cost. The depth and breadth of this work are huge, requiring considerable time and skill. I'm a developer working independently on this software from the ground up. Your purchase will support me directly.

This software respects you and puts you in control \u2014 values often overlooked in the tech industry. Do you value your freedom? Will you contribute to making open-source sustainable? With a one-time purchase, you'll become a backer of open-source AR \u2014 and together, we'll make technology empower us all.`,$A="Buy now",ep="Try it",tp="https://alemart.github.io/encantar-js/buy",np=86400,ip=np,Na="encantar-reminder-0.4.6-dev",rp=1,gr=class{constructor(){this._dialog=this._createDialog()}init(t){this._dialog!==null&&(t.appendChild(this._dialog),setTimeout(()=>this._show(),500))}release(){this._dialog!==null&&this._dialog.remove()}_show(){return this._dialog===null?!1:(this._dialog.showModal(),!0)}_close(){if(this._dialog===null||!this._dialog.open)return!1;let t=Math.floor(Date.now()*.001);return localStorage.setItem(Na,String(t)),this._dialog.close(),!0}_isEnabled(){if(rp&1)return!1;let t=Math.floor(Date.now()*.001),n=Number(localStorage.getItem(Na)??"0");return t>=n+ip||n>=t}_createDialog(){let t="transparent",n="whitesmoke",o="#6366f1",r=n,s="gold",d="black",c="sans-serif",u="#333",g="16px",f=o,b="20px";if(!this._isEnabled()||typeof HTMLDialogElement>"u")return null;let A=document.createElement("dialog"),_=document.createElement("div"),m=document.createElement("h1"),x=document.createElement("p"),E=document.createElement("div"),w=document.createElement("button"),M=document.createElement("button"),S=document.createElement("button");A.style.width="95%",A.style.minWidth="300px",A.style.borderRadius="8px",A.style.border="none",A.style.backgroundColor=n,A.style.padding="0",A.style.boxShadow="4px 4px 20px rgba(0,0,0,0.75)",A.style.userSelect="none",A.addEventListener("click",B=>A===B.target&&A.close()),_.style.textAlign="center",_.style.fontSize=g,_.style.fontFamily=c,_.style.color=u,_.style.padding="20px",_.style.margin="0",A.appendChild(_),m.style.fontSize=b,m.style.color=f,m.style.margin="0",m.style.fontWeight="bold",m.innerText=jA,_.appendChild(m),x.innerText=ZA,x.style.padding="8px 0",x.style.textAlign="justify",_.appendChild(x),E.style.display="flex",E.style.justifyContent="space-evenly",_.appendChild(E);let D=(B,Q,U,O)=>()=>{B.style.backgroundColor=Q,B.style.color=U,B.style.border="2px solid "+O};return w.style.cursor="pointer",w.style.fontSize=g,w.style.fontWeight="bold",w.style.fontFamily=c,w.style.color=r,w.style.backgroundColor=o,w.style.border="2px solid "+o,w.style.padding="12px 24px",w.style.outline="none",w.style.minWidth="120px",w.style["-webkit-tap-highlight-color"]=t,w.innerText=$A,w.setAttribute("autofocus",""),w.addEventListener("click",()=>{location.href=tp,this._close()}),w.addEventListener("pointerdown",D(w,s,d,s)),w.addEventListener("pointerup",D(w,o,r,o)),w.addEventListener("pointerleave",D(w,o,r,o)),E.appendChild(w),M.style.cursor="pointer",M.style.fontSize=g,M.style.fontWeight="bold",M.style.fontFamily=c,M.style.color=o,M.style.backgroundColor=r,M.style.border="2px solid "+o,M.style.padding="12px 24px",M.style.marginLeft="12px",M.style.outline="none",M.style.minWidth="120px",w.style["-webkit-tap-highlight-color"]=t,M.style["-webkit-tap-highlight-color"]=t,M.innerText=ep,M.addEventListener("click",()=>this._close()),M.addEventListener("pointerdown",D(M,s,d,s)),M.addEventListener("pointerup",D(M,r,o,o)),M.addEventListener("pointerleave",D(M,r,o,o)),E.appendChild(M),S.style.cursor="pointer",S.style.fontSize=g,S.style.fontFamily=c,S.style.color=u,S.style.opacity="0.5",S.style.position="absolute",S.style.top="8px",S.style.right="8px",S.style.border="none",S.style.padding="8px",S.style.backgroundColor=t,S.style.outline="none",S.style["-webkit-tap-highlight-color"]=t,S.innerHTML="&#x2715;",S.addEventListener("click",()=>this._close()),_.appendChild(S),A}}});var mn,Mn,Bn,fr,Da=ce(()=>{"use strict";ba();Ba();Ra();Fe();fr=class{constructor(t,n,o=null){fi(this,mn);fi(this,Mn);fi(this,Bn);this._container=o||this._createContainer(n),this._isOwnContainer=o==null,this._container.parentElement!==n&&(this._container.remove(),n.insertAdjacentElement("afterbegin",this._container)),this._container.hidden||(X.warning("The container of the HUD should have the hidden attribute"),this._container.hidden=!0),this._internalContainer=n.attachShadow({mode:"closed"}),this._internalContainer.appendChild(document.createElement("slot")),mi(this,mn,new ur),mi(this,Mn,new hr(t)),mi(this,Bn,new gr)}get container(){return this._container}get visible(){return this._visible}set visible(t){}get _statsPanel(){return Vt(this,mn)}_init(t,n,o){let r=this._internalContainer;Vt(this,mn).init(r,n),Vt(this,Mn).init(r,o),Vt(this,Bn).init(r);for(let d of r.children)d.style.getPropertyValue("pointer-events")==""&&(d.style.pointerEvents="auto"),d.style.getPropertyValue("z-index")==""&&(d.style.zIndex="1000000");let s=this._container;s.style.position="absolute",s.style.left=s.style.top="0px",s.style.right=s.style.bottom="0px",s.style.padding=s.style.margin="0px",s.style.zIndex=String(t),s.style.userSelect="none",this._visible=!0}_release(){this._visible=!1,Vt(this,Bn).release(),Vt(this,Mn).release(),Vt(this,mn).release(),this._isOwnContainer&&(this._isOwnContainer=!1,this._container.remove())}_createContainer(t){let n=document.createElement("div");return n.hidden=!0,t.insertAdjacentElement("afterbegin",n),n}get _visible(){return!this._container.hidden}set _visible(t){this._container.hidden=!t}};mn=new WeakMap,Mn=new WeakMap,Bn=new WeakMap});var ht,mr,op,So,sp,ap,cp,lp,dp,ka,uo,ho,go,fo,mo,Ir,_r,Zn,Io,_o,yo,yr,Qa=ce(()=>{"use strict";zn();ht=Re(be(),1);Da();sr();Fe();Kn();Le();mr=class extends Jt{},op={container:null,hudContainer:null,resolution:"lg",style:"best-fit",canvas:null,fullscreenUI:!0},So=0,sp=So+0,ap=So+1,cp=So+2,lp=100,dp=500,ka=5,uo=class{constructor(t){if(t==null)throw new Z("Unspecified viewport container");if(!(t instanceof HTMLElement))throw new Z("Invalid viewport container");this._container=t,this._subContainer=document.createElement("div"),t.appendChild(this._subContainer)}get container(){return this._container}get subContainer(){return this._subContainer}init(){this._container.style.touchAction="none",this._container.style.backgroundColor="black"}release(){this._container.style.removeProperty("background-color"),this._container.style.removeProperty("touch-action")}},ho=class{constructor(t,n,o=null){if(o!==null&&!(o instanceof HTMLCanvasElement))throw new Z("Not a canvas: "+o);this._originalCSSTextOfForegroundCanvas="",o!==null&&(this._originalCSSTextOfForegroundCanvas=o.style.cssText,o.style.cssText=""),this._foregroundCanvas=this._styleCanvas(o??this._createCanvas(n),ap),this._foregroundCanvas.style.background="transparent",this._backgroundCanvas=this._styleCanvas(this._createCanvas(n),sp),this._backgroundCanvas.hidden=!0,this._foregroundCanvas.hidden=!0;let r="encantar.js "+st.version;this._backgroundCanvas.dataset.arEngine=r,this._foregroundCanvas.dataset.arEngine=r,t.appendChild(this._backgroundCanvas),t.appendChild(this._foregroundCanvas)}get backgroundCanvas(){return this._backgroundCanvas}get foregroundCanvas(){return this._foregroundCanvas}init(){this._backgroundCanvas.hidden=!1,this._foregroundCanvas.hidden=!1}release(){this._backgroundCanvas.hidden=!0,this._foregroundCanvas.hidden=!0,this._backgroundCanvas.style.cssText="",this._foregroundCanvas.style.cssText=this._originalCSSTextOfForegroundCanvas}_createCanvas(t){let n=document.createElement("canvas");return n.width=t.width,n.height=t.height,n}_styleCanvas(t,n){return t.style.position="absolute",t.style.left="0px",t.style.top="0px",t.style.width="100%",t.style.height="100%",t.style.zIndex=String(n),t.style.objectFit="unset",t}},go=class{constructor(t){this._viewport=t,this._container=t.container,this._boundEventHandler=this._triggerEvent.bind(this)}init(){this._container.addEventListener("fullscreenchange",this._boundEventHandler)}release(){this._container.removeEventListener("fullscreenchange",this._boundEventHandler)}request(){let t=this._container;return t.requestFullscreen===void 0?t.webkitRequestFullscreen===void 0?ht.default.Promise.reject(new dt):document.webkitFullscreenEnabled?(t.webkitRequestFullscreen(),new ht.default.Promise((n,o)=>{setTimeout(()=>{t===document.webkitFullscreenElement?(X.log("Entering fullscreen mode..."),n()):o(new TypeError)},100)})):ht.default.Promise.reject(new Ot):document.fullscreenEnabled?new ht.default.Promise((n,o)=>{t.requestFullscreen({navigationUI:"hide"}).then(()=>{X.log("Entering fullscreen mode..."),n()},o)}):ht.default.Promise.reject(new Ot)}exit(){if(document.exitFullscreen===void 0){let t=document;return t.webkitExitFullscreen===void 0?ht.default.Promise.reject(new dt):t.webkitFullscreenElement===null?ht.default.Promise.reject(new Pe("Not in fullscreen mode")):(t.webkitExitFullscreen(),new ht.default.Promise((n,o)=>{setTimeout(()=>{t.webkitFullscreenElement===null?(X.log("Exiting fullscreen mode..."),n()):o(new TypeError)},100)}))}return document.fullscreenElement===null?ht.default.Promise.reject(new Pe("Not in fullscreen mode")):new ht.default.Promise((t,n)=>{document.exitFullscreen().then(()=>{X.log("Exiting fullscreen mode..."),t()},n)})}isAvailable(){return document.fullscreenEnabled||!!document.webkitFullscreenEnabled}isActivated(){return document.fullscreenElement!==void 0?document.fullscreenElement===this._container:document.webkitFullscreenElement!==void 0?document.webkitFullscreenElement===this._container:!1}_triggerEvent(){let t=new mr("fullscreenchange");this._viewport.dispatchEvent(t)}},fo=class{constructor(t){this._viewport=t,this._canvas=null}takeSnapshot(t){let n=this._viewport,o=X.resolution(t??n.resolution,n.aspectRatio),r=this._canvas??(this._canvas=this._createCanvas(o.width,o.height)),s=r.getContext("2d");return r.width=o.width,r.height=o.height,s.imageSmoothingQuality="high",s.drawImage(n._backgroundCanvas,0,0,r.width,r.height),s.drawImage(n.canvas,0,0,r.width,r.height),new ht.default.Promise((d,c)=>{if("transferToImageBitmap"in r)try{let u=r.transferToImageBitmap();d(u)}catch(u){c(u)}else createImageBitmap(r).then(d,c)})}_createCanvas(t,n){if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(t,n);let o=document.createElement("canvas");return o.width=t,o.height=n,o}},mo=class{constructor(t){this._viewport=t,this._throttleTimer=null,this._onViewportResize=this._onViewportResize.bind(this),this._onWindowResize=this._onWindowResize.bind(this),this._onOrientationChange=this._onOrientationChange.bind(this),this._resizeStrategy=new _r,this._viewport.addEventListener("resize",this._onViewportResize),this._triggerResizeEvent()}init(){window.addEventListener("resize",this._onWindowResize),typeof screen.orientation=="object"?screen.orientation.addEventListener("change",this._onOrientationChange):window.addEventListener("orientationchange",this._onOrientationChange),this._triggerResizeEvent()}release(){typeof screen.orientation=="object"?screen.orientation.removeEventListener("change",this._onOrientationChange):window.removeEventListener("orientationchange",this._onOrientationChange),window.removeEventListener("resize",this._onWindowResize),this._viewport.removeEventListener("resize",this._onViewportResize),this._resizeStrategy.clear(this._viewport)}setStrategy(t){this._resizeStrategy.clear(this._viewport),this._resizeStrategy=t,this._triggerResizeEvent()}setStrategyByName(t){switch(t){case"best-fit":this.setStrategy(new Io);break;case"stretch":this.setStrategy(new _o);break;case"crop":this.setStrategy(new yo);break;case"inline":this.setStrategy(new _r);break;default:throw new Z("Invalid viewport style: "+t)}}_triggerResizeEvent(){let t=new mr("resize");this._viewport.dispatchEvent(t)}_onWindowResize(){this._throttleTimer!==null&&clearTimeout(this._throttleTimer),this._throttleTimer=setTimeout(()=>{this._throttleTimer=null,this._triggerResizeEvent()},lp)}async _onOrientationChange(){let t=this._viewport._backgroundCanvas;for(let n=0;n<ka;n++){await X.wait(dp/ka);let o=t.width/t.height,r=this._aspectRatioOfScreen();(o-1)*(r-1)<0&&this._triggerResizeEvent()}}_onViewportResize(t){let n=this._viewport,o=n.canvas,r=n.virtualSize;o.width=r.width,o.height=r.height;let s=n._backgroundCanvas,d=n._realSize;s.width=d.width,s.height=d.height,this._resizeStrategy.resize(n)}_aspectRatioOfScreen(){let t=Math.max(screen.width,screen.height),n=Math.min(screen.width,screen.height);return typeof screen.orientation=="object"?screen.orientation.type.startsWith("landscape")?t/n:n/t:typeof window.orientation=="number"?Math.abs(window.orientation)==90?t/n:n/t:document.documentElement.clientWidth>document.documentElement.clientHeight?t/n:n/t}},Ir=class{clear(t){t.container.style.cssText="",t._subContainer.style.cssText=""}},_r=class extends Ir{resize(t){let n=t.container,o=t._subContainer,r=t.virtualSize;n.style.display="inline-block",n.style.position="relative",n.style.left="0px",n.style.top="0px",n.style.width=r.width+"px",n.style.height=r.height+"px",o.style.position="absolute",o.style.left="0px",o.style.top="0px",o.style.width="100%",o.style.height="100%"}},Zn=class extends Ir{resize(t){let o=t.container;o.style.position="fixed",o.style.left="0px",o.style.top="0px",o.style.width="100vw",o.style.height="100vh",o.style.zIndex=String(1e9)}},Io=class extends Zn{resize(t){let n=t._subContainer,o=window.innerWidth/window.innerHeight,r=t.aspectRatio,s=1,d=1,c="0px",u="0px";r<=o?(d=window.innerHeight,s=Math.round(d*r),s-=s%2,c=`calc(50% - ${s>>>1}px)`):(s=window.innerWidth,d=Math.round(s/r),d-=d%2,u=`calc(50% - ${d>>>1}px)`),n.style.position="absolute",n.style.left=c,n.style.top=u,n.style.width=s+"px",n.style.height=d+"px",super.resize(t)}},_o=class extends Zn{resize(t){let n=t._subContainer;n.style.position="absolute",n.style.left="0px",n.style.top="0px",n.style.width=window.innerWidth+"px",n.style.height=window.innerHeight+"px",super.resize(t)}},yo=class extends Zn{resize(t){let n=t._subContainer,o=t._backgroundCanvas,r=t.canvas;n.style.position="absolute",n.style.left="0px",n.style.top="0px",n.style.width=window.innerWidth+"px",n.style.height=window.innerHeight+"px",o.style.objectFit="cover",r.style.objectFit="cover",super.resize(t)}clear(t){let n=t._backgroundCanvas,o=t.canvas;n.style.objectFit="unset",o.style.objectFit="unset",super.clear(t)}},yr=class extends jt{constructor(t){super();let n=Object.assign({},op,t);this._settings=Object.freeze(n);let o=window.innerWidth/window.innerHeight,r=X.resolution(n.resolution,o);this._mediaSize=()=>r,this._resolution=n.resolution,this._style=n.style,this._containers=new uo(n.container),this._hud=new fr(this,this._subContainer,n.hudContainer),this._canvases=new ho(this._subContainer,r,n.canvas),this._resizer=new mo(this),this._resizer.setStrategyByName(this._style),this._fullscreen=new go(this),this._snapshotter=new fo(this)}get container(){return this._containers.container}get style(){return this._style}get hud(){return this._hud}get resolution(){return this._resolution}get virtualSize(){return X.resolution(this._resolution,this.aspectRatio)}get aspectRatio(){let t=this._realSize;return t.width/t.height}get fullscreen(){return this._fullscreen.isActivated()}get fullscreenAvailable(){return this._fullscreen.isAvailable()}get canvas(){return this._canvases.foregroundCanvas}get _backgroundCanvas(){return this._canvases.backgroundCanvas}get _realSize(){return this._mediaSize()}get _subContainer(){return this._containers.subContainer}requestFullscreen(){return this._fullscreen.request()}exitFullscreen(){return this._fullscreen.exit()}convertToPixels(t,n="normalized"){let o=this.canvas,r=t.x,s=t.y;if(n=="adjusted"){let u=o.width/o.height;u>=1?s*=u:r/=u}else if(n!="normalized")throw new Z(`Invalid space: "${n}"`);let d=.5*(1+r)*o.width,c=.5*(1-s)*o.height;return new nt(d,c)}convertFromPixels(t,n="normalized"){let o=this.canvas,r=2*t.x/o.width-1,s=-2*t.y/o.height+1;if(n=="adjusted"){let d=o.width/o.height;d>=1?s/=d:r*=d}else if(n!="normalized")throw new Z(`Invalid space: "${n}"`);return new nt(r,s)}takeSnapshot(t){return this._snapshotter.takeSnapshot(t)}_init(t,n,o){n=="immersive"?this._style!="best-fit"&&this._style!="stretch"&&this._style!="crop"&&(X.warning(`Invalid viewport style "${this._style}" for the "${n}" mode`),this._style="best-fit",this._resizer.setStrategyByName(this._style)):n=="inline"&&this._style!="inline"&&(X.warning(`Invalid viewport style "${this._style}" for the "${n}" mode`),this._style="inline",this._resizer.setStrategyByName(this._style)),this._mediaSize=t,this._containers.init(),this._canvases.init(),this._resizer.init(),this._fullscreen.init();let r=this.fullscreenAvailable&&this._settings.fullscreenUI;this._hud._init(cp,o,r)}_release(){this._hud._release(),this._fullscreen.release(),this._resizer.release(),this._canvases.release(),this._containers.release()}}});var La,st,zn=ce(()=>{"use strict";La=Re(be(),1);Pn();qr();ya();va();Qa();sr();Wn();Fe();st=class{static startSession(t){return An.instantiate(t)}static isSupported(){return An.isSupported()}static get version(){return"0.4.6-dev"}static get Speedy(){return La.default}static get Tracker(){return cr}static get Source(){return pr}static Viewport(t){return new yr(t)}static Vector2(t,n){return new nt(t,n)}static Vector3(t,n,o){return new Ue(t,n,o)}static get Settings(){return Ye}};Object.freeze(st);X.log(`encantar.js version ${st.version}. GPU-accelerated Augmented Reality for the web by Alexandre Martins. https://encantar.dev`)});var Ap=Wo((Of,Ka)=>{zn();window.Speedy=window.Speedy||st.Speedy;Ka.exports=st});return Ap();})();
//# sourceMappingURL=encantar.min.js.map
